arXiv:1509.03649v5 [math.CT] 25 Nov 2015

Contents
I

Systems
1
Generating New Systems . . . . . . . . . . . . . . . . . . . . . . . .
1.1
Taking/Adding Objects/Relations . . . . . . . . . . . . . . .
1.2
Separating and Combining Subsystems . . . . . . . . . . . .
2
Relations and Objects . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1
Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2
Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3
Comparability . . . . . . . . . . . . . . . . . . . . . . . . .
2.4
Function . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Classifications . . . . . . . . . . . . . . . . . . . . . . . . .
Composition . . . . . . . . . . . . . . . . . . . . . . . . . .
Inverse and Unit . . . . . . . . . . . . . . . . . . . . . . . .
Two Part Function and the Meaning of Equality for Functions
Selection Function . . . . . . . . . . . . . . . . . . . . . . .
Order Preserving Function and Galois Connections [VIII] . .
Natural Pair of Functions . . . . . . . . . . . . . . . . . . . .
2.5
Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . .

II Category
3
Arrows . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1
Defining Equality of Arrows . . . . . . . . . . . . .
3.2
Classifying Arrows [I] . . . . . . . . . . . . . . . .
Invertible . . . . . . . . . . . . . . . . . . . . . . .
Left and Right Inverse . . . . . . . . . . . . . . . .
4
Some Categories . . . . . . . . . . . . . . . . . . . . . . .
4.1
Partial Order . . . . . . . . . . . . . . . . . . . . .
4.2
Algebraic Category . . . . . . . . . . . . . . . . . .
5
Functor . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1
Natural Pair of Functions in the Definition of Functor
5.2
Isomorphism . . . . . . . . . . . . . . . . . . . . .
5.3
Classification of Other Functor Types . . . . . . . .
Embedding . . . . . . . . . . . . . . . . . . . . . .
Functor for Partial Orders . . . . . . . . . . . . . .
1

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

15
15
15
16
16
17
17
18
18
18
18
18
19
19
19
20
20
21
21

.
.
.
.
.
.
.
.
.
.
.
.
.
.

23
23
23
24
24
24
25
25
25
27
29
29
30
30
31

CONTENTS

2

6
7

Opposite Category and Contravariant Functor
Algebraic Functor . . . . . . . . . . . . . .
5.4
Product Category and Bifunctor . . . . . . .
Product Functor for Common Domain . . . .
Bifunctor[IX] . . . . . . . . . . . . . . . . .
Decomposing Bifunctors . . . . . . . . . . .
5.5
Natural Transformation . . . . . . . . . . . .
Integer Systems . . . . . . . . . . . . . . . . . . . .
Rational Systems . . . . . . . . . . . . . . . . . . .
7.1
Product . . . . . . . . . . . . . . . . . . . .
7.2
Dual Orders . . . . . . . . . . . . . . . . . .
7.3
Involution . . . . . . . . . . . . . . . . . . .
7.4
Product for Rational Systems . . . . . . . .
7.5
Sum for Rational Systems . . . . . . . . . .
7.6
Embedding . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

III Set Theory
8
Set Operations . . . . . . . . . . . . . . . . . . . . . .
8.1
First Generation . . . . . . . . . . . . . . . .
Union . . . . . . . . . . . . . . . . . . . . . .
Difference . . . . . . . . . . . . . . . . . . . .
8.2
Second Generation . . . . . . . . . . . . . . .
Intersection . . . . . . . . . . . . . . . . . . .
Complement . . . . . . . . . . . . . . . . . .
8.3
Properties . . . . . . . . . . . . . . . . . . . .
Unit . . . . . . . . . . . . . . . . . . . . . . .
Inverse . . . . . . . . . . . . . . . . . . . . .
Other Representations . . . . . . . . . . . . .
Distributions . . . . . . . . . . . . . . . . . .
9
Categories . . . . . . . . . . . . . . . . . . . . . . . .
9.1
Collection Category . . . . . . . . . . . . . .
9.2
Partial Order, Under Inclusion . . . . . . . . .
9.3
Concrete Category . . . . . . . . . . . . . . .
Hom Set . . . . . . . . . . . . . . . . . . . .
Yoneda’s Lemma . . . . . . . . . . . . . . . .
Representable Functors . . . . . . . . . . . . .
10 Set Function . . . . . . . . . . . . . . . . . . . . . . .
10.1 Image . . . . . . . . . . . . . . . . . . . . . .
Image and Inclusions . . . . . . . . . . . . . .
Image and Set Operations . . . . . . . . . . .
Fiber . . . . . . . . . . . . . . . . . . . . . .
10.2 Quotient Sets and Decomposition of Functions
10.3 Sequence . . . . . . . . . . . . . . . . . . . .
Representation . . . . . . . . . . . . . . . . .
Monotonic Sequence . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

31
35
35
37
38
41
41
45
49
49
50
53
53
54
56

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

57
58
58
58
58
58
58
59
59
59
59
59
60
61
61
61
62
62
64
67
68
68
68
69
70
70
71
71
71

CONTENTS

11

12

3

Sequence of Objects for an Operation . . . . .
Sequence of Functions . . . . . . . . . . . . .
Sequence for Composition . . . . . . . . . . .
Sequence and Cartesian Product . . . . . . . .
10.4 Net . . . . . . . . . . . . . . . . . . . . . . .
Bounds . . . . . . . . . . . . . . . . . . . . .
Directed Set . . . . . . . . . . . . . . . . . . .
Definition . . . . . . . . . . . . . . . . . . . .
10.5 Matrix . . . . . . . . . . . . . . . . . . . . . .
Special Families . . . . . . . . . . . . . . . . . . . . .
11.1 Power Set . . . . . . . . . . . . . . . . . . . .
Power Functor . . . . . . . . . . . . . . . . .
Direct Image . . . . . . . . . . . . . . . . . .
Another Functor . . . . . . . . . . . . . . . .
11.2 Family of Families . . . . . . . . . . . . . . .
11.3 Nest . . . . . . . . . . . . . . . . . . . . . . .
Increasing Nest . . . . . . . . . . . . . . . . .
Decreasing Nest . . . . . . . . . . . . . . . .
11.4 σ-Algebra . . . . . . . . . . . . . . . . . . . .
Generated σ−algebra . . . . . . . . . . . . . .
11.5 Set Filter . . . . . . . . . . . . . . . . . . . .
Filter Generated by a Base . . . . . . . . . . .
Principal Filter and Filter Generated by a Point
Cofinite Filter . . . . . . . . . . . . . . . . . .
Fréchet Filter Base and Filter . . . . . . . . . .
Filter as a Directed Set . . . . . . . . . . . . .
Image . . . . . . . . . . . . . . . . . . . . . .
Elementary Filter of a Net . . . . . . . . . . .
Ultrafilter . . . . . . . . . . . . . . . . . . . .
Zorn’s Lemma and the Axiom of Choice . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

72
72
73
73
73
73
74
74
74
75
75
75
76
77
77
77
77
77
78
78
78
79
79
80
80
80
80
81
81
82

IV Universal Concepts

83

V Lattice
13 Supremum and Infimum . . . . . . . .
14 Lattice . . . . . . . . . . . . . . . . . .
15 Semilattice and Algebraic Aspects . . .
15.1 Order of a Semilattice . . . . .
15.2 Lattice as an Algebraic Structure
16 Completeness . . . . . . . . . . . . . .
16.1 Complete Partial Order . . . . .
Directed Complete . . . . . . .
Naturally Complete . . . . . . .
Bounded Complete . . . . . . .
16.2 Complete Lattice . . . . . . . .

85
85
86
87
87
88
89
89
89
90
90
91

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

CONTENTS

4
VI Group
17 Subcollections . . . . . . . . . . . . . . . . . . . . . . . . .
17.1 Power operation . . . . . . . . . . . . . . . . . . .
17.2 Subgroup . . . . . . . . . . . . . . . . . . . . . . .
17.3 Congruence Class . . . . . . . . . . . . . . . . . . .
17.4 Invariant subspace . . . . . . . . . . . . . . . . . .
18 Quotient group . . . . . . . . . . . . . . . . . . . . . . . .
19 Commutator . . . . . . . . . . . . . . . . . . . . . . . . . .
20 Transformation . . . . . . . . . . . . . . . . . . . . . . . .
20.1 Homomorphism. . . . . . . . . . . . . . . . . . . .
20.2 Isomorphism . . . . . . . . . . . . . . . . . . . . .
20.3 Automorphism . . . . . . . . . . . . . . . . . . . .
20.4 Action Group . . . . . . . . . . . . . . . . . . . . .
Group, Action Group and Group of Transformations
Similarity . . . . . . . . . . . . . . . . . . . . . . .
Transitive Action Groups . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

93
93
93
93
95
96
97
98
101
101
102
104
105
105
105
106

VIILinear Space

109

VIIITopological System
21 Two Descriptions, One System
21.1 Closure . . . . . . . .
21.2 Interior . . . . . . . .
22 Neighborhoods . . . . . . . .

111
111
111
113
113

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

Introduction
The attempt is to give a formal concpet of system, and with this provide a definition of category, that
will also satisfy the definition of a system. An axiomatic base is given, for constructing the group of
integers. In the process, we define a group of automorphisms; we are defining an ordered group of
functors with a natural transformation between any two. We give an isomorphism from the group of
integers into the group of automorphisms, as guaranteed by Cayley’s Theorem. The ultimate aim is to
use these definitions and concepts, of system and category, to give a general description of mathematics.
When studying a system we will identify two kinds of components, as enough to define a system.
We shall call the one kind objects and the other kind relations. In essence, it is being argued that
anything can be thought as being completely described by 1) the things it is composed of, and 2) the
characteristics about it and the things that compose it.
There are three properties that will be regarded as of absolute importance in the study of systems.
These are three characteristics that appear throughtout systems of all sorts. We speak of Structure, Symmetry, and Inheritance. This last takes the form of order, as well. The inheritance principal is viewed as
a principal of conservation. In considering inheritance, we wish to establish formal observations to the
following questions, regarding formation of new systems from old ones:
1) What basic properties are passed on from one system to another?
2) If a new system has been formed, what systems could it come from (who are the possible parents)?
3) If two systems are formed from one, what properties will these two new systems have in common?
It was necessary to first describe a system, in order to later describe relations between systems.
The relations, in turn, were used for the description of inheritance principles. There is a parallelism
with categories, functors and natural transformations. The system takes the place of category, while the
functor takes the place of relations between systems. Finally, the natural transformation describes an
inheritance principle. In the development of category theory, the same line of thought was followed, as
was pointed out by [I]:
“...‘category’ has been defined in order to define ‘functor’ and ‘functor’ has been defined
in order to define ‘natural transformation’."
Inheritance can be studied in terms of society; a system that satisifes a property, that is also satisifed
by all the objects in the system. So we may say a human society is a society, since the interactions
of different societies are more or less like human interactions. One can say a human (or any living
organism, for example) is a society of cells. Cells themselves are born, interacting, reproducing in one
form or another, and dying. Do cells inherit these properties from particles?
5

CONTENTS

6

In mathematics this situation is encountered. One can say certain collections of groups are also
groups. We can consider the collection of collections as a society. We would like to verify if filter,
topology, vector space, and many other concepts can be seen as a society. Can we define some system,
whose objects are vector spaces, so that this new system is itself in one way or another like a vector
space? Notice we are not asking that the system be a vector space, just that it has some property that
vector spaces have. We can also consider the collection of filters, on a set, and see how inheritance
plays out in this context.
There is a difference between the definition of category given here, and the definition given in [I]:
Definition. A metagraph consists of objects a,b,c,..., arrows f,g,h,..., and two operations as follows:
Domain, which assigns to each arrow f an object a=dom f
Codomain, which assigns to each arrow f an object b=cod f
These operations on f are best indicated by displaying f as an actual arrow starting at its domain
(or “source”) and ending at its codomain (or “target”): f : a → b...A metacategory is a metagraph
with two additional operations:
Identity, which assigns to each object a an arrow ida = 1a : a → a
Composition, which assigns to each pair hg, f i of arrows with dom g = cod f an arrow g ◦ f ,
called their composite, with g ◦ f : dom f → cod g... These operations in a metacategory are
subject to the two following axioms:
f

g

k

Associativity. For given objects and arrows in the configuration a → b → c → d one always has
the equality k ◦ (g ◦ f ) = (k ◦ g) ◦ f . This axiom asserts that the associative law holds for the
operation of composition whenever it makes sense (i.e., whenever the composites on either side
of (1) are defined).
Unit law.For all arrows f : a → b and g : b → c composition with the identity arrow 1b gives
1b ◦ f = f and g ◦ 1b = g. This axiom asserte that the identity arrow 1b of each object b acts as
identity for the operation of composition, whenever this makes sense.
Contrary to this definition, the definition of category we will provide, in terms of systems, consists
of two kinds of objects. We call the ordinary objects, c-objects. Arrows will be the other kind of object,
of the system. This process of considering arrows as object is a key concept that is present throughout.
This is how generalizations and complexity arises: by taking relations, and making relations about
those. For example, relations of the form a → c ⇒ b → d can be turned into objects of arrows a →
c ⇒ b → d =⇒ e → g ⇒ f → h. Arrows are one particular way of seeing relations, in mathematics.
The definition of category will be a system with relations regarding the arrows and objects. Arrows can
be 	 (reflexive) or ↔ (symmetric). The following diagram is very important and we will try to see the
underlying properties, uses and consequences of it.
a

րb ց
−→ c

For example, in topology the diagram expresses concepts of separability; the diagram will be used to
give a description of supremum, and density. Curiously, in the scope of these definitions, the supremum

CONTENTS

7

is a particular case of density. Of course, this is also the diagram that expresses transitivity. We can also
think of this diagram when we are developing products of functors, on product categories. It describes
three main forms that inheritance will take (each one of these forms for inheritance can be seen reflected
in one of our three questions regarding inheritance):
1) Generational Inheritance
◦

ր◦ ց
=⇒ ◦

◦

t◦ ց
−→ ◦

2) Common Descendency

3) Common Origin
ր◦ u
◦

−→ ◦

We first speak of systems and immediately after, introduce relations, arrows, and equivalence. Orders are given in three main types; preorder, partial order, natural order. After making such differentiations, we see basic definitions and observations. We end this subsection with the construction (rather,
the assumption of existence) of a natural order that is not trivial, the order of integers. We move on
to functions, on collections, and provide the basic types and definitions of functions. We include a
definition of two-part functions, which are crucial in the definition of functor. Here we introduce the
concept of selection function to describe the Axiom of Choice, for the first time. Also, we define order
preserving functions and duality is brought into play for the first time, in the form of dual orders. At
the end we see an important description of how two functions can be asked to behave well, in joint.
We first study Galois Connections, and then we study the concept natural pair of functions. This last,
will be the main idea behind the concpet of functor; we will give the defnition of functor, in terms of
this concept. A notation is defined and presented in the context of arrows, functions, operations, and
generalizations of these. This will enable us to give mechanical proofs in many circumstances.
There is a special kind of function, that we define as operation. That is, next we define an operation
as a function that sends objects into functions. We define the concept of left and right operations, for
a certain type of operations. When we operate two objects, we can take the view that either of the two
objects, was acting on the other; a function is associated to one object and this applied to the other
object is the result of the operation. Consider an object in the collection, for which a closed operation is
defined, call the object x. We can say, on the one hand, object x acts, on other objects of the collection
in such manner... To verify this, we would provide a list of pairs of objects; the first of each pair is the
object operated with x. The second of each pair is the corresponding result of the operation, between x,
and the first of the pair. One can also say, the objects of O act on x, according to... To verify this, we
would give another list of pairs. Here the first of each pair is the object that acts on x and the second is
the result of the operation. The first list is the right operation of x while the second is the left operation.
In chapter two, we introduce categories and the main properties of functor, along with a definition of
natural transformation. Here, we start by giving a basic classification of arrows; isomorphism, left/right
cancellable, left/right invertible. After this, we show that a partal order is category and we also define
algebraic categories, motivated by considering a category whose arrows are functors from one category

8

CONTENTS

to itself. This is the concept of a monoid, as given in [I]. We also give the definition of a group and prove
very basic properties regarding unit and inverse. The functor is next, and we begin by giving a definiton
of functor that will provide easy to relate to the concept of natural pair of functions. After giving a brief
classification of some functor types, we define opposite category and functor. We prove that there is an
opposite functor on the category of all categories. This serves as bases for a discussion on contravariant
functor. We see a general description of a simple type of functor, the algebraic functor. The next subsection provides a construction of product category and we try to see what functors look like in this tyoe
of category. We then define bifunctors with one component contravariant, the other covariant. This is
followed by a theorem that allows decomposition of some bifunctors, into two simpler bifunctors. After
studying the functor, we go into natural transformation and we see how this relates to the constructions
given for the product of two functors, with common domain. Throughout, we will apply the concept
of using arrows as objcets, so as to generalize the concept of arrows between arrows. The natural transofrmation is great example of how this and for that we show that natural transformations can compose
in two manners. We show the interchange law for the vertical and horizontal compositions of natural
transformations, and after this we show that there are two categories to be considered. These are 1) the
~
category of functors Cat(C, D), and 2) the 2-category of all categories which we will denote Cat.
The section of integers is central, it begins retaking the discrete number system. A discrete number
system is one whose objects and arrows are arranged in the form · · · → a → b → c → · · · → x →
y → z → · · · . We show that this system generates a group of automorphisms, on the partial order
which corresponds to the discrete number system. This group of automorphisms is generated using
one functor, the functor determined by the arrows of the discrete number system. Using this group
of automorphisms we build the group of integers with addition. We study the operation as functor,
and as a natural transfomation. In short, a discrete number system contains all the information needed
to construct a group on itself. Next, a second operation is defined for integers. This is of course the
product, another functor. Rational systems are introduced through a construction that involves dual
orders. We see that a rational system is an involution. Then, the operations are defined for the rationals
and we give an embedding of the integers into the rationals, as order and operation.
In chapter III, we start with an axiomatic base for sets that is quite similar to the one provided in [I];
in fact only minor changes have been made. After the basic properties and operations of sets, we study
sets as categories. The first view is to see a set as collection category, then we see it as a partial order
under inclusion. Here, we will also introduce concrete category and give a proof of the Yoneda lemma.
We see how this relates to the construction provided for the integers through Cayley’s theorem.
We continue to set functions and we introduce here the concept of image and inverse image for a
family of sets. The general results that relate image, inclusion and set operations are presented. After
this, we present the concept of fiber and we use it to give a decomposition for set functions. The next
subsection for set functions, is sequence. In the paragraph Sequence of Objects for an Operation, we
introduce the concept of series by defining a sequence of functions that can be applied to a sequence,
and that results in the sequence of partial sums. There is a paragraph on compositions of a sequence of
functions and here we introduce, among other things, the concept of invariant objects and sets. From
this we derive the concept of once-effective functions. Once-effective functions are important in the
study of the closure functor which is later used as a starting point in topology. We end the discussion
on sequences with a description of sequence in terms of cartesian product. The concept of sequence is
generalized in the next subsection. Here we start by defining bounds and supremum. After this we start
discussion on directed sets and end with the definition of net. This is used for defining matrices.
The next section is on families of sets, starting with the power set and functor before defining

CONTENTS

9

direct image and direct inverse image for families. We then define the forward and backward image
of sets f → A, f ← B. After this, we establish a characterization for direct and direct inverse image in
terms of f → A and f ← B. We also note the duality between image and fiber, using the forward and
backward images. We see how to express the power set as another kind of functor. Some properties
and relations for special types of families are given and then we start with the study of filters. We give
a brief introduction to ultrafilters. Ultrafilters will be taken up again in the next chapter; when we study
lattices; after we have proven Zorn’s Lemma. In fact, The proof of Zorn’s Lemma is what follows next.
In Chapter IV, we study lattices. First, we revisit the supremum, then define lattice in terms of
supremum and order. The concept of semilattice is defined algebraically in terms of an operation. We
show that sublattices and lattices are closely connected and then we show that a lattice can also be
viewed as an algebraic structure (with two operations) and a sublattice can also be viewed as an order.
After introducing lattices we see properties of completeness. Filters, in the general sense, and boolean
algebras are to be included here, but do not yet make appearence in this document.
After Lattices, we devote a chapter to group theory. The last chapter is a brief description of topological systems. We describe them as functors on algebraic categories.
Let us take this oppostunnity to understand the notation that is used through to the end. Firstly, the
notation is presented for a general case of arrows. That is, if we have an arrow a → c −→ b → d we
express this by a, c; b, d. Next, we say that a; f x, f is equivalent to the statement the function f applied
to the object x, results in fx. Finally, we use the notation to express operations by saying a, c; b, d is
equivalent to the statement a ∗ d = b ∗ c. This way, if we define a, g; b, f as the statement saying f a = gb
we can express a, ∗c; b, ∗d or a, c; b, d as saying the same thing. For example, when defining the integers
we give the operation in terms of comparability of arrows. That is, we give a system of arrows between
arrows and the operation is defined so that it coincides with the notation. We define an order on top of
an existing order and this gives rise to strong arrows.

10

CONTENTS

List of symbols (Incomplete)
Sys
S , S ′, S ′′ , S ′′′, ...
∅
a, b, c, ..., x, y, z, ...
O, Q,...
SX
f :a→b
{a → b}
{a →}
{→ b}
O1 →× O2 or O1 × O2
a →× b
x ≤ y or y ≥ x
x=y
x < y or y > x
a, c; b, d
f : O1 → O2
Dom f
Range f
Im f
f a, a f, f (a), (a) f
a; f a, f
a, g; b, f
f Q1 or f [Q1 ]
f −1 Q2 or f −1 [Q2 ]
g◦ f
I:O→O
f −1
f |Q 1
ι
Sel
Pop
x ≤op y
P, Q; Pop, Qop
P, Qop ; Pop, Q
P, Pop; Pop , P

Universal system
System
Empty system
Object
Collection of objects
Remove all objects, except X, and all relations that do not include X
Arrow
Collection of arrows from a into b
Collection of arrows with a as source
Collection of arrows with b as target
Cartesian product
Object of cartesian product
Comparability in partial order P
x ≤ y and y ≤ x
Irreflexive comparability in partial order
Comparability between arrows a → c and b → d
Function with O1 as domain and range is O2
Domain of the function f
Range of the function f
Image of the function
Image of object a, under f
Image of object a, under f , is f a
Image of a, under f , is the same object as image of b, under g
Image of subcollection Q1
Preimage of subcollection Q2
Composition of functions
Identity function
Inverse function
Function with domain restricted to Q1
Inmersion
Selection function
Opposite partial order
Comparability in opposite order
P, Q are order bijective
P, Q are dual
P is self dual
11

12
P, Q; Q, P
{O1 f O2}
O1 f O2
∗, ⊕, ·, ◦, ...
∗x
x∗
a; a ∗ x, x
a, y; b, x
x; x, e
x; e, e
x; e, x−1
x, x; y, y
x∗, x∗; ∗y, ∗y or a, c; a ∗ b, b ∗ c
f, f ; ∗ f x, ∗x
a ⊕ b; (a ∗ x) ⊕ (b ∗ x), x
C, D, ...
A
O|C
A|C
b→c∗a→b
1x
1C
{a →iso b}
F:C→D
FO
FA
Cat
IC
ICat
{CFD}
CFD
{CFiso D}
Cop
f op : b →op a
Fop : Cop → Dop
op : Cat → Cat
F⋉
f × g : C → D1 × D2
f × g : C1 × C2 → D × D
(h∗, ∗g)
B : C1 × C2 → D
τ : O|C → A|D
Z
Z<
Z≤

CONTENTS
Galois connection for two partial orders P, Q
All functions O1 → O2
All functions Qa → Qb , for all subcollections Qa , Qb of Oa , Ob
Operation
Right operation
Left operation
The action of x on a results in a ∗ x
The action of x on a is the same object as the action of y on b
The object e is a unit of the operation
The object e absorbs with the operation
The objects x, x−1 are dual to the unit
The operation commutes
The operation is associative
Function and operation commute
Two operations commute
Category
Collection of arrows
Collection of objects of the category
Collection of arrows of the category
Composition of b → c with a → b
Reflexive arrow for x
Unit function of the category;
Collection of isomorphisms for a, b
Functor
Object function of the functor F
Arrow function of the functor F
Category of cateories as c-objects and functors as arrows
Identity functor for C
Identity functor for Cat
Collection of functors
Collection of functors for subcategories
Collection of all isomorphisms C → D
Opposite category
Opposite arrow of f
Opposite functor of F : C → D
Functor that sends a categories and functors to their opposite
Contravariant functor
Product functor of common domain
Product functor of common range
Left-right operation function
Bifunctor
Bridge or natural transformation
Discrete number system
Discrete number system with transitive arrows
Discrete number system with transitive and reflexive arrows

CONTENTS
{+x}≤
Z†
Z
N0
N
N†
N†
a
b

Q
Obj
Obj∈
U
V
R
Set
A, B, ..., X, Y, ...
∅
x∈A
<
A = {x} x∈A
A⊆B
A⊂B
A=B
X, Y,...
S
S
X or
A

13
Order of automorphisms +x, for Z≤
Group of automorphisms +x : Z≤ → Z≤
Integer number system
System of natural numbers
System of natural numbers, without the object of operation 0
A partial order N × {c}, isomorphic to N
A partial order N × {c}, dual to N
Arrow a →× b, of the collection N0 →× N or −N0 →× N
Rational number system
Collection of all objects
System of all objects and of arrows x ∈ A
Universe of sets; subcollection of Obj
Add the object U to the collection U
Collection of all normal objects
Category of small sets; arrows are functions
Set
Empty set
x is an element of the set A
Not an element of
Set A is represesnted as,
Set A is a subset of set B
Set A is a subset of set B, but they are not the same object
Set A is subset of set B, and B is subset of A
Family of sets
Union of all sets in the family

A∈X

A∪B
T
T
X or
A

Union of sets A and B
Intersection of all sets in the family

A∈X

A∩B
A−B
Ac
PA
A, B, ...
PA
Set⊆
PA
f [[X]]
f −1 [[Y]]
( f x) ∈ f A
( f −1 B) ∈ f −1 [[Y]]
f −1 [z], f −1 {z}
{{A}} or {{x}} x∈A
f |Im f
ιf
Ef

Intersection of sets A and B
Difference of set A and B
Complement of set A
Set of all subsets of set A
Collection/set category
Set category of the set PA
Category of small sets; ordered under inclusion
Power category of A; ordered under inclusion
Image of family X
Inverse image of family Y
Object in the image of A; there is x ∈ A such that ( f x) = f x
Object in the family f −1[[Y]]; there is B ∈ Y such that ( f −1 B) = f −1 B
Fiber of object z
Family of singletons of A
Function onto the image
Inmersion of image into range
Image equivalence of f

CONTENTS

14
f /E f
Dom f /E f
pf
n
I
s, t, ..., (xi)i , (yn )n , ...
(xi )ni=1
ON
On
S, T, ...
Λn+1
i=1
Λni=1 (xi )i
Λ
ΛO
Λi∈N xi or Λ∞
i=1 xi
n
P
xi

Bijective function, f module E f
Inverse image of the family {{Im f }}
Projection into fiber
All numbers x ∈ N such that 1 ≤ x ≤ n
Index set
Sequence
Finite sequence
Collection of all sequence of objects in O
Collection of all finite sequence of the form n → O
Order preserving functor N → N
Finite operator; function that sends (xi )i into Λnj=1 (xi )i ⊕ xn+1
Finite operator applied to the sequence (xi )i
General operator; sequence of functions Λnj=1
Union of the family that consists of the image of every finite operator
Series of (xi )i , under a general operation ⊕
P
Partial sum; image of (xi )i , under the finite operator nj=1

i=1
n
Q

xi

Partial product; image of (xi )i , under the finite operator

xi

Series for operation ·; image of (xi )i under the function

i=1
∞
P

i=1
∞
Q

xi

i=1

Φ
φ
φ(xi )i or (φi )i
(σi )i
(πi )i
an
(⊕xi )i

fn

Series for operation +; image of (xi )i under the function

P

N

Qn

j=1

Q

N

Sequence of functions
Sequence function associated to the sequence of functions Φ
Sequence of partial operations for (xi )i ; every φn is Λnj=1 (xi )i
Sequence of partial sums for some sequence (xi )i
Sequence of partial products for some sequence (xi )i
Partial product for the constant sequence (a)i
Sequence of right operations for (xi )i and ⊕
General operator for composition
Composition of the sequence ( f )i

I | Systems
A system is a collection of objects and a collection of relations. When considering a system, it will be
decided, for any concept that makes appearence, whether it be an object or a description. We can form
collections of systems, just as we can with any other type of object. Relations are those components
of the system that come in the form of assertions about the system, objects of the system, and other
systems. All relations refer to, at least, the system or objects of the system. Additionally, it is required
that every object appear in at least one relation. Therefore, if a certain relation is an object of the
system, we are saying it is the object of some relation regarding it. This is kept in mind, when category
is defined as a system.

§1 Generating New Systems
1.1 Taking/Adding Objects/Relations
We will now discuss the concept of making new system(s), from given system(s). Suppose you have
a system S, then the only actions permitted in the forming of new systems are 1) Taking objects or
relations from a given system 2) Adding objects or relations to a given system. We will give a restriction
for taking or adding objects or relations: no object can be left without a relation. A collection is called
a subcollection of another, if it has been obtained by taking objects/relations from the other.
If S′ is obtained from S by adding only relations, we will say S′ is a detailed version of S. Consider
any object x that has any relation in Sys, with some object of S′. Then the system S′′ formed by adding
the object x and any collection of relations, that mention x or an object of S′ , is a complication of S′ .
We will say that S′ is a simplified version of S′′ .
Axiom 1. We will suppose the existence of one system, Sys. It is defined by one relation: All system S
is obtained by taking objects or arrows from Sys.
Another way of stating this axiom is that every thing is an object of Sys; in particular, every system
is an object of it. Consequently, Sys is an object of Sys.
Axiom 2. Given any object X, in a system S, we can form the new system SX, whose (only) object is X
and whose relations are the relations of S, pertaining to X. For every system, there is a system SysX.
The twin system of Sys, is the empty set, denoted by ∅, and constructed from Sys by taking away
all objects and all relations. Any system can be obtained from ∅ by adding objects or relations. The
emptyset is a thing in Sys; the thing that consists of nothing.
15

CHAPTER I. SYSTEMS

16

1.2 Separating and Combining Subsystems
When studying a system, we can decide it convenient to see which objects are not related amongst
themselves, in any chosen manner. To be more explicit, consider S to be such that its objects can be
distinguished as two kinds a, b, c, ..; x, y, z, ... and suppose there is not a single relation in S for which
one of each kind of object is present. We consider two, evident, simplified versions of S.
Let us now consider the case in which we may want to separate S into two systems, but there is
no guarantee as too whether we can differentiate objects as before (there may be relations, in S, that
involve objects of both collections). We will form the two simplifications by defining the two kinds of
objects. Relations will be two kinds also: the one kind of relations are those that do not refer to the
second kind of object, and the second kinds of relation are those that do not refer to the first kind of
object. In this case we have a separation that loses information. We accomplish a separation that does
not lose information by defining the first kind of relations to be those referring to objects of the first
kind, and the second kind of relations are defined as those that mention the second kind of objects.

§2 Relations and Objects
A relation is a collection of statements referring to systems and objects. If all the statements of a relation
can be obtained by changing the objects (subjects of the statement) in one statement, the statements are
components of the relation. Arrows will be used to represent relations; a collection of arrows can be
the simplfied form for certain relations. The main idea behind the use of an arrow is to distinguish two
objects, in a given scenario. Thus, a → b means first is a, second is b. The object to the left of the arrow
is the source object and the one to the right is the target object. We can represent an arrow by saying
f : a → b. It is reasonable that for some relations, the collection of arrows is discernible. This means,
that there can be more than one arrow between two objects. A pair of arrows is parallel if they have the
same source and same target object. For objects a, b in C, define {a → b} as the collection of all arrows
with a as source and b as target. We also define {a →} as the collection of arrows with a as source and
{→ b} as the collection that has b in the target.
Binary relations are those such that every statement refers to only two objects a, b. An ordered
pair relation is any relation whose components are arrows between two objects of the system, and two
components are the same if they have the same objects in the same position with respect to the arrow.
This last means that the arrows are non-discernible (parallel arrows are the same arrow).
An ordered pair relation is said to be reflexive if for every object a of the system we have the
component a → a; these arrows will be called reflexive. In case there are no reflexive arrows, the
relation is irre f lexive. It will be called symmetrical if all arrows are double ended; for every arrow
a → b we have the arrow b → a. The relation is anti-symmetric if given any choice of distinct objects
a, b there is at most one arrow between them (only reflexive arrows are allowed to be double ended).
Suppose for every every pair of components a → b and b → c the component a → c exists in the
collection of statements, then the relation will be called transitive. If there is an arrow a → b or b → a,
we will say a, b are →-comparable. We say that a relation is trivial if all the arrows are reflexive.
Throughout mathematics we will also use the equivalence relation, amongst others, with great frequency. It is desireable to regard certain objects as the same with respect to certain criteria. We can
determine objects by the relations it has in other systems that are not Sys. We wish to say when two
systems are the same, in a lesser sense. An ordered pair relation is called an equivalence relation if it is
reflexive, symmetric and transitive.

2. RELATIONS AND OBJECTS

17

2.1 Equivalence
The collection O1 →× O2 defined in terms of the collections O1 , O2 will be called the cartesian product
and it consists of all arrows a →× b, where a, b are in O1 , O2 , respectively. Given a collection O, we
immediately get an equivalence relation O →× O. Such equivalence relations are called simple.
Take an object x of an equivalence relation and let X be the collection of objects of the equivalence
that are comparable with x. We can carry out a separation of the equivalence, so as to consider a system
that, for convenience, is also denoted by X. When giving the separation, into the collection X, it does
not matter if you carry out the separation that loses information, or the separation that does not lose
information. We invariably get a separation that does not lose information and is one of the reasons
that simple equivalence relations are so important. For objects x, y in X, we shall verify that the system
Y, correspoding to y, this is the same system as X. Let a be an object of X then we can suppose the
existence of an arrow a → x because of symmetry. This together with the existence of an arrow x → y
imply the existence of an arrow a → y which means a is an object of Y. A similar argument can be
given to verify that all objects of Y also belong to X. Therefore, the systems X, Y are the same because
they both consist of the same objects and both consist of all arrows amongst these objects.

2.2 Order
A preorder is a reflexive and transitive ordered pair relation. A preorder that is anti-symmetric will be
called partial order. Not all the objects are ordered amongst each other and when there is an arrow
amongst two objects x, y we say they are order comparable, for example the arrow x ≤ y. If an arrow
for an order is not reflexive we may express x < y. Arrows ≤ may be called inequalities, while an arrow
< is a strict inequailty. Anti-symmetry holds if x ≤ y and y ≤ x, imply x = y. An object M of a partial
order is said to be maximal if for every x in the partial order such that M ≤ x, we have x = M. We say
that an object m is minimal if x ≤ m implies x = m. Maximality of M means that it appears as source
object in one arrow only, the reflexive arrow. Of course, minimality means m appears as target, only in
the reflexive arrow.
A natural order is a transitive binary relation, in which every object of the collection appears in
exactly one arrow with every other object. We can see that a natural order is a partial order, however
not all partial orders are necesarilly natural. Of course, given a collection of partial orders, the system
formed by including all the objects of all the orders with their respective arrows, is again a partial order.
Proposition 2.1. Given a partial order P, and a subcollection of it, we can specify a simplified version
of P, that is itself a partial order on the objects of the subcollection.
Informally, the axiomatic base for numbers is given by 1) an object exists, 2) there is one arrow on
each side of every object, and 3) an order relation is given.
Axiom 3. We suppose the existence of a system such that
1) The system is non-empty.
2) Every object is source of exactly one arrow and target of exactly one arrow.
3) The relations of the system are components of a non-trivial natural order.

CHAPTER I. SYSTEMS

18

We are able to ask that 2) holds because we know we can take arrows away to form a new system
and we are not breaching our only rule: no object is left without a relation (arrow).
We have objects 0 and 1, such that 0 → 1. We are unable to apply 2) to conlcude 1 → 0, so we
have −1 → 0 → 1, for some object −1 that is not 0, 1. We are now unable to say 1 → −1, because
transitivity would lead to a contradiction with the fact that the order is irreflexive. We now know there
are objects −2, 2 such that −2 → −1 → 0 → 1 → 2. We continue construction in this manner and call
such a system a discrete number system.

2.3 Comparability
It is desireable to have relations amongst relations themselves. Some orders arise in the form of relations
amongst relations, as will be seen in building rational systems. Consider systems S1 , S2 , with respective
arrows →1 and →2 in the systems. Suppose we have formed a system whose objects are the arrows of
S1 , S2. For an ordered pair relation, with a component being an arrow of the form a →1 c −→ b →2 d
or a →2 c −→ b →1 d, we will express a, c; b, d. We will in such cases say a, c and b, d are comparable.
This kind of comparability will give us some operations and it will allow many constructions for finding
the integers and rationals and it will also arise in categories, where we define functors and natural
transformations in terms of comparability properties.

2.4 Function
Definition Consider a system f with two kinds of objects. The first collection of objects called
the domain and the second kind will be called range; unless a more convenient notation is taken up in
particular cases, these will be represented by Dom f and Range f , respectively. If the system has an
ordered pair relation such that the collection of target objects is a subcollection of Range f and any
source object appears to the left of exactly one arrow, we will say the system is a function from Dom f
into Range f . This will be expressed by f : Dom f → Range f . For the most part, except in cases
where this is not convenient, the components of a function f will be denoted by a 7→ f f a or a → f f a or
a; f a, f . We can, in place of f a, write a f or f (a). If we are to consider two functions f, g : O1 → O2 ,
such that f a and gb are the same object, we will write a, g; b, f . It will be common to name functions by
f, g : Dom f, Dom g → Range f, Range g, meaning f : Dom f → Range f and g : Dom g → Range g.
Image The collection of all objects that appear to the right of an arrow is represented by Im f . Let
f : O1 → O2 , and for any subcollection Q2 of O2 , we will write f −1 Q2 to represent the subcollection of
objects x in O1 , such that f x is in Q2 . This collection is the preimage of Q2 . We say f Q1 is the image of
Q1 , and it is defined as the collection of objects f x in O2 , for every x in Q1 . If there exists the possibility
of confusion, the image and preimage will be written as f [Q1 ] and f −1 [Q2 ].
Classifications If the function is such that all the objects of Im f appear in exactly one relation,
it will be called monic. If every object in Range f appears in at least one relation, then it will be said
the function is from Dom f onto Range f , or if all else is clear from the context, we will simply say
f is onto. If every object in Range f appears in exactly one arrow, the function is monic and onto; the
function is said to be bijective.

2. RELATIONS AND OBJECTS

19

One would think that we are able to restrict the function to a certain subcollection, in the Im f and
obtain a function that is onto. Also, we expect to restrict Dom f in such a way that we obtain a monic
function. These two instances will be studied and used.
Composition Given two functions f, g : O1 , O2 → O2 , O3 , we form g ◦ f : Q1 → O3 , where
a 7→g◦ f c if there exists an object b in O2 such that a 7→ f b 7→g c. This is a principal of transitivity
because we are assigning an arrow from a to c, given there are arrows from a to b and from b to c. Any
function g ◦ f will be called a composition. The composition is associative:
f ; f (g ◦ h)a, (g ◦ h)a
f ; f (g(ha)), (g ◦ h)a
f ; ( f ◦ g)(ha), (g ◦ h)a
f ; (( f ◦ g) ◦ h)a, (g ◦ h)a
Inverse and Unit Let I : O → O such that x 7→I x; this function will be denoted by IO and if
no confusion is possible we simply write I. Given a bijective function f : O1 → O2 , we will say the
function f −1 : O2 → O1 is inverse of f , if f −1 ◦ f and IO1 are the same function.
Proposition 2.2. Let f be a bijective function and f −1 an inverse of f . Then f ◦ f −1 is the function IO2 .
The function f −1 : O2 → O1 , that is obtained by reversing all arrows of f , is an inverse of f . The
definition of equality, in the next paragraph, makes f −1 unique.
Proof. We know that for every object in O1 , we have x 7→ f f x 7→ f −1 x, so that ( f −1 ◦ f )x is x.
Now, let f −1 be the function obtained by reversing all arrows of f . If x is an object in O1 , then f −1
is the function that sends f x 7→ f −1 x because we have x 7→ f f x.
The inverse of a composition g ◦ f : O1 → O3 is f −1 ◦ g−1 : O3 → O1 . This is easily figured out by
observing the bijectivity of f, g and f −1 , g−1 .
Two Part Function and the Meaning of Equality for Functions Our first equivalence relation is
stated so as to determine an equality criteria for functions. Two functions will be the same if they both
have the same domain, range, and components. If a function can be seperated into two systems fA and
fB , without losing information, we say f is a two part function fA , fB . We shall say A, B are the objects
of the first and second kind given by the separation; notice that each of these collections consists of
objects in the domain and range. We are considering simplified versions of the function f . This is done
by taking away arrows and objects in the domain, in such a way that the new system is also a function.
If f : O1 → O2 and Q1 is the subcollection of O1 considered, then f |Q1 : Q1 → O2 is called the
restriction of f to Q1 . Notice that we are carrying out the construction of a simplified version of f . If f
is monic, then any restricted function of f is also monic. A similar remark does not hold if f is onto. A
function ι is called an inmersion if Dom ι ⊆ Range ι and x 7→ι x. Of course, the identity function I is
the special case of ι, when equality holds. Also, if we restrict I to a subcollection of its domain, then it
becomes an inmersion into its own domain.

20

CHAPTER I. SYSTEMS

Selection Function In this section, we give an axiom that allows us to identify any object with a
reflexive arrow. We are looking for a simple way of characterizing the selection of an object, amongst
all others in some collection O. A function {x} → Range f , where the domain consists of one object,
is called selection function. For any x in O, we have the selection function ιx : {x} → O that is an
S
inmersion. Let X represent a collection of collections and write X for the collection of objects that
S
belong to some O in X. A selection function for X is a function Sel : X → X such that SelO ∈ O.

Axiom of Choice. Given a non-empty family of functions X, there exists a selection function.

We are stating that objects can be chosen one by one, from arbitrary families. This axiom will take
another interesting form, in a later chapter. There, we will discuss the axiom of choice in a slightly
different context. We will be able to choose elements from partial orders.
Order Preserving Function and Galois Connections [VIII] There are certain functions from an
order into another, that can transform the objects in such a manner that the function suits the orders
well. We can say that the function recognizes the order of both. Let P and Q be two partial orders
where arows are ≤ and , respectively.
Definition 1. A function P → Q defined on the objects of these categories is said to preserve the order
if for every arrow a ≤ b we also have f a  f b; if instead of this, we have f b  f a, then the function is
said to be order reversing.
We say an order preserving function is an order embedding if for every f a  f b we have a ≤ b. An
order embedding that is onto, is called order bijectivity.
It is easy to see an order bijectivity is indeed a bijective function. For this, we only need to verify
that every order embedding is monic. To prove this, take a, b in P such that f a = f b, and verify a = b.
The opposite of a partial order is denoted by Pop and it is defined as the system whose objects are
those from P and whose arrows are the reversed arrows of P. It will be seen that there is not always an
order bijectivity for a partial order and its opposite. When it does exist, we say P is self dual.
When there is an order bijectivity P → Q we write P, Q; Pop, Qop . If there is an order bijectivity
into the opposite of Q, then we say P and Q are dual orders and we represent this with P, Qop ; Pop , Q.
Notice that self dualtiy is expressed as P, Pop; Pop, P.
We shall address the issue of whether there exists an order bijectivity Pop → Qop given there is an
order bijectivity P → Q. Let f : P → Q be an order bijectivity, we wish to prove that f is also an order
bijectivity Pop → Qop . We know x ≤op y if and only if y ≤ x which is true if and only if f y  f x and
this holds if and only if f x op f y.
If we consider an order bijectivity f : P → Q, and its inverse f −1 , we have two order preserving
functions; one from P to Q and the other from Q to P. There is a similar situation with more generality
than this last example. Let f, g : P, Q → Q, P. We will ask that f, g are order preserving but we will
also ask that the compositions be order preserving, in a different sense. This last condition is a less
restrictive condition than the situation with f, f −1 in which we have f f −1q = q and f −1 f p = p.
Definition 2. A pair of functions f, g, as mentioned above, is called a Galois connection if 1) f, g are
order preserving, and 2) for every object p in P and q in Q we have p ≤ g f p and f gq ≤ q.
Here is a characterization of Galois connections. Suppose that the functions f, g : P, Q → Q, P are
such that for every p, q in P, Q we have f p ≤ q if and only if p ≤ gq. We will sometimes say f, g are
comparable functions and we will write f ; g instead of using the notation for arrows P, Q; Q, P.

2. RELATIONS AND OBJECTS

21

Proposition 2.3. A pair of functions is a Galois connection if and only if it is comparable.
Proof. Suppose the pair f, g is comparable. For p, we know that f p ≤ f p and this implies p ≤ g f p.
We can similarly prove this for q in Q and that proves 2). Now, we shall prove f, g are order preserving.
Take p, r, both in P, such that p ≤ r ≤ g f r. This is equivalent to stating that f p ≤ f r. If f gr ≤ r ≤ q
are in Q, we have gr ≤ gq.
Now, suppose f, g is a Galois connection. If we suppose f p ≤ q, then p ≤ g f p ≤ gq. Let p ≤ gq,
then f p ≤ f gq ≤ q.
Natural Pair of Functions Let ∗a : O1 → Q1 and ∗b : O2 → Q2 be onto functions. Consider
the collection O of all functions of the form O1 → O2 . Let y in Q1 and f a function in O, then we
have x in O1 such that x 7→∗a y. Define F f : Q1 → Q2 such that x ∗ a 7→F f f x ∗ b; this simply
means f x, F f ; x ∗ a, ∗b. The situation described here is of great importance. If we have functions
F, G : O1 , Q1 → O2 , Q2 , then we would like to know when it is possible to give functions ∗a : O1 → Q1
and ∗b : O2 → Q2 that will allow us to describe the actions of applying G, in terms of the functions ∗b
and F. That is, we are giving a function F and we also give rules for transforming the domain and range
of F (that is the role of ∗a and ∗b respectively), so as to generate a new function G that is defined for
the transformed domain and range. The way this function G works is by sending objects ∗a(x) in the
transfromed image, into the object that results from transforming the orginal object, first under F, and
then under ∗b. Explicitly we have F x, G; x ∗ a, ∗b. We will say that F, G are a natural pair of functions,
under ∗a and ∗b and this will be expressed by F, G; ∗a, ∗b.

2.5 Operation
Sometimes it will be convenient to use the collection {O1 → O2 } of all functions from O1 into O2 ;
we will use the notation {O1 f O2}. However, in the definition of operation, this collection is not large
enough to be useful. Let O1 f O2 represent the collection of all functions of the form Q1 → Q2 , where
Q1 , Q2 are any subcollections of O1 , O2 , respectively.
An operation is a function ∗ : O → O1 f O2. We say the objects in O are the actions of the operation.
The image of a in O, under ∗, is a function a∗ called left operation. The image of x in O1 , under a∗ is
a∗ x and we express a; a∗ x, x instead of the function notation x; a∗(x), a∗. Just as we have characterized
the operation in terms of functions associated to the objects of O, we can also determine a function in
terms of functions associated to the objects of O1 . Let x be any object in O1 ; we wish to build a general
function ∗x. An object is in the domain of ∗x if and only if there exists an object a, in O, such that a ∗ x
is defined, i.e., x is in the domain of a∗. We define the transformation as a 7→∗x a ∗ (x); this is expressed
with a; a ∗ x, x instead of the function notation a; ∗x(a), ∗x. the objects of O1 , O2 are called origin and
target objects, respectively. An operation ∗ is full if ∗ : O → {O1 f O2}. This means O1 is the domain of
every left operation. Equivalently, an operation is complete if the domain of every right operation is O.
We will frequently encounter functions of the form ∗ : O1 → O1 f O2 ; we call them operation from
O1 to O2 . For this kind of operation, we can define the concept of commutativity. We say x in O1
commutes if ∗x, x∗ are the same function. We say ∗ commutes if every action (and thus target) object
x commutes. Other times we will consider operations ∗ : O1 → O2 f O2 and we say the objects of O1
are actions for O2 . If the objects for O1 are actions for O2 . Suppose we have such an operation, and
suppose there exists an action object e such that e∗ is the identity operation for O2 ; we say e is a left
unit of *. If ∗ : O1 → O2 f O1, and ∗e is IO1 , for some e in O2 , we say e is a right unit. We can speak of
a unit if ∗ : O → O f O and there is an object e that commutes; e is a unit if the left/right operations are

22

CHAPTER I. SYSTEMS

the identity function. When there is a unit, two objects can be related in a special manner and we say
x−1 is right inverse of x if x; e, x−1 . We are justified in saying x is left inverse of x−1 .
Form the system whose weak arrows are the arrows of the right operation functions ∗x, for every
x in O. Two weak arrows a →∗x c and b →∗y d will be related if c and d are the same object; in such
case a, y; b, x will be expressed instead of a, c; b, d. This relation is an equivalence relation so we can
equally say b, x; a, y. We choose to do this because in terms of the notation for functions we can express
a, ∗y; b, ∗x or b, ∗x; a, ∗y. Two objects x, y commute if x, x; y, y.
If ∗ : O → {O f O}, then the composition is defined for the functions which are left/right operations.
We want to define an operation ◦ such that the actions, source, and target objects are the left and right
operations of ∗. The operation in question is ◦ : {O f O} → {O f O} f {O f O}, where ◦ is composition of
functions. We will say the operation is associative if x∗, x∗; ∗y, ∗y, for every choice of obects x, y. This
means that x ∗ ◦ ∗ y is the same function as ∗y ◦ x∗; the functions x∗ and ∗y commute. Associativity can
also be seen as a transitive property regarding the operation, for the following reason. We have assigned
a →y∗◦∗x c to any arrows a →y∗ b →∗x c. In terms of the objects and the original operation, associativity
is expressed by a, c; a ∗ b, b ∗ c, for every objects a, b, c. This last form of writing the associativity gives
intuition for why we say it is a transitive principle: on one side we have a, c, while on the other we have
a, b and b, c, in that order. In conclusion, ∗ is associative if for every pair x, y of objects, x∗ is a natural
pair of functions with itself, under ∗y, ∗y. Or, we can say ∗y is a natural pair with itself under x∗, x∗.
An operation and a function can commute. This happens for f : O → O and ∗ : O → O f O if
f, f ; ∗ f x, ∗x, for every x; put differently, f ◦ ∗x is the same function as ∗ f x ◦ f . Given two operations
⊕ : O1 → {O1 f O1} and ∗ : O2 → {O1 f O1 }, we say ∗ distributes over ⊕ on the left if for all b in O1
and all x in O2 we have x∗, x∗; ⊕(x ∗ b), ⊕b. Another way of saying this is all the left operations of ∗
commute with ⊕. If ∗ : O1 → {O2 f O1 } and instead we verify the above with ∗x, ∗x; ⊕(b ∗ x), ⊕b then
we say ∗ distributes on the right. Distribution on the left can be written as x; (x ∗ a) ⊕ (x ∗ b), a ⊕ b and
distribution on the right is a ⊕ b; (a ∗ x) ⊕ (b ∗ x), x.
Suppose we have a full operation ∗ : O → {O1 f O2 }. Propose a function ∗ : (O1 →× O) −→ O2
which is called a binary operation. Let a →× x be an object in O1 →× O. We define ∗(a →× x) := a ∗ x.
Let us consider the construction of the operation, provided we have a binary operation. We wish to give
a function ∗x for every object in O; this function must send objects of O1 into O2 . The components
of the function are a →∗x ∗(a →× x). Given a function ((O2 →× O1 ) →× O) −→ O3 , there is an
operation O → {(O2 →× O1 ) f O3 }. Every function in the image can be turned into an operation of the
form O1 → {O2 f O3 }. It is then possible to build an operation O → {O1 f {O2 f O3 }}.

II | Category
Here, we will treat objects and arrows as two different kinds of objects. The relations in a category are
not the arrows. The relations, in this definition of category, are statements about arrows and objects. It
will be clear, from the definition, that a category is indeed a system whose objects consist of relations
also. This is important to consider an environment where a functor is to be treated as a function.
A collection of arrows is said to have the reflexive property if for all object x there exists at least one
reflexive arrow. It will be said that the collection of arrows has the transitive property if the composition
for the arrows (adequately seen as functions) defines an operation ∗ : A|C → AkC f A|C. Clearly, the
composition is not always a full operation. A collection of arrows that satisfies the last two properties,
for all objects of some collection O, will be called a collection of order arrows for O.
Definition 3. A category is a system with objects of two kinds; the one kind are called c-objects, while
the other kind is a collection of order arrows, for the collection of c-objects. Additionally, for any choice
of c-objects x, y, and arrows f : a → x and g : b → y, there is a reflexive arrow 1b , 1 x such that
1) 1 x ; f, f

and

g; g, 1b

Unit

2) g∗, g∗; ∗ f, ∗ f

Associativity

The two kinds of objects are represented by O|C, A|C, respectively. In 2) we are stating that for every
h : x → b, the arrows g ∗ (h ∗ f ) and (g ∗ h) ∗ f are the same. All we are saying is that both, the collection
of arrows and the operation for the arrows, satisfy their own reflexive and transitive properties.

§3 Arrows
3.1 Defining Equality of Arrows
Given two arrows we need to provide a definition of equality between them. That is, we will establish
an equivalence relation for arrows of any given category. Since categories may have arrows that are
discernible, an arrow is not necessarily determined by the objects and the position with respect to the
arrow, as is the case with non-discernible arrows.
Definition 4. Two arrows f, g : x → b, of the same category, are the same arrow if for every arrow
h : a → x and i : b → y we verify f, h; g, h and i, g; i, f .
What this means is that an arrow is defined to be the same as another in terms of the result of the
operation ∗. We say f, g are the same when f ∗ h is the same as g ∗ h and i ∗ f is the same as i ∗ g, for
every h, i composable with f, g.
23

CHAPTER II. CATEGORY

24

It remains to be proven that this is indeed an equivalence relation, defined on the arrows of the
category. Reflexivity is trivially verified. Symmetry is not hard to prove; we know g, h; f, h is a notation
to replace f, h; g, h and i, f ; i, g replaces i, g; i, f . Suppose e is the same as f and f is the same as g.
Since e, h; f, h and f, h; g, h we can say that e, h; g, h. Similarly, one finds i, g; i, e.

3.2 Classifying Arrows [I]
Invertible Defining types of arrows is important for classifying functions, and more generally,
functors. We say that f : a → b is invertible if there exists f −1 : b → a such that f −1 ∗ f and
f ∗ f −1 are 1a and 1b , respectively. If there is an invertible arrow between two objects, we say they are
isomorphic. So, we say an arrow that makes two object isomorphic, is an isomorphism. The collection
of isomorphisms from for any pair of objects is represented as {a →iso b}.
Proposition 3.1. The relation of isomorphism, is an equivalence relation on the objects of the category.
Proof. First, we know that any object a, of the category, is isomorphic to itself because 1a is invertible and 1a ; 1a, 1a . By definition, symmetry holds; if f is invertible, then so is f −1. Now, let a, b be
isomorphic with f and b, c isomorphic with g. Consider the arrow f −1 ∗ g−1 , and it is easy to verify
g ∗ f ; 1c, f −1 ∗ g−1 and f −1 ∗ g−1 ; 1a, g ∗ f .
Say f −1 and g both make f invertible, we shall prove they are the same arrow. We know they are
both functions of the form b → a, so now it must be shown that the operations coincide. Let h be an
arrow composable with f −1 , g.
g
g
g
g
g
g
g
g, h

;
;
;
;
;
;
;
;

g ∗ h, h
1a ∗ (g ∗ h), h
(1a ∗ g) ∗ h, h
[( f −1 ∗ f ) ∗ g] ∗ h, h
[ f −1 ∗ ( f ∗ g)] ∗ h, h
[ f −1 ∗ 1b ] ∗ h, h
f −1 ∗ h, h
f −1 , h

With this we prove that f −1, g have the same left operation for composition. We can just as easily
show that they have the same right operation.
Proposition 3.2. The inverse of an invertible arrow is unique.
Left and Right Inverse If two discernible arrows have the same source and target, we say they are
parallel. An arrow f : x → b is left cancellable if for every pair of parallel arrows g, h : a → x, the
expression f, g; f, h implies 1 x , g; 1 x , h. Suppose for every g, h : b → y, the expression g, f ; h, f implies
g, 1b; h, 1b. Then we say f is right cancellable.
If there is an arrow l : b → a such that l ∗ f is 1a , we say f has left inverse. In a similar manner, f
has right inverse if there is r : b → a such that f ; 1b, r.
Proposition 3.3. If f has left inverse, then it is left cancellable because we can apply f −1 to f, g; f, h.
An arrow with right inverse is right cancellable.

4. SOME CATEGORIES

25

Now we give a result that characterizes monic functions as functions with left inverse. It will later
be proven that onto functions are characterized as functions with right inverse.
Lemma I. A function has left inverse if and only if it is monic.
Proof. If the function has left inverse, and a, b are different objects, then (l ◦ f )a and (l ◦ f )b are also
different. Therefore, f a and f b must be different, so that l is a function. This means f is monic.
Suppose f is monic; we will give l : Range f → Dom f such that a; a, l ◦ f . Take y in the image of
f so that x; y, f for some x in the domain. We define y; x, l. If, however, y is not in the image, we can
take any a in the domain and define y; a, l. The reader can prove this is a left inverse.
Lemma II. A function has right inverse if and only if it is onto.
Proof. Let f be a function with right inverse r : Range f → Dom f . This means that for every y in the
range of f , we verify y; y, f ◦ r. It is tue that f is onto because to every y, in the range, we assign an
object, in the domain, whose image, under f , is y.
If the function is onto, every element of the range has non-empty inverse image. Let f −1 [[{{Im f }}]]
represent the collection of inverse images, of objects in the range; this notation will later be justified
when we study set functions. We are giving a collection whose objects are f −1 [{y}], where {y} can be
any collection of one object, in Range f . There is a selection function S : f −1 [[{{Im f }}]] → Dom f , for
the family f −1[[{{Im f }}]]. Let T : Range f → f −1 [[{{Im f }}]] be the function that sends y 7→T f −1[{y}].
It is now necessary to verify that S ◦ T acts as right inverse of f .
Theorem 3.4. A function has inverse if and only if it is bijective.
uodate nexr appt send miles cb

§4 Some Categories
We see that a category is an efficient way of describing partial orders, collections of functions, and
operations. These descriptions are given in the present section.

4.1 Partial Order
A partial order can be seen as a category. We shall prove that the objects and relations of a partial order
define c-objects and arrows of an order category. The relations of the partial order are a collection
of order arrows for the objects because the order is reflexive and transitive. Anti-symmetry means
there is at most one relation for two objects. The reflexive arrow is the unit and we now only need to
verify associativity for the order relations. We see that the operation for two relations b ≤ c ∗ a ≤ b,
results in a ≤ c; recall that this operation works as composition for functions. It is therefore clear that
associativity holds, since we get the same result from c ≤ d ∗ (b ≤ c ∗ a ≤ b) and (c ≤ d ∗ b ≤ c) ∗ a ≤ b.

4.2 Algebraic Category
An important type of category is that which consists of domains and functions. That is, we consider
categories whose c-objects are collections and whose arrows are functions. When we study sets, we
will see that functions are arrows in the category of sets. For now, we study a particular case. Consider

CHAPTER II. CATEGORY

26

a system that consists of one c-object O and the arrows are functions O → O. We want to prove that
this system is a category. The collection of functions is a collection of order arrows for O because they
are distinguishable and we have defined the function IO and composition for functions. The function
I acts as the unit. Associativity has already been proven for functions. When cosidering these types
of categories, we will usually consider the category {O fiso O} of bijective functions. Notice that this
category consists of one c-object and the arrows have inverse. We now move on to a type of category
that generalizes these categories of functions.
An algebraic category is a category C with one object in O|C; it consists of one c-object, e. In this
particular instance, the arrows, all of which are reflexive arrows of e, are called objects of operation.
Notice that the operation is full. We are using the concept of category to simplify our view of a system
that has an operation defined. We have chosen a unit object for the operation, by choosing to have
one c-object. Our unit is clearly the arrow that appears in 1) of the definition to a category. Moreover,
we also represent this arrow with e. We may say that a system is an associative category if it satisfies
everything except 1) in the definition of category (there is no unit).
A group is an algebraic category such that its c-objects all have inverse to the unit. This form of
reasoning will also help build the integers with sum. For all objects of operation f, g, h, of a group,
1) f ; f, e

Re f. (Unit)

2) f ; e, f −1

S ymm. (duality)

3) g∗, g∗; ∗ f, ∗ f

or

g, f ; g ∗ h, h ∗ f

We will prove f −1; e, f and e; f, f also hold.
f −1
f −1
f −1
f −1
f −1
f −1
f −1

;
;
;
;
;
;
;

f −1 ∗ f, f
( f −1 ∗ f ) ∗ e, f
( f −1 ∗ f ) ∗ [ f −1 ∗ ( f −1 )−1 ], f
[( f −1 ∗ f ) ∗ f −1 ] ∗ ( f −1)−1 , f
[ f −1 ∗ ( f ∗ f −1 )] ∗ ( f −1)−1 , f
f −1 ∗ ( f −1 )−1 , f
e, f
e
e
e
e

;
;
;
;

e ∗ f, f
( f ∗ f −1) ∗ f, f
f ∗ ( f −1 ∗ f ), f
f ∗ e, f

What is more, f and ( f −1 )−1 are the same object.
f
f
f
f
f

;
;
;
;
;

f, e
f ∗ e, e
f ∗ [ f −1 ∗ ( f −1 )−1 ], e
( f ∗ f −1 ) ∗ ( f −1 )−1 , e
( f −1 )−1 , e

T rans. (Associativity),

5. FUNCTOR

27

One of the important properties of a group is that there always is a unique solution to f ; g, x, for x.
It is straightforward to verify that we have one solution to f ; g, x:
f ; f ∗ ( f −1 ∗ g), f −1 ∗ g
f ; ( f −1 ∗ f ) · g, f −1 ∗ g
f ; g, f −1 ∗ g.
We use associativity to prove ∗ is left cancellable; this last means f is left cancellable, for every f
in the category that is not e. If f, g; f, h, then
f −1
f −1
f −1
f −1 ∗ f
f −1 ∗ f, e
e, e
e, g

;
;
;
;
;
;
;

f −1 ∗ ( f ∗ g), f ∗ h
( f −1 ∗ f ) ∗ g, f ∗ h
g, f ∗ h
g, h
g, h
g, h
e, h.

Let us now suppose we have two solutions x1 , x2 . That is, f ; g, x1 and f ; g, x2. We may conclude
e, x1 ; e, x2 which means they are the same object of operation. An important consequence of this is that
the unit and inverse are unique. A similar exposition shows the only solutions to x; g, f is g ∗ f −1 :
g ∗ f −1 ; (g ∗ f −1 ) ∗ f, f
g ∗ f −1 ; g ∗ ( f −1 ∗ f ), f
g ∗ f −1 ; g, f.
Also, given g, f ; h, f we have g, e; h, e. A group is said to be abelian if the operation is commutative.
Proposition 4.1. If ∗ is left cancellable and x is not a unit, then the left operation functions x∗ are
monic. If the operation is right cancellable, the right operation functions ∗x are onto.
Proof. Take a left operation f ∗, and let g, h be objects of the category such that f, g; f, h which is true
if and only if f ∗ (h) is the same object as f ∗ (g). We know that e, g; e, h holds, so f ∗ is monic.
A similar proof is valid for functions ∗ f , given ∗ is right cancellable.
Proposition 4.2. The left and right operation functions, for a group G, are invertible.
Proof. In a group, the inverse objects of operation commute. It is therefore clear that x ∗ ◦(x−1 )∗ is the
same function as (x−1 ) ∗ ◦x∗.

§5 Functor
At various points in our studies, we will come across a concept of generalized functions; we will
consider functions from a category into another. This means that we need to define a function on the
collection of objects of a category. It will be necessary to define two part functions for categories, so
that c-objects will be sent into c-objects, and arrows will be sent into arrows. In this section we discuss

CHAPTER II. CATEGORY

28

the concept of functor; a two part function between categories. There is an important aspect about the
functor, that will arise in the definition, and we mention it briefly. When defining a functor, we request
three conditions, for the two part function; natural pair of functions are behind each of these.
Let 1C be the unit function of C, defined by x 7→1C 1 x . The first condition that a functor satisfies
means that we invariably obtain the same result by i) sending an object into its reflexive arrow and then
transforming the arrow, or ii) transforming the object first, and associating the reflexive arrow second.
In short, F1 x and 1F x are the same object. The condition is expressed in terms of the notation for
composition of functions as operation.
A functor contains an arrow function and this arrow function will preserve arrows in the following,
intuitive sense. If f : a → b, then the functor will send f into an arrow from the transformed object of
a, into the transformed object of b. In other words, the arrow function sends arrows, to arrows between
corresponding objects. In condition 2) we will use the notation in terms of comparability, where weak
arrows are the arrows of C and D and strong arrows are the components of FA .
We will finally request that functors preserve the operation of arrows. This means that we will obtain
the same result after applying the functor to a composition of arrows, as we would from composing the
corresponding transformed arrows. This means that the notation is used in terms of the composition
operation for functions.
Definition 5. A functor F : C → D is a two part function FO , FA : O|C, A|C → O|D, A|D such that
for every arrow f : a → b, we have
1) 1D , 1C ; FA , FO

Preserves Unit

2) a, b; FO a, FO b

Preserves Objects

3) FA , FA ; ∗FO f, ∗ f

Preserves Composition

So, a functor is a function that preserves: 1) the unit property for the operation, 2) arrows amongst
respective pairs of objects, and 3) the transitive property for the collection of arrows.
The composition of a functor is a functor. Let F,G : C, D → D, E. We have 1D , 1C ; FA , FO and
1E , 1D ; GA , GO . Let G ◦ F be the two part function that consists of GO ◦ FO and GA ◦ FA .
1E
1E
1E
1E
1E
1E , 1C

;
;
;
;
;
;

(1E ◦ GO ) ◦ FO , GO ◦ FO
(GA ◦ 1D ) ◦ FO , GO ◦ FO
GA ◦ (1D ◦ FO ), GO ◦ FO
GA ◦ (FA ◦ 1C ), GO ◦ FO
(GA ◦ FA ) ◦ 1C , GO ◦ FO
GA ◦ FA , GO ◦ FO .

Next, we verify condition 2) is satisfied.
f
f
f
f

;
;
;
;

G[F(a → b)], G ◦ F
G(Fa → Fb), G ◦ F
G(Fa) → G(Fb), G ◦ F
(G ◦ F)a → (G ◦ F)b, G ◦ F.

5. FUNCTOR

29

Finally, we see 3) holds:
a∗b
a∗b
a∗b
a∗b

;
;
;
;

(G ◦ F)(a ∗ b), G ◦ F
G[F(a ∗ b)], G ◦ F
G[Fa ∗ Fb], G ◦ F
(G ◦ F)a ∗ (G ◦ F)b, G ◦ F.

The following result establishes that functors send ismorphisms into isomorphisms.
Proposition 5.1. If F : C → D is a functor and f : a → b is an isomorphism in C, then F f is an
isomorphism in D.
Proof. The arrow f −1 : b → a has image F f −1 : Fb → Fa; we wish to show F f −1 and F f are inverse.
F f −1
F f −1
F f −1
F f −1

;
;
;
;

F f −1 ∗ F f, F f
F( f −1 ∗ f ), F f
F1a , F f
1Fa , F f

5.1 Natural Pair of Functions in the Definition of Functor
We now study the role of natural pair of functions in the definition of functor. The concept appears in
very clear form when we give 1). In defining a functor we consider two categories C and D. But, we
have also brought into play 1C : O|C → A|C. So, let FO and FA be the transformation of the domain
and image, respectively. We conlcude that in order for F to be a functor, 1C and 1D have to be a natural
pair of functions under the two simplified versions of F.
Given an arrow f : a → b in C, we will consider it to be a one component function. Also, the arrow
F f is a one component function Fa → Fb. In 2), we are stating that f is sent into some function F f ,
with which it is a natural pair of functions, under FO . That is, the one component function FO : a → b.
Now we consider that ∗ f and ∗F f transform A|C and A|D, respectively. The third statement in the
definition of functor states that F can be applied to an arrow, after applying ∗ f , or one can first apply
F and then ∗Fa. Thus, we can restate 3) by saying FA is a natural pair with itself, under ∗ f and ∗F f .

5.2 Isomorphism
The purpose of this subsection is to show that we already have a criteria of isomorhpism defined for
functors. We will also describe weaker forms of isomorphism that make sense, for functors.
Let Cat represent the system with all categories as objects, and functors as arrows. It is not difficult
to see that functors are a collection of order arrows for categories. They are discernible arrows and
composition is well defined. Consider the identity functor IC which acts as unit on objects and arrows of
the category C. We know Cat is associative because functions are associative. Since identity functions
act as unit under composition, so does the identity functor. This means that Cat is a category. The
functor ICat is an arrow of Cat; proving this is a functor is not difficult.
Since we are dealing with a category, and functors are the arrows, it is oportune to mention that
{CFD} represents the collection of functors from C into D. As one may expect, we use CFD to
represent the collection of all functors from any subcategory of C into any subcategory of D.

CHAPTER II. CATEGORY

30

Definition 6. A functor F is an isomorphism between C and D if FO and FA are bijections. An
isomorphism from one category to itself is called an automorphism.
Following our conventions, we agree to use {CFiso D} in representation of the collection that consists
of all isomorphisms from C to D. From theorem 3.4 we know the isomorphism has inverse functions
−1
F−1
O and FA , to the object and arrow functions, respectively. We may now prove the following result.
Lemma. The definition of isomorphism between categories, coincides with the definition of isomorphic
arrows in the category Cat. That is to say, all isomorphisms are invertible arrows.
Theorem 5.2. The system of one c-object, C, and automorphisms, is a group.
Proof. We know that the composition of an isomorphism is again an isomorphism; the composition
of functors is a functor, and the composition of bijective functions is bijective. Also, IC is an isomorphism, so that isomorphisms are a collection of order arrows for categories. Furthermore, the system of
categories and isomorphisms is a category because functions are associative.
The system of one c-object, C, and automorphisms for arrows, is indeed an algebraic category
because it consists of one c-object, namely C. It is a group because of the lemma.
Corollary. The collection of bijective functions {O fiso O} is the the group of transformations of X. If H
is a group such that the group of transformations is a detailed version of H, we say H is a group of
transformations of X.

5.3 Classification of Other Functor Types
We have no guarantee that, given a, b in C and an arrow h : Fa → Fb in D, there is an arrow f : a → b
in C such that f ; h, F. When this is true for every a, b in C and arrow h : Fa → Fb, we say the functor
is full. It is faithful if for every f, g : a → b, the expression f, F; g, F implies f, IC ; g, IC .
Fa→Fb}
Consider the function FA |{{a→b}
; we restrict the domain, of FA , to {a → b}, and then we retrict the
range of FA |{a→b} to its image, {Fa → Fb}. We are making the observation F{a → b} := {Fa → Fb}.
Proposition 5.3.
1) A functor F : C → D is full if and only if for every pair of objects a, b, in the domain category C,
Fa→Fb}
the function FA |{{a→b}
is onto.
2) A functor F : C → D is faithful if and only if for every pair of objects a, b, in the domain category
Fa→Fb}
C, the function FA |{{a→b}
is monic.
Of course, a functor that is full and faithful is not necessarily an isomorphism because we have no
knowledge regarding the object function FO .
Embedding An embedding is a faithful functor with monic object function. We have already
studied an instance of this, when we introduced order preserving functions. We have left clear that an
order embedding is a monic function. We make this the monic function of a functor P → Q. We need
to define the arrow function and this could not be easier. We already know that the arrows of a patial
order are non-discernible. Since a ≤ b if and only if f a ≤ f b, the arrow function is defined.

5. FUNCTOR

31

Embedding will be a concept used throughout in order to show that one category can be seen as an
extension of another. Let us consider this in terms of systems. Take a system S , and give a separation
of it that loses information. We keep a certain subcollection S , and we take away the arrows that do not
pertain to the objects we are left with. This is a one way of giving an idea of embedding in a system.
We are attributing an object in one system to an object in another system. Different objects are assigned
different objects. The relations in one system are relations in another.
Functor for Partial Orders We are now able to speak of functors for partial orders; these functors
are order preserving functions.
Lemma. Given an order preserving function f : O|P → O|Q, we have a functor F : P → Q whose
object function is f .
Proof. We have already seen that partial orders are categories, so it is left to show that the properties
of functor are satisfied. The arrow function is determined by property 2) of functors; recall that there
is at most one arrow in a partial order. This means that a relation a ≤ b, in P, is sent into the relation
f a ≤ f b for objects of Q; we know this relation exists in Q because the function is order preserving.
Take an object a in P and apply the functor to it and then we send that object to the unit arrow; the
result is Fa ≤ Fa. If, on the contrary we apply 1P to a and then send a ≤ a to its corresponding arrow,
the result is Fa ≤ Fa.
We are left to prove 3)
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b

;
;
;
;
;

F(b ≤ c ∗ a ≤ b), F
F(a ≤ c), F
Fa ≤ Fc, F
Fb ≤ Fc ∗ Fa ≤ Fb, F
F(b ≤ c) ∗ F(a ≤ b), F.

Theorem 5.4. If f is an order bijectivity, then F, with f as object function, is an isomorphism.
Proof. We only need to prove that the arrow function is bijective, because f is bijective. The arrows in
the partial orders are non-discernible and f sends every a ≤ b into a unique arrow f a ≤ f b.
If we have an arrow x ≤ y, in Q. Then, there are a, b in P such that a; x, F and b; y, F, and an arrow
a ≤ b. The arrow Fa ≤ Fb is the arrow assigned to a ≤ b.
Opposite Category and Contravariant Functor The topic of this paragraph is inspired on previous developments for partial orders. Given a category C, we construct a system consisting of the same
objects, and for every arrow f : a → b we give an arrow f op : b →op a. The system that results is called
the opposite of C and we write it with Cop .
Of course, 1Cop is defined as the function that acts as x; 1op
x , 1Cop . Now it is on us to define the operation
in Cop . Let us consider a composable pair of arrows, say f : a → b and g : b → c. Then we define the
arrow f op ∗ gop as the arrow c →op a that is opposite of b → c ∗ a → b. In other words, f op ∗ gop is
defined as (g ∗ f )op .
Lemma I. The opposite, of a category C, is also a category.

CHAPTER II. CATEGORY

32

op
Proof. We would like to show that 1op
: x →op a
a is indeed the unit of a in the opposite category. If f
op
is an arrow in C , then we have
op
op
1op
; 1op
a
a ∗ f , f
1op
; ( f ∗ 1a )op , f op
a
1op
; f op , f op
a

If gop : y →op b, then
op
gop ; gop ∗ 1op
y , 1y
gop ; (1y ∗ g)op , 1op
y
gop ; gop , 1op
y

To show that associativty holds, consider hop : b →op x:
f op
f op
f op
f op
f op
f op

;
;
;
;
;
;

f op ∗ (hop ∗ gop ), hop ∗ gop
f op ∗ (g ∗ h)op , hop ∗ gop
[(g ∗ h) ∗ f ]op , hop ∗ gop
[g ∗ (h ∗ f )]op , hop ∗ gop
(h ∗ f )op ∗ gop , hop ∗ gop
( f op ∗ hop ) ∗ gop , hop ∗ gop

Lemma II. Given a functor F : C → D, there is a functor Fop : Cop → Dop .
Proof. We define Fop as the functor with FO as object function. Suppose f op : b →op a is an arrow in
Cop ; it is the opposite of the arrow f : a → b and we define f op ; (F f )op , Fop .
To prove 1) of functors, let x be a c-object in Cop
x ; (1Dop ◦ FO )x, 1Dop ◦ Fop
O
x ; 1Dop (Fx), 1Dop ◦ Fop
O
op
op
◦
F
,
1
x ; 1op
O
Fx D
op op
x ; F (1 x ), 1Dop ◦ Fop
O
op
.
x ; (F ◦ 1Cop )x, 1Dop ◦ Fop
O
We know that (F f )op is of the form Fb →op Fa. This means that 2) is satisified. To verify 3), let
gop : c →op b, so that
f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop

;
;
;
;
;
;

Fop ( f op ∗ gop ), Fop
Fop (g ∗ f )op , Fop
[F(g ∗ f )]op , Fop
(Fg ∗ F f )op , Fop
(F f )op ∗ (Fg)op , Fop
Fop f op ∗ Fop gop , Fop

5. FUNCTOR

33

Theorem 5.5. There is a functor op : Cat → Cat that sends a category to its opposite category, and a
functor to its opposite functor.
Proof. The functor op, acts as F; Fop , op and C; Cop, op. It is not difficult to see (1Cat ◦ opO )C is the
same as (opA ◦ 1Cat )C, which verifies 1) for functors. 2) is true because C, D; opC, opD is the same as
saying F : C → D is sent into Fop : Cop → Dop . Given G : D → E, the relation G ◦ F; opG ◦ opF, op
holds; (G ◦ F)op : Cop → Eop and Gop ◦ Fop : Cop → Dop → Eop are equal. Let f op be an arrow in Cop ,

f
f
f
f
f
f

;
;
;
;
;
;

(G ◦ F)op f op, (G ◦ F)op
[(G ◦ F) f ]op , (G ◦ F)op
[G(F f )]op , (G ◦ F)op
Gop (F f )op , (G ◦ F)op
Gop (Fop f op ), (G ◦ F)op
(Gop ◦ Fop ) f op , (G ◦ F)op .

We say F⋉ is contravariant if instead of satisfying condition 2), it satisfies 2)′ a, b; F⋉O b, F⋉O a. This
means that arrows are reversed. In terms of natural pair of functions, we are saying that f : a → b
is sent into some function F⋉ f : F⋉ b → F⋉ a such that f is a natural pair of functions with (F⋉ f )op ,
under F⋉O . This has implications for condition 3); let g : b → c:
b→c∗a→b
b→c∗a→b
b→c∗a→b
b→c∗a→b
b→c∗a→b

;
;
;
;
;

F⋉ (b → c ∗ a → b), F⋉
F⋉ (a → c), F⋉
F⋉ c → F⋉ a, F⋉
F⋉ b → F⋉ a ∗ F⋉ c → F⋉ b, F⋉
F⋉ (a → b) ∗ F⋉ (b → c), F⋉

Thus, a contravariant functor satisfies 3)′ F⋉ , F⋉ ; ∗F⋉ g, g∗ instead of 3). Equivalently, F⋉ (g ∗ f ) is
the same object as F⋉ f ∗ F⋉ g; in notation for function, we have g ∗ f ; F⋉ f ∗ F⋉ g, F⋉ . This can be
resolved in a simple way, using the opposite category of the range category. Let us be clear, a functor is
covariant when it satisfies 1), 2), 3), and contravariant when it satisfies 1), 2)′ , 3)′.
Theorem 5.6.
1) Given a contravariant functor F⋉ : C → D, there is a covariant functor F : C → Dop .
2) Given a covariant functor F : C → D, there is a contravariant functor F⋉ : C → Dop .
Proof.
1) The covariant functor F is defined to have the same object function but the arrow function is FA
which sends f : a → b into FA f := (F⋉A f )op : Fa → Fb.

CHAPTER II. CATEGORY

34
To show that 1) holds,
x
x
x
x
x
x

;
;
;
;
;
;

(1Dop ◦ F⋉O )x, 1Dop ◦ FO
1Dop (F⋉O x), 1Dop ◦ FO
(1F⋉O x )op , 1Dop ◦ FO
(F⋉A 1 x )op , 1Dop ◦ FO
FA 1 x , 1Dop ◦ FO
(FA ◦ 1C )x, 1Dop ◦ FO .

This means 1Dop , 1C ; FA , FO . The definition of FA assures us that 2) is satisfied. Moving on to 3),
we make f : a → b and g : b → c.
g∗
g∗
g∗
g∗
g∗

f
f
f
f
f

;
;
;
;
;

F(g ∗ f ), F
[F⋉ (g ∗ f )]op , F
[F⋉ f ∗ F⋉ g]op , F
(F⋉ g)op ∗ (F⋉ f )op , F
Fg ∗ F f, F

2) We will carry out the proof of the second part of this theorem, although it is similar to the first.
Here, we define F⋉A f := (FA f )op
x
x
x
x
x
x

;
;
;
;
;
;

(1Dop ◦ FO )x, 1Dop ◦ F⋉O
1Dop (FO x), 1Dop ◦ F⋉O
(1FO x )op , 1Dop ◦ F⋉O
(FA 1 x )op , 1Dop ◦ F⋉O
F⋉A 1 x , 1Dop ◦ F⋉O
(F⋉A ◦ 1C )x, 1Dop ◦ F⋉O .

Since (FA f )op is Fb →op Fa, we know F⋉ is contravariant. Now, we prove 3)′ holds:
g∗
g∗
g∗
g∗
g∗

f
f
f
f
f

;
;
;
;
;

F⋉ (g ∗ f ), F⋉
[F(g ∗ f )]op , F⋉
[Fg ∗ F f ]op , F⋉
(F f )op ∗ (Fg)op , F⋉
F⋉ f ∗ F⋉ g, F⋉ .

Corollary. If f ⋉ : O|P → O|Q is an order reversing function, then it is the object function of a covariant
functor F : P → Qop .

5. FUNCTOR

35

Proof. All that we need to prove is that there is a contravariant functor P → Q. The proof of 1) is the
same as in theorem , and 2) is given by the fact that f is order reversing. We are left to prove 3).
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b
b≤c∗a≤b

;
;
;
;
;

F(b ≤ c ∗ a ≤ b), F
F(a ≤ c), F
Fc ≤ Fa, F
Fb ≤ Fa ∗ Fc ≤ Fb, F
F(a ≤ b) ∗ F(b ≤ c), F.

Corollary.
1) Let f be an order bijectivity P, Q; Pop, Qop . Then, there is a covariant isomorphism F : P → Q.
2) Suppose P and Q are dual orders. Then, there is a covariant isomorphism F : P → Qop .
There is another side to this. We can prove that given a covariant functor F : C → D, there is a
contravariant functor F⋉ : Cop → D. As one may expect, we can also say that given a contravariant
functor C → D, there is a covariant Cop → D.
Proposition 5.7. If F : C → D is a covariant functor, then so is Fop . Likewise, (F⋉ )op is contravariant,
given F⋉ is contravariant.
Algebraic Functor An algebraic functor is one such that the source and target are algebraic categories. Given two algebraic categories, it is trivial to define a functor from one category to the other.
Suppose e1 , e2 are the c-objects of C, D, respectively. This means that every arrow in C is a reflexive
arrow for e1 , and similarly for D and e2 . With this in mind, we see that any functor C → D has the
object function defined by FO e1 := e2 . One can easily see that the composition of algebraic functors is
again an agebraic functor. We already know that the composition of functors is a functor and it is easy
to give the object function of a compostition of algebraic functors.
Let ∗ be the operation of composition for the objects of operation, in any category C, and give a
function ⊙ : O → CFC, with a collection O in the domain. We are assigning every object in the domain,
a functor, from some subcategory into the category itslef. This defines an operation · : O → A|C f A|C.
Since every object in the image of ⊙ is a functor, we can say that ⊙x( f ∗ g) is the same as ⊙x f ∗ ⊙xg. In
other words, f ∗ g; f · x ∗ g · x, x in terms of the notation for ·.
Proposition 5.8. If there is a function from some collection O into CFC, then there is an operation ·
that distributes over the operation ∗, of the category.
Recall theorem 5.2; we sometimes consider an algebraic functor Z → CFC, given Z is algebraic.

5.4 Product Category and Bifunctor
Given two C1 , C2 categories, form a system C, with O|C := O|C1 →× O|C2 and A|C := A|C1 →× A|C2 ;
the arrows of C are objects that consist of two arrows. We are using comparability for arrows. Weak
arrows are those in C1 and C2 . The arrows in C are strong (ordered pairs of arrows). In short, C is a
category, with O|C := O|C1 →× O|C2 and A|C := A|C1 →× A|C2 .

CHAPTER II. CATEGORY

36

We define the arrows in a natural manner. Let a →× b a c-object, in C. Take arrows f : a →C1 c
and g : b →C2 d; to avoid confusion, we will use the notation a →C1 c to express that the arrow is in
category C1 . The reader can see that a →× b and c →× d are a natural pair of functions, under f, g.
Moreover, a →× b and c →× d are c-objects in C. We define an arrow f →× g : a →× b −→ c →× d.
Theorem 5.9. The system C, defined in terms of C1 , C2 , is a category and we say it is the product
category of C1 and C2 (in that order). This category may be expressed as C1 × C2 .
Proof. We first need to prove that A|C1 →× A|C2 is a collection of order arrows for O|C1 →× O|C2 .
Given a c-object a →× b, in C, we know the c-objects a, b are in C1 , C2 , respectively. These satisfy
a; 1a, 1C1 and b; 1b, 1C2 , for their unit arrows because C1 and C2 are categories. We define the unit arrow
1a→× b as the arrow 1a →× 1b : a →× b −→ a →× b.
Suppose we have two arrows in the product category; say f →× g : a →× b −→ c →× d and
h →× i : c →× d −→ x →× y. It is clear that there is an arrow h ∗ f , in C1 , and an arrow i ∗ g, in C2 .
The composition h →× i ∗ f →× g : a →× b −→ x →× y, is defined as the arrow h ∗ f →× i ∗ g, so that
a →× b and x →× y are a natural pair under h ∗ f : a → x and i ∗ g : b → y. In other words, if we use
the notation for the operation ∗ of C, we have
h →× i; h ∗ f →× i ∗ g, f →× g.

(II.1)

We move on to show that the unit and associativity are true, for the operation ∗ that acts on the
category C. First, we will show that 1c→× d is the unit of the c-object c →× d, in C.
1c→× d ; 1c →× 1d ∗ f →× g, f →× g
1c→× d ; 1c ∗ f →× 1d ∗ g, f →× g
1c→× d ; f →× g, f →× g.
h →× i ; h →× i ∗ 1c →× 1d , 1c→× d
h →× i ; h ∗ 1c →× i ∗ 1d , 1c→× d
h →× i ; h →× i, 1c→× d .
Finally, we have to prove associativity. We have to consider two more arrows, let us use j : x → w
and k : y → z. We have a new arrow in C; the arrow is j →× k. In terms of the notation for ∗,
j →× k
j →× k
j →× k
j →× k
j →× k
j →× k
j →× k, f →× g

;
;
;
;
;
;
;

( j →× k) ∗ (h →× i ∗ f →× g), h →× i ∗ f →× g
( j →× k) ∗ (h ∗ f →× i ∗ g), h →× i ∗ f →× g
j ∗ (h ∗ f ) →× k ∗ (i ∗ g), h →× i ∗ f →× g
( j ∗ h) ∗ f →× (k ∗ i) ∗ g, h →× i ∗ f →× g
( j ∗ h →× k ∗ i) ∗ ( f →× g), h →× i ∗ f →× g
( j →× k ∗ h →× i) ∗ ( f →× g), h →× i ∗ f →× g
j →× k ∗ h →× i, h →× i ∗ f →× g

Proposition 5.10. The opposite of a product category, is the product of the opposites; that is to say
op
(C1 × C2 )op and Cop
1 × C2 are the same category.

5. FUNCTOR

37

Proof. A category and its opposite have the same c-objects, so we have not much to prove about the
c-objects, we are interested in the arrows. Let g →× op f represent the arrow ( f →× g)op , in (C1 × C2 )op .
The arrow f →× g is of the form a →× b −→ c →× d because f : a →C1 c and g : b →C2 d. We are
able to express g →× op f : c →× d −→op a →× b which means that we want to define ( f →× g)op as an
op
ordered pair, of c →C1 a and d →C2 b. We define ( f →× g)op := f op →× gop , which is in A|(Cop
1 × C2 ).
We have to show that this definition and the definition of product for opposite category are consistent. with each other. We reiterate the naming of arrows, as in the previous result; let f : a →C1 c,
h : c →C1 x, g : b →C2 d, and i : d →C2 y. We know f →× g takes a →× b into c →× d, and h →× i
takes c →× d into x →× y.
(f
(f
(f
(f
(f
(f

→×
→×
→×
→×
→×
→×

g)op
g)op
g)op
g)op
g)op
g)op

;
;
;
;
;
;

( f →× g)op ∗ (h →× i)op , (h →× i)op
f op →× gop ∗ hop →× iop , (h →× i)op
f op ∗ hop →× gop ∗ iop , (h →× i)op
(h ∗ f )op →× (i ∗ g)op , (h →× i)op
(h ∗ f →× i ∗ g)op , (h →× i)op
(h →× i ∗ f →× g)op , (h →× i)op

Product Functor for Common Domain It is interesting to see what happens when a functor is
defined for product categories. What can be said about a functor F : C1 × C2 → D1 × D2 ? We will
carry out a detailed analysis, one step at a time. Begin, considering a functor into a product category.
Proposition 5.11. Given functors f, g : C → D1 , D2 , there is a functor f × g : C → D1 × D2 , and we
say it is the product functor of common domain.
Proof. Let f : C → D1 and g : C → D2 be two functors. We shall build a functor F : C → D, where
the range is the product category. The object function, of F, sends a 7→ fa →× ga. We make the arrow
function send f : a →C c into f f →× g f . To verify we have a functor, apply 1D ◦ F to any c-object
a in C, the result is 1fa →× 1ga . On the other hand, a 7→1C (1a ) 7→F (f1a →× g1a ); we can say 1) of
functors is true because it is true for f and g. We would like to see that F f is an arrow of the form
fa →× ga −→ fc →× gc, which is true because F f is f f →× g f . With this we have proven that an arrow
from a →C c is sent into an arrow Fa → Fc. Lastly, we will show that 3) holds. Let h : c → x, then
h∗
h∗
h∗
h∗
h∗

f
f
f
f
f

;
;
;
;
;

F(h ∗ f ), F
f(h ∗ f ) →× g(h ∗ f ), F
fh ∗ f f →× gh ∗ g f, F
fh →× gh ∗ f f →× g f, F
Fh ∗ F f, F.

One may now ask, given a functor F : C → D1 ×D2 , is it possible to decompose it into two functors
with common domain? We are saying that the functor sends c-objects a 7→ (F1 a →× F2 a); since the
image of a c-object is an order arrow →× , we use F1 a to denote the source associated to a and F2 a is

38

CHAPTER II. CATEGORY

the target. Also, the functor sends an arrow f : a →C c into an arrow F1 a →× F2 a −→ F1 c →× F2 c
which means we have two arrows, F1 f : F1 a → F1 c and F2 f : F2 a → F2 c. We can associate two
arrows in the range, to every arrow in the domain; f is assigned the arrows F1 f , F2 f .
Proposition 5.12. Given a functor F : C → D1 × D2 , there are functors f : C → D1 and g : C → D2
such that f × g and F are the same functor.
We have proven a functor has a product category, in the image, if and only if it can be decomposed
as two functors with common domain.
Bifunctor[IX] It is possible to give a functor that acts on pairs of c-objects, and pairs of arrows;
a product category is domain, instead of range. The first thing to be brought to our attention will be
the limitations in dealing with these functors. One may expect to be able to form two functors with
common range, by decomposing a functor F : C1 × C2 → D. This is not true, however. The reader may
convince himself that there is no straightforward way of defining f : C1 → D or g : C2 → D, given a
functor C1 × C2 → D. Also, it is interesting to notice that the range is a simple category (not necessarily
a product category) and we assign each pair of objects into a single object in D. Again, we take two
arrows f, g (from C1 and C2) and we give a single arrow.
When we try giving the product of common range, for two functors C1 , C2 → D, we come across
the following difficulty. Is it possible to build a functor from the product category of the domains into
D? Take functors f, g : C1 , C2 → D, and define F : C1 ×C2 → D such that the c-objects are transformed
according to (a →× b) 7→F F(a, b) := fa. Give arrows f : a → c and g : b → d, then the action of
F on the arrow f →× g is defined by F( f, g) := f f : fa → fc. Let us prove F this is a functor. It
is easily seen that (1D ◦ F)(a →× b) is 1fa , just as (F ◦ 1C1 ×C2 )(a →× b). The second condition of
functors is satisfied; if we apply F to f →× g : a →× b −→ c →× d, the result is an arrow of the
form F(a, b) → F(c, d), because F(a, b) is fa and F(c, d) is fc. To verify that 3) also holds, take a
composable pair of arrows f →× g and h →× i, and apply F to their composition, which has been
defined as h →× i ∗ f →× g := h ∗ f →× i ∗ g. This is expressed as F(h ∗ f, i ∗ g), and in reality it is the
arrow f(h ∗ f ). Also, F(h, i) ∗ F( f, g) is the same as fh ∗ f f . Of course, one can also build a functor G
such that a →× b is sent into gb and f →× g is sent into gg. Although we were able to find functors F
and G, given f, g that have the same range, the functors we found are relatively simple. They are simple
in the sense that we are losing all the infomation of one functor, or another. We are building functors
whose transformation disregards the information regarding one functor. A solution to this, is proposed
in the following proposition.
Proposition 5.13. Let f, g : C1 , C2 → D be functors, then we can define a functor f×g : C1 ×C2 → D×D
called the product of common range.
Proof. We define a c-object function, (f × g)(a, b) := fa →× gb. Let the arrow function be defined by
that transformation (f × g)A ( f, g) := f f →× gg. The reader may prove that this is a functor. If he runs
across any difficulty, a similar construction and proof is carried out, in the theorem of this division.
Let B : C1 ×C2 → D be a function which has a product category in the domain, and suppose it sends
a c-object a →× b into a c-object B(a, b). An arrow f →× g : a →× b −→ c →× d, is sent into an arrow
B( f, g) : B(c, b) → B(a, d). We know there are arrows c →× b and a →× d in C1 × C2 . We will say B
is contravariant with respect to the first argument and covariant with respect to the second argument if
the source and target objects of B( f, g), are the images of c →× b and a →× d, respectively. Although

5. FUNCTOR

39

we are sending pairs into singles, we do it in such a way that the source of B( f, g) depends on c and b.
Conversely, the target depends on a and d. A function B can be suitably defined to be covariant in the
first argument and contravariant in the second. There can also be functions covariant (or contravariant)
in both arguments.
In (II.1), we are giving an operation ∗ : A|C → A|C f A|C. For every f →× g, there is a right
operation function (∗ f, ∗g) : A|C → A|C. The function (∗ f, ∗g) sends h →× i into h ∗ f →× i ∗ g. We
have potential for more functions than just the right operation. The left operation of h →× i is defined
as the function (h∗, i∗) such that f →× g; h ∗ f →× i ∗ g, (h∗, i∗). Still this is not all, since we can define
the right-left operation which is a function (∗ f, i∗) that sends h →× g into h ∗ f → i ∗ g. Finally, we
define the following the left-right operation and use this to express contravariance in the first argument
and covariance in the second. Given two arrows h : c →C1 x and g : b →C2 d, we define the function
(h∗, ∗g) : A|C → A|C that sends ( f →× i) 7→ (h ∗ f →× i ∗ g), where f : a →C1 c and i : d →C2 y. If we
apply B to h ∗ f →× i ∗ g, the result is the arrow B(h ∗ f, i ∗ g), which is of the form B(x, b) → B(a, y).
On the other hand, applying ∗B(h, g) to B( f, i), we get
B( f, i)
B( f, i)
B( f, i)
B( f, i)

;
;
;
;

∗B(h, g)B( f, i), ∗B(h, g)
∗[B(x, b) → B(c, d)][B(c, d) → B(a, y)], ∗B(h, g)
[B(c, d) → B(a, y)] ∗ [B(x, b) → B(c, d)], ∗B(h, g)
B(x, b) → B(a, y), ∗B(h, g).

With this we show that B( f, i) ∗ B(h, g) is parallel to B(h ∗ f, i ∗ g), given B is contravariant in the first
argument and covariant in the second. A function B : C1 × C2 → D is a bifunctor if
1) 1D , 1C1 ×C2 ; BA , BO
2) a →× b, c →× d; B(c, b), B(a, d)
3) B, B; ∗B(h, g), (h∗, ∗g).
The first condition is stating that for any c-object, in C, B(1a , 1b), is the same arrow in D, as 1B(a,b) . It
is the usual first condition for functors, where C is now a product category. The second request for a
bifunctor is the statement that the arrow f →× g : a →× b −→ c →× d is sent into an arrow of the
form B(c, b) → B(a, d). In 3) we are expressing that applying B ◦ (h∗, ∗g) or ∗B(h, g) ◦ B to ( f →× i),
yields the same result in both cases. If it is a bifunctor, then h ∗ f →× i ∗ g; B( f, i) ∗ B(h, g), B is true.
Equivalently, to 3), we can say for every composable pair of arrows, f →× g and h →× i, we verify
condition 3)′ h →× i ∗ f →× g; B( f →× i) ∗ B(h →× g), B.
Proposition 5.14. F : C1 × C2 → D is a functor if and only if there is a bifunctor B : Cop
1 × C2 → D.
Proof. To verify that we have a bifunctor, we start with the property of unit arrows.
a →×
a →×
a →×
a →×
a →×
a →×
a →×

b
b
b
b
b
b
b

;
;
;
;
;
;
;

(1D ◦ F)(a →× b), 1D ◦ BO
1D F(a, b), 1D ◦ BO
1F(a,b) , 1D ◦ BO
FA 1(a→× b) , 1D ◦ BO
FA (1a →× 1b ), 1D ◦ BO
BA [1op
a →× 1b ], 1D ◦ BO
(BA ◦ 1Cop
×C2 )(a →× b), 1D ◦ BO
1

CHAPTER II. CATEGORY

40

With this we are saying that BO (a, b) and FO (a, b) are the same, while BA ( f op , g) := FA ( f, g). An
arrow, in the domain of B, say f op → g : c →× b −→ a →× d, is transformed into the arrow
F( f, g) : F(a, b) → F(c, d). We prove that composition is preserved, with
f op
f op
f op
f op
f op
f op
f op

→×
→×
→×
→×
→×
→×
→×

i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop

→×
→×
→×
→×
→×
→×
→×

g
g
g
g
g
g
g

;
;
;
;
;
;
;

B( f op ∗ hop →× i ∗ g), B
B( f op ∗ hop , i ∗ g), B
B[(h ∗ f )op , i ∗ g], B
F(h ∗ f, i ∗ g), B
F(h →× i) ∗ F( f →× g), B
F(h, i) ∗ F( f, g), B
B(hop , i) ∗ B( f op , g), B

Given B, we define a functor with F(a, b) := B(a, b) and F( f, g) := B( f op , g).
There is a bifunctor, for every functor with a product category in the domain. We will continue to
give examples of bifunctors, from given functors. Given two functors, it shouldn’t be difficult to build
a bifunctor, since it is contravariant in the first argument and covariant in the second argument. In fact,
the reader may verify that the following result is a corollary of the last two propositions. Nevertheless,
we still give the proof, so as to help the reader with understanding the constructions better.
Proposition 5.15. Given two functors f, g : C1 , C2 → D, it is possible to define a bifunctor of the form
op
f×g : Cop
1 ×C2 → D×D. The object function is defined so that (f×g)(a, b) is fa →× gb, and (f×g)( f , g)
is the same as f f →× gg.
Proof. To prove 1),
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)

;
;
;
;
;
;
;
;

1D×D B(a, b), 1D×D
1D×D (fa →× gb), 1D×D
1(fa→× gb) , 1D×D
1fa →× 1gb , 1D×D
f1a →× g1b , 1D×D
B(1op
a , 1b ), 1D×D
op
B(1a →× 1b ), 1D×D
(B ◦ 1Cop
×C2 )(a →× b), 1D×D .
1

Let us now look at the second condition of bifunctors; an arrow f op →× g : c →× b −→ a →× d is
sent into f f →× gg : fa →× gb −→ fc →× gd, which is of the form B(a, b) → B(c, d). Finally,
f op
f op
f op
f op
f op
f op
f op

→×
→×
→×
→×
→×
→×
→×

i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop
i ∗ hop

→×
→×
→×
→×
→×
→×
→×

g
g
g
g
g
g
g

;
;
;
;
;
;
;

B( f op →× i ∗ hop →× g), B
B( f op ∗ hop →× i ∗ g), B
B( f op ∗ hop , i ∗ g), B
f(h ∗ f ) →× g(i ∗ g), B
fh ∗ f f →× gi ∗ gg, B
fh →× gi ∗ f f →× gg, B
B(hop , i) ∗ B( f op, g), B.

5. FUNCTOR

41

Decomposing Bifunctors We proceed with the study of a functor F : C1 × C2 → D1 × D2 . To
begin with, it sends a c-object, say a →× b in C1 × C2 , into a c-object F(a, b) := x →× y in D1 × D2 .
Arrows have to be sent into arrows; give f : a → c and g : b → d in C1 and C2 , respectively. Suppose
F(b, d) = w →× z, then f →× g is an arrow of the form a →× b −→ c →× d, in the domain. The
corresponding image is an arrow F( f →× g) : F(a, b) −→ F(c, d). Let us make observations based on
the results that we already have. First, is an extension of propositions 5.11 and 5.13.
Proposition 5.16. Given two functors f, g : C1 , C2 → D1 , D2 , there is a functor f×g : C1 ×C2 → D1 ×D2 .
Proof. The product functor is defined as FO (a, b) := fa →× gb and FA ( f, g) := f f →× gg.
Theorem 5.17. B : C1 × C2 → D1 × D2 is a bifunctor if and only if B can be expressed as a product of
common domain for two bifunctors p, q : C1 × C2 → D1 , D2 .
Proof. Proposition 5.12 implies that the corresponding functor Cop
1 × C2 → D1 × D2 , associated to
B, can be decomposed as two functors of common domain f, g : Cop
1 × C2 → D1 , D2 . We consider
bifunctors p, q : C1 × C2 → D1 , D2, by applying proposition 5.14 a second time.
Let p, q : C1 × C2 → D1 , D2 two bifunctors of common domain, then we can construct two functors
f, g : Cop
1 × C2 → D1 , D2 , again with result 5.14. From these two we form a functor of common domain,
f × g : Cop
1 × C2 → D1 × D2 . Now we can give a bifunctor B : C1 × C2 → D1 × D2 .
The reader is left to prove the eequality of the product with B.
Corollary. B : C1 × C2 → D × D is a bifunctor if and only if there are bifunctors p, q : C1 × C2 → D,
parallel in Cat.

5.5 Natural Transformation
Our ultimate goal is to generalize concepts, and the natural transformation is next, as exposed by [I].
We see that one way of giving meaning to the situations so far discussed is by interpreting the binary
relations by stronger and weaker arrows. We will see the natural transformation as a strong arrow
between two weak arrows, the functors.
In the last section, given f, g : C → D1 , D2 , we were able to give a functor that was product for
common domain. We did this by giving a category D1 × D2 , and then we can assign a c-object in C,
into an arrow →× , which is a c-object of the product category. Let us consider the situation where D1
and D2 are the same category. We give a functor from C into D × D. Here, we take a turn. Because
D × D is a collection of non-discernible arrows, instead of assigning an arrow →× , to an object in C,
we will assign it an arrow in D.
Let functors f, g : C → D, and function τ : O|C → A|D be such that a 7→τ τa : fa → ga. We say τ
is a bridge from f to g, and we write τ : f → g.
~ := D(τ;
~
~ := Im τ,
Proposition 5.18. Given a bridge, τ : f → g, we can give a category D
f, g), with O|D
~ such that TO := τ.
and a functor T : C → D
~ Given an arrow f : a → b, define an arrow τ f : τa → τb,
Proof. First, we must define the arrows of D.
~
~
for the category D. The composition in D is defined by τg ∗ τ f := τ( f ∗ g); we guarantee the existence
of τ( f ∗ g), for composable arrows in the category C.

CHAPTER II. CATEGORY

42

Given a c-object τb, we have a unit arrow 1τb := τ1b : τb → τb, such that
1τb
1τb
1τb
1τb

;
;
;
;

1τb ∗ τ f, τ f
τ1b ∗ τ f, τ f
τ(1b ∗ f ), τ f
τ f, τ f.

~ has a unit arrow for every c-object τa. The reader should
Similarly, we have τ f ; τ f, 1τa which proves D
~ is a category.
not have difficulty showing associativity holds for the composition, so we conlcude D
If we define TA f := τ f , we have a functor.
Definition 7. A bridge τ : f → g is a natural transformation if for every arrow f : a → b, in C, we have
τb, τa; g f, f f in terms of composition for D.
The expression τb, τa; g f, f f means that τb ∗ f f is the same arrow as g f ∗ τa. It is reasonable to
request this because they are parallel, τb ∗ f f : fa → gb and g f ∗ τa : fa → gb. Equivalently, one can say
the bridge is a natural transformation if and only if f f, g f are a natural pair of functions, under τa, τb.
Proposition 5.19. Let τ, a bridge for two functors f, g : C → D, and suppose the arrows of D are
non-discernible. Then τ is a natural transformation.
Corollary. Suppose there are two order preserving functions f, g : O|P → O|Q such that f a ≤ ga for
every c-object in C. Then, τ : O|P → A|Q that sends a 7→ f a ≤ ga is a natural transformation f → g,
where the functors satisfy fO := f and gO := g.
We are playing with an order defined on the functors of the partial orders. For any two order
preserving f, g : O|P → O|Q, we say f  g if and only if f x ≤ gx, for every object in P. Of course, if
f, g are the functors corresponding to f, g, respectively, then we say f ≤ g.
Proposition 5.20. Let f and g be two functors P → Q, for partial orders. The relation f ≤ g, is a partial
order on the functors.
Proof. Let f represent the object function of f. We observe reflexivity holds in the fact that f ≤ f is
equivalent to the statement f x ≤ f x, for every x in P. Suppose f ≤ g ≤ h. Transitivity holds because we
can assert f x ≤ gx ≤ hx, for every x in P, where g, h is the object function of g, h. If f ≤ g and g ≤ f,
then we have f x ≤ gx and gx ≤ f x for every x. This means f x = gx.
We will build two different categories, using natural transformations as strong arrows for weak
arrows, the functors. That is to say, our categories will have functors as c-objects and natural transformations as arrows. Consider the collection of natural transformations f → g, for a pair of parallel
functors f, g : C → D; we define Nat(f, g) := {f → g}.
Cat(C, D) is a category if Cat(C, D)O := {CFD} and the natural transformations are arrows. First,
every functor has a natural transformation 1f : f → f so that x 7→1f 1fx := fx → fx; in other words, the
unit arrow of f sends an object x, in C, into the unit arrow 1fx , in D. Let use define the operation of
arrows as · so that x 7→σ·τ σx ∗ τx for τ, σ : f, h → h, j. Of course, σx ∗ τx : fx → jx is the composition,
in D, of σx : hx → jx and τx : fx → hx. To prove this is indeed a natural transformation, use the arrow

5. FUNCTOR

43

σb ∗ h f ∗ τa. Suppose we have a natural transformation τ : f → h, then τ · 1f and 1h · τ are the same as
τ. To prove associativity; show ρ · (σ · τ) and (ρ · σ) · τ are the same function. Applying ρ · (σ · τ) to x,
x
x
x
x
x
x

;
;
;
;
;
;

[ρ · (σ · τ)]x, ρ · (σ · τ)
ρx ∗ (σ · τ)x, ρ · (σ · τ)
ρx ∗ (σx ∗ τx), ρ · (σ · τ)
(ρx ∗ σx) ∗ τx, ρ · (σ · τ)
(ρ · σ)x ∗ τx, ρ · (σ · τ)
[(ρ · σ) · τ]x, ρ · (σ · τ)

~ Let τ, α : f, g → h, i be natural transformations for
Now we study the category of all categories, Cat.
the functors f, h : C → D and g, i : D → E. If we apply τ to x, the reuslt is τx : fx → hx. If we apply α
to fx, we get αfx : g(fx) → i(fx). In the same way, αhx : g(hx) → i(hx). We define α ◦ τ : g ◦ f → i ◦ h, a
natural transformation such that
(α ◦ τ)x := α(hx) ∗ g(τx).
(II.2)
We can equivalently say (α ◦ τ)x := i(τx) ∗ α(fx) because α(hx), α(fx); i(τx), g(τx). To prove (α ◦ τ) is in
Nat(g ◦ f, i ◦ h), we must prove (α ◦ τ)b, (α ◦ τ)a; (i ◦ h) f, (g ◦ f) f for any f : a → b, in C. Recall that for
every arrow h f : ha → hb in D, we have α(hb), α(ha); i(h f ), g(h f ) because α is in Nat(g, i).
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b
(α ◦ τ)b, (α ◦ τ)a

;
;
;
;
;
;
;
;

(α ◦ τ)b ∗ (g ◦ f) f, (g ◦ f) f
α(hb) ∗ g(τb) ∗ gf f, (g ◦ f) f
α(hb) ∗ g(τb ∗ f f ), (g ◦ f) f
α(hb) ∗ g(h f ∗ τa), (g ◦ f) f
α(hb) ∗ g(h f ) ∗ gτa, (g ◦ f) f
i(h f ) ∗ α(ha) ∗ gτa, (g ◦ f) f
(i ◦ h) f ∗ (α ◦ τ)a, (g ◦ f) f
(i ◦ h) f, (g ◦ f) f.

To prove associativity, let µ : l → m, where l, m : E → F . This implies µ ◦ α : l ◦ g → m ◦ i such that
(µ ◦ α)hx := µi(hx) ∗ lα(hx). Thus,
x
x
x
x
x
x

;
;
;
;
;
;

[µ ◦ (α ◦ τ)]x, µ ◦ (α ◦ τ)
µ(i ◦ h)x ∗ l(α ◦ τ)x, µ ◦ (α ◦ τ)
µi(hx) ∗ l(αhx ∗ gτx), µ ◦ (α ◦ τ)
µi(hx) ∗ lα(hx) ∗ (l ◦ g)τx, µ ◦ (α ◦ τ)
(µ ◦ α)hx ∗ (l ◦ g)τx, µ ◦ (α ◦ τ)
[(µ ◦ α) ◦ τ]x, µ ◦ (α ◦ τ).

Lemma. Let α, β : g, i → i, k be natual transformations of functors g, i, k : D → E. In terms of the
~ we verify β · α; (β ◦ σ) · (α ◦ τ), σ · τ. Equivalently, if the notation is used
notation operation ◦ of Cat,
for ·, which is the operation in the categories Cat(C, D) and Cat(D, E), then β ◦ σ; (β · α) ◦ (σ · τ), α ◦ τ.

CHAPTER II. CATEGORY

44
Proof. Notice β · α : g → k, and σ · τ : f → j.
x
x
x
x
x
x
x
x

;
;
;
;
;
;
;
;

[(β · α) ◦ (σ · τ)]x, (β · α) ◦ (σ · τ)
(β · α)(jx) ∗ g[(σ · τ)x], (β · α) ◦ (σ · τ)
[β(jx) ∗ α(jx)] ∗ g(σx ∗ τx), (β · α) ◦ (σ · τ)
β(jx) ∗ [α(jx) ∗ g(σx)] ∗ g(τx), (β · α) ◦ (σ · τ)
β(jx) ∗ [i(σx) ∗ α(hx)] ∗ g(τx), (β · α) ◦ (σ · τ)
[β(jx) ∗ i(σx)] ∗ [α(hx) ∗ g(τx)], (β · α) ◦ (σ · τ)
(β ◦ σ)x ∗ (α ◦ τ)x, (β · α) ◦ (σ · τ)
[(β ◦ σ) · (α ◦ τ)]x, (β · α) ◦ (σ · τ).

Theorem 5.21. Given categories C, D, E, there is a functor F : Cat(C, D) × Cat(D, E) → Cat(C, E)
such that FO (f →× g) := g ◦ f and FA (τ →× α) := α ◦ τ.
Proof. We will need to prove, first of all, that the unit natural transformation, 1g◦f , is the same as 1g ◦ 1f .
To see that this is true, note (II.2) implies x; 1g (fx) ∗ g(1f x ), 1g ◦ 1f so that for any c-object x in C
x
x
x
x
x
x

;
;
;
;
;
;

1g◦f x, 1g◦f
1(g◦f)x , 1g◦f
1(g◦f)x ∗ 1(g◦f)x , 1g◦f
1g(f x) ∗ g1fx , 1g◦f
1g (fx) ∗ g1fx , 1g◦f
(1g ◦ 1f )x, 1g◦f .

We know (1Cat(C,E) ◦ FO )(f →× g), results in 1g◦f . On the other hand, (FA ◦ 1C )(f →× g) is 1f ◦ 1g , where
we use C := Cat(C, D) × Cat(D, E).
Let τ : f → h and α : g → i, which means τ →× α : f →× g −→ h →× i. The image of the arrow in
the domain category is α ◦ τ : g ◦ f → i ◦ h.
The proof that F satisfies 3) is given by the lemma:
(σ →×
(σ →×
(σ →×
(σ →×
(σ →×

β) · (τ →×
β) · (τ →×
β) · (τ →×
β) · (τ →×
β) · (τ →×

α)
α)
α)
α)
α)

;
;
;
;
;

F[(σ →× β) · (τ →× α)], F
F[σ · τ →× β · α], F
(β · α) ◦ (σ · τ), F
(β ◦ σ) · (α ◦ τ), F
F(σ →× β) · F(τ →× α), F.

The functor is an object function FO : O|Cat(C, D) × O|Cat(D, E) → O|Cat(C, E) and an arrow
function given by FA : A|Cat(C, D) × A|Cat(D, E) → A|Cat(C, E). These functions give operations.
The operation for functors is FO : O|Cat(C, D) → {O|Cat(D, E) f O|Cat(C, E)}, and the operation for
natural transformations is FA : A|Cat(C, D) → {A|Cat(D, E) f A|Cat(C, E)}.

6. INTEGER SYSTEMS

45

§6 Integer Systems
We have proven the existence of a discrete number system, but there are many such systems. For any
discrete number system Z, consider the system obtained by adding transitive arrows. We conserve
the property of having non-discernible arrows; add only one arrow for every pair a → b and b → c.
We denote such a system with Z< . If we add one reflexive arrow to every c-object of Z< , the system
obtained is denoted by Z≤ . This new system is a partial order, in which we consider the arrows in the
natural order, of axiom 3. When considering a partial order, we may write a < b to make it clear a and
b are not the same object.
Now that there is a partial order, associated to any discrete number system Z, we can consider
functors Z≤ → Z≤ . We have the identity functor, which we assign to the object 0, by +0 := IZ≤ .
But, there is another functor to consider. We call it the functor sum 1, denoted +1 : Z≤ → Z≤ . To
prove that we have a functor, we will give an order preserving function, and then we define +1 as the
functor associated to said function. It is not necessary to look far for our function, the arrows of Z
form a bijective function. These arrows form a function, with Z in the domain, because every object
is source of one arrow only. Since every object of Z is target of exactly one arrow, we can say that the
object function of +1, is bijective. Take a < b in Z≤ , then we also have a + 1 ≤ b. Since we also have
b < b + 1, it turns out a + 1 < b + 1.
Proposition 6.1. The arrows of a discrete number system Z, are the components of an order bijectivity
for the objects of Z≤ . The corresponding functor, +1, is an automorphism of the partial order Z≤ .
Compose this automorphism with itself to form a new automorphism, and call it sum 2. For any
x + 1 of the partial order Z≤ , such that 0 < x + 1, we give the automorphism +(x + 1) := +1 ◦ +x. Since
we have given a functor +x, the object function is order preserving and the corresponding functor is
precisely +x. We will prove that these functors are related as in proposition 5.20.
Lemma I. If x, x + 1 are two comparable objects, in a discrete number system, and 0 < x + 1, then the
functors satisfy +x < +(x + 1).
Proof. In terms of the order preserving functions, we have a + x < (a + x) + 1 = a + (x + 1) for any a
in Z≤ . This is the same as saying +xO  +(x + 1)O .
Since +1 is an automorphism, we have the inverse automorphism +(−1) : Z≤ → Z≤ . This is the
functor minus 1. If x < 0, we define +(x − 1) := +(−1) ◦ +x, and +(−1) := +1−1 . The reader may verify
that, in general, +(−x) is the inverse of +x. Here, we give the second part of the last result.
Lemma II. For comparable objects x, x − 1 with x − 1 < 0, the functors satisfy +(x − 1) < +x.
Proof. Note that a + (x − 1) = (a + x) − 1 < a + x.
Theorem 6.2. If Z is a discrete number system, then there is an isomorphism ⊕ : Z≤ → {+x}≤ , where
{+x}≤ is the partial order on automorphisms +x. Given any two a ≤ b, in Z≤ , there is a natural
transformation +a → +b.
Proof. The lemmas give a discrete number system, · · · < +(−2) < +(−1) < +0 < +1 < +2 < · · · . The
object function of ⊕ is bijective; we have defined it to be onto, and we need to show it is monic. We
verify this last, because any two functors +a, +b are different.

CHAPTER II. CATEGORY

46

The arrow function is also bijective because partial orders consist of none discernible orders. All
we need to do is assign arrows amongst respective objects.
Finally, if a ≤ b, we know +a ≤ +b. From the corollary of proposition 5.19, we have a natural
transformation of the form +a → +b.
The following lemma will be extremely useful in proving our next theorem, where we wish to show
the functors in the image of ⊕, commute under composition.
Lemma. Let f, g : O → O be bijective functions that commute. Then f −1 , g also commute.
Proof.
g
g
g
g
g
g
g, g

;
;
;
;
;
;
;

g ◦ f −1 , f −1
( f −1 ◦ f ) ◦ (g ◦ f −1 ), f −1
f −1 ◦ ( f ◦ g) ◦ f −1 , f −1
f −1 ◦ (g ◦ f ) ◦ f −1 , f −1
( f −1 ◦ g) ◦ ( f ◦ f −1 ), f −1
f −1 ◦ g, f −1
f −1 , f −1

Theorem 6.3. Let Z be a discrete number system. The object function, of the isomorphism ⊕, defines
a full operation + : O|Z → {O|Z fiso O|Z}.
1) The functors of {+x}≤ form a commutative group, under composition; we represent it with Z† .
2) Using +, we construct a commutative group Z, on the objects of the discrete number system.
3) There is an isomorphism Z → Z† .
Proof. The object function ⊕O sends x into the automorphism +x, for Z≤ . The object function of +x is
+xO , we may also write it as +x. Thus, every object in Z≤ is assigned a function +xO : O|Z≤ → O|Z≤ .
The fact we are sending every x into an automorphism, implies the operation is full. The operation can
be expressed as + : O|Z → O|Z f O|Z because the objects of Z and Z≤ are the same.
1) We know that the collection of automorphisms is a group. Since +0 is the identity, we only need
to notice the functors of {+x}≤ have inverse also in {+x}≤ . Therefore, the functors +x form a
group, under ◦.
Now we would like to see the group is commutative. We wish to prove +x ◦ +y and +y ◦ +x are
the same function, whoever x, y of Z may be. If 0 ≤ x, then +1 ◦ +x is the same as +x ◦ +1
because +x is compositions of +1; using the lemma, one can prove +(−x) ◦ +1 and +1 ◦ +(−x)
are the same. This proves +1 commutes with all. Now, suppose +y commutes with all; we will

6. INTEGER SYSTEMS

47

prove +(y + 1) commutes with all other functors of the group.
+ (y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)

;
;
;
;
;
;
;
;

+(y + 1) ◦ +x, +x
(+1 ◦ +y) ◦ +x, +x
+1 ◦ (+y ◦ +x), +x
+1 ◦ (+x ◦ +y), +x
(+1 ◦ +x) ◦ +y, +x
(+x ◦ +1) ◦ +y, +x
+x ◦ (+1 ◦ +y), +x
+x ◦ +(y + 1), +x.

One can equally show +(y − 1) commutes with all +x, given +y commutes with all.
2) We know the unit exists because +0 is identity. It will be useful to see how other objects act on 0.
We know 0 + 1 is the target in the arrow 0 → 1. Suppose 0 + x is x, then we also have 0 + (x + 1)
is x + 1. The same is true for x − 1, so that 0; x, x for every x.
Also, we see that every x has an inverse. Since +(−x) := +x−1 is true, we can conclude the inverse
of x, is −x because
x
x
x
x
x

;
;
;
;
;

x + (−x), −x
(0 + x) + x−1 , −x
(0 + x) + x−1 , −x
(+x−1 ◦ +x)0, −x
0, −x

Commutativity of two objects x, y follows from commutativity of their functors:
x
x
x
x
x
x, x

;
;
;
;
;
;

x + y, y
(0 + x) + y
(+y ◦ +x)0, y
(+x ◦ +y)0, y
y + x, y
y, y.

Associativity is proven using commutativty of the operation and commutativity of the functors.
To prove the operation is associative we will prove x+ and +y commute. We use the fact +x and
+y commute and that the operation itself commutes, which means left and right operations are
the same functions.
+ x, +x ; +y, +y
x+, x+ ; +y, +y.
Up to this point we have proven that there is an commutative operation that satisfies the properties
of group. However, we still need to build a group which consists of one c-object and objects of

CHAPTER II. CATEGORY

48

operation on it. We may consider the objects of a discrete number system as automorphisms on
a category that is sufficiently large. We mean sufficiently large in the sense that we can make
a category as large as we want to give as many automorphisms (arrows) as can be needed. We
know that this is true for the group of ordered automorphisms Z† . So, for any discrete array of
numbers, we say each is an automorphism of a suitable category. This category is the c-object of
the group, and we will give it the symbol Z† . Our group Z is defined as the algebraic category
with Z† as object of the automorphisms, which are the objects of the discrete number system Z.
We are defining A|Z := O|Z≤ . The operation of Z is the one defined by the functors of Z† , which
are the inverses and compositions of the functor determined by the arrows of Z.
3) Lastly, consider the algebraic functor i : Z → Z† such that iO Z† := Z≤ , and iA x := +x for every
automorphism x : Z† → Z† . To show this is indeed a functor, we must prove the third condition
of functors. That would be to verify i(x + y) is the same object of operation as ix ◦ iy. In other
words, one must prove i(x + y) := +(x + y) and ix ◦ iy := +x ◦ +y. Start with associativity and
apply commutativity to prove this:
a, x ; a + y, y + x
a, x ; a + y, x + y.

Every discrete number system generates a group of functors, that determine the objects of the discrete number system as a group; both groups involved will be isomorphic. At the same time, the discrete
number system is a group of automorphisms of another category. Thus, automorphisms of the kind generated by discrete number systems, follow the pattern of a discrete number system. Every object is in
the same position; every object has one arrow into it and one arrow from.
a
For practical purposes,
or a c will express a ≤ c. We have freedom to write a b c · · · or its
c
vertical counterpart, in order to express all the possible relations a ≤ b, a ≤ c, b ≤ c, . . . . The question,
now, is how we got from ≤ to this +. This is basically an explanation of (II.3), below. We generalize
the system of integers, in the following manner. Begin with one row, which represents Z≤ , and to each
object of that row assign a function. The function +x, represented by the columns of 0 and x, consists
of the arrows from the column 0 into the column x. One object is chosen, 0, for which the arrows of its
function are all reflexive; the identity function. The functions +x, all preserve the natural order of Z≤ ;
every column is Z≤ . The functions are order bijectivities and since the functors are ordered, natural
transformations define a partial order for them. If 0 ≤ x, the natural transformation +0 −→τ +x is the
function that assigns to each object a of Z≤ , the arrow a → a + x, so a →τ τa : a ≤ a + x.
The fact that our bridge is a natural transformation, means τb, τa; +x(a ≤ b), +0(a ≤ b). This can
otherwise be written as b ≤ b + x, a ≤ a + x; a + x ≤ b + x, a ≤ b. This last is equivalent to saying
b ≤ b + x ◦ a ≤ b is the same composition as a + x ≤ b + x ◦ a ≤ a + x; both are a ≤ b + x.
The grid of objects (II.3) is a representation of the constructions we have carried out. We can see
it as a collection of arrows for the objects of Z≤ . In this case, we are providing no new information,
to what is given by a discrete number system. We can also, and more meaningfully, interpret this as
comparability of relations.

7. RATIONAL SYSTEMS

49

···
···
···
···
···
···

..
.
−5
−4
−3
−2
−1
0
..
.

..
..
..
.. ..
.
.
.
. .
−4 −3 −2 −1 0 · · ·
−3 −2 −1 0 1 · · ·
−2 −1 0 1 2 · · ·
.
−1 0 1 2 3 · · ·
0 1 2 3 4 ···
1 2 3 4 5 ···
..
..
..
.. ..
.
.
.
. .

(II.3)

a b
. This would of course
c d
be expressed as a, c; b, d. We have chosen this definition of comparability for good reason. Suppose 0
is one of the four objects, and you have a rectangle of the form:
x 0
n x
a n
0 a
.
4)
3)
2)
1)
n a
a 0
0 x
x n
This means we have applied the functor +a to 0, and x. After applying +a to 0, we naturally get a. If
we apply +a, to x, the result is n. In terms of the notation for +, we can assert 0, x; a, n. The operation
is defined by a →+x n if 1) or 3) occur. If, on the contrary, we have the occurence of 2), the rectangle
in which a, x occur will be unique. The same is true for 4). One can see this is true in general; we need
a b
not take 0 as a corner. Given any rectangle
, we have a, c; b, d in terms of the operation as well
c d
as the comparability of arrows. Although, we must be careful in using the notation , ; , for the following
reason. When representing comparability for the order relation, or the operation, a, c; b, d and a, b; c, d
a
means the same thing as a c. However, changing
mean the same thing, because we have said that
c
a, c; b, d for b, d; a, c is only valid if the notation is used in representation of the operation. This is due
to anti-symmetry of the order. Defining the operation in terms of comparability, with arrows that have
a 0, assures the operation is an ordered triple; we are eliminating one component, by fixing 0.
We say a ≤ c and b ≤ d are comparable if they appear in a rectangle:

§7 Rational Systems
7.1 Product
A new operation is defined, in terms of the sum, for the objects of Z. For x ≥ 0 we define the product as
the operation · given by a; (a · x) + a, x + 1. This is to say ·(x + 1)a := (+a ◦ ·x)a. It is in our best interest
to define the operation in such a way that x · 1 means we add x once. Said differently, we want x; x, 1.
To achieve this, we define x; 0, 0. If we have 0; 0, x, we also have 0; 0, x + 1. Similarly, 1; x + 1, x + 1 if
1; x, x. From this point on, we will use the notation a − x to express a + (−x). The product for x ≤ 0,
is defined by a; (a · x) − a, x − 1. It is immediate, from this definition, that x; −x, −1. Again, we have
0; 0, x − 1 and −1; −(x − 1), x − 1 given 0; 0, x and −1; −x, x. We thus have, for every integer a,
a; 0, 0

0; 0, a

1; a, a

a; a, 1.

Theorem 7.1. The product is a full operation · : Z → {·x}, where {·x} is a collection of functions ·x.
Every ·x determines a functor ·x on Z. Furthemore, the operation is commutative and associative.

CHAPTER II. CATEGORY

50

Proof. To prove ·x is a functor suppose, for x ≥ 0, that a + b; (a · x) + (b · x), x.
a+b
a+b
a+b
a+b

(a + b) · x + (a + b), x + 1
[(a · x) + (b · x)] + (a + b), x + 1
[(a · x) + a] + [(b · x) + b], x + 1
a · (x + 1) + b · (x + 1), x + 1.

;
;
;
;

This implies ·x is a functor from Z to itself. It is not, however, an automorphism. It is not difficult to
see under what condidtions it is monic.
We know 0 commutes with any integer, so now we wish to know if the same is true for x + 1, given
that x commutes with any integer. Using the last result we find
a+1
a+1
a+1
a+1
a+1
a+1
a+1
a + 1, a + 1

;
;
;
;
;
;
;
;

(a + 1) · x + (a + 1), x + 1
[(a · x) + x] + (a + 1), x + 1
[((a · x) + x) + a] + 1, x + 1
[((a · x) + a) + x] + 1, x + 1
[(a · x) + a] + (x + 1), x + 1
[(x · a) + a] + (x + 1), x + 1
(x + 1) · (a + 1), x + 1
x + 1, x + 1

Of course we can prove that x; x·a+x·b, a+b because of commutativity. We now turn to associativity
for the product. If a, b; a · x, x · b then,
a
a
a
a
a
a, b

;
;
;
;
;
;

a · [(x + 1) · b], (x + 1) · b
a · [(x · b) + b], (x + 1) · b
a · (x · b) + a · b, (x + 1) · b
(a · x) · b + a · b, (x + 1) · b
[(a · x) + a] · b, (x + 1) · b
a · (x + 1), (x + 1) · b

Similar proofs hold for x ≤ 0. That is, we are able to prove that if the properties hold for x, they
also hold for x − 1.

7.2 Dual Orders
The main concept of a ratio is that of comparing two relations. Therefore, we will take a more general
view, by defining an order on arrows of Z × Z. We will carry out a construction of two ordered systems,
seperately, and then we will combine them. This process will be iterated three times; until we have
a satisfactory system. At which point in time we will close out the construction by defining the two
resulting systems as the same.
We build a new system by taking away, from Z, all the objects x < 0, and relations of such objects.
This new system is N0 . If we take away the object of operation 0 from N0 , we are left with the system N.
The notation used here is a convenience in representation of arrows of the cartesian products; a →× c

7. RATIONAL SYSTEMS

51

is ac . An order will be defined for the c-objects of N × N; make ac ≤ bc if a ≤ b. The order with respect
to the target objects is a bit different. We say d ≤ c if and only if ac ≤ ad . The first order is represented
by N† := N × {c}. The second is N† := {a} →× N, for any 0 < a, c.

Proposition 7.2. The orders N† and N† are dual; explicitly N† , (N† )op ; (N† )op , N†. Therefore, there is a
contravariant isomorphism N† → N† .

Proof. If we hold the target fixed, then there is an order bijectivity to N. In the case we hold fixed the
source, the resulting order is dual to N.
We will give the contravariant functor, to be more precise, and better understand the situation. Let
N† := N×{c} and N† := {a}×N. Then we make the object function cx 7→ ax . For arrows, cx ≤ cy 7→ ay ≤ ax .

In a similar manner, we form the system −N0 , where we now take away the objects x > 0 and
relations of every x > 0. Notice that the systems N† are order bijective with −N. What we want then, is
to define a partial order −N × N
is dual to N × N. Consider a functor d : −N × N → N × N. The
 which

−a
a
object function is defined as d c := c . So, we define the arrow function d( −a
≤ −b
) := db ≤ ac . This
c
d
defines a partial order that is dual to the order of N × N because we have defined the order in terms of a
contravariant functor.

−∞ → · · ·

−4
1

→

↓
−∞ → · · ·

−4
2

−3
1

→

↓
→

−3
2

−2
1

→

↓
→

−2
2

−1
1

→

↓
→

−1
2

0
1

→

l
→

0
2

1
1

→

↑
→

1
2

2
1

→

↑
→

2
2

3
1

→

↑
→

3
2

4
1

··· → ∞

↑
→

4
2

··· → ∞
(II.4)
.

↓
−∞ → · · ·

−4
3

..
.

↓
→

−3
3

..
.

↓
→

−2
3

..
.

↓
→

−1
3

..
.

l
→

0
3

..
.

↑
→

1
3

..
.

↑
→

2
3

..
.

↑
→

3
3

..
.

↑
→

4
3

··· → ∞

..
.

We combine the two systems already formed, into one system, represented above. We give a partial
< 0 and 0 < ac , for every 0 < a, c.
order Q† , with O|Q† := O|Z × N. We do this in such a manner that −a
c
To achieve this, we define 0x := 0, for every x in N. Said differently, any order Z × {x} is a partial order
generated by a discrete number system, for 0 < x.

CHAPTER II. CATEGORY

52

−∞ ↔ · · ·

−4
0

↔

↓
−∞ → · · ·

−4
1

−4
2

→

−4
3

→

∞ ← ···

−4
4

→

→

→

−2
2

−2
3

→

−2
4

−1
1

→

−1
2

→

−1
3

→

−1
4

→

0
2

→

0
3

→

0
4

→

1
2

→

1
3

→

1
4

2
1

2
2

→

2
3

→

2
4

↔

3
1

→

3
2

→

3
3

→

3
4

4
1

4
2

→

4
3

→

4
4

..
.

..
.

..
.

..
.

..
.

↓

↓

↓

↓

l

↑

↑

↑

↑

0

0

0

0

0

0

0

0

0

↓

↓

↓

↓

l

↑

↑

↑

↑

..
.

..
.

..
.

..
.

..
.

..
.

..
.

..
.

..
.

←

−4
−3

−4
−2

−4
−1

4
0

−3
−4

←

↓
←

−3
−3

−3
−2

←

−3
−1

←

3
0

←

−2
−2

←

−2
−1

←

2
0

−1
−3

−1
−2

←

↔

−1
−1

0
−4

←

l
←

0
−3

←

0
−2

←

0
−1

←

1
−3

←

1
−2

←

1
−1

↓

↑

1
0

−1
0

←

2
−3

←

2
−2

←

2
−1

←

−2
0

3
−3

3
−2

←

3
−1

←

−3
0

··· →

∞

··· →

∞

··· →

∞

4
−4

(II.5)
.

· · · ← −∞

4
−3

· · · ← −∞

↑
←

4
−2

· · · ← −∞

↑
←

↑
↔

∞

↑

↑

↑
↔

←

↑

↑
←

3
−4

↑

↑

↑
←

2
−4

↑

↑

l
←

1
−4

↑

l

↓

↓
↔

←

↓

↓

↓
↔

−2
−3

−1
−4

↓

↓

↓
←

←

↓

↓
←

−2
−4

··· →

↑

..
.

−4
−4

∞

↑

↑
→

··· ↔

↑

↑
→

4
0

↑

↑

↑
→

3
0

↑

↑

↑
→

↔

↑

↑

l
→

1
1

2
0

↑

↑

l

↓
→

0
1

l

↓

↓
→

↑

↓

↓
→

↓

↔

..
.

↓
∞ ↔ ···

−3
4

→

1
0

..
.

↓
∞ ← ···

−3
3

−2
1

−1
0

..
.

↓
∞ ← ···

−3
2

↔

↓

↓

↓
∞ ← ···

→

↓

↓
−∞ → · · ·

−3
1

−2
0

↓

↓

↓
−∞ → · · ·

↔

↓

↓
−∞ → · · ·

−3
0

4
−1

· · · ← −∞

↑
↔

−4
0

· · · ↔ −∞

7. RATIONAL SYSTEMS

53

An extended rational system is any collection of objects such that the order between them is given
by (II.5). The objects that are connected to ∞, or −∞, by double arrows, will all be denoted by ∞, or
−∞. If the collection of objects does not include the objects ∞, −∞, then the system is simply rational.
We will call the objects of such systems, rationals. Our objects −∞, +∞ are comparable in the order
but not so much in the operations. The object 00 is not comparable even in the order; the reader may
closely study (II.5) to see that there is no convenient definition.

7.3 Involution
The bottom part of the system (II.5) is Q† , and Q†O := O|Z × −N. There is an order bijectivity Q† → Q† .
We shall prove that they are also dual orders. This means that (II.5) is the combination of two dual
systems that are actually the same system. Thus, in this case we can consider the simplified version
(II.4), or its dual, because it is self dual.
Consider the bijective function q : Q† → Q† that sends ac 7→q −a
. The function p has the same
−c
x
x
domain and and image, but c 7→ p −c . Also, r1 , r2 : N0 × N, N0 × −N → −N0 × N, −N0 × −N such that
for any integer x, we have ax 7→r −a
.
x
Proposition 7.3. The function q is a two part function

q|N0 ×N = r2 ◦ p|N0 ×N = p|−N0 ×N ◦ r1
q|−N0 ×N = r2−1 ◦ p|−N0 ×N = p|N0 ×N ◦ r1−1 .
In the following proposition we are saying that p establishes an order bijectivity Q† , (Q† )op ; (Q† )op , Q†.
On the other hand, q establishes an order bijectivity Q† , Q† ; (Q† )op , (Q† )op .
Proposition 7.4. q : Q† → Q† is an order bijectivity. What is more, both systems are dual orders if we
consider the function p.
We can say, more concisely, that p is a bijective function from one collection onto itself, with the
interesting characteristic that its action on a rational number, with respect to the order, is that of taking
opposite order. Given our equivalence relation, we see that p and r are the same function −, that gives
the inverse under +. The interesting thing to notice is that if we reverse the arrows two times, we have
the same order; that is to say, the opposite, of the opposite order, is the original order. This is why
we have an order bijectivity q, after applying the function − two times (once with the function p and
once with the function r). This is a special case of something more general. An involution is a function
f : O → O such that f x; x, f which means f ( f x) is x. We will encounter many kinds of involutions.

7.4 Product for Rational Systems
Presently, we will define a relation for determining when we will regard two arrows of Z × Z as the
same. This of course is given in terms of the product for integers. The arrows a →× c and b →× d
are = comparable if a, c; b, d in terms of the product; we will say a →× c = b →× d. This has an
important meaning in terms of the notation: a, c; b, d is used for stating 1) a · d and b · c result in the
same object of operation, and 2) ac = db . First, we observe that a, c; a, c, is obtained from a, a; c, c by
using commutativity. Second, we see that a, c; b, d can be re-written as b, d; a, c. We will later see that

CHAPTER II. CATEGORY

54

transitivity holds, because in terms of the operation we have a, c; b, d and b, d; e, f which we will prove
a
= −c
. This is proven by the rules for product:
implies a, c; e, f . Some arrows in the equivalence are −a
c
−a
−a
−a
−a
−a
−a, c

;
;
;
;
;
;

(−a) · (−c), −c
[(−1) · a] · [(−1) · c], −c
[(−1 · a) · −1] · c, −c
[a · (−1 · −1)] · c, −c
a · c, −c
a, −c.

We turn to define the product for the objects of the dual systems in (II.4); notice we are excluding
, b . We first have to find the unit for this
objects of the form 0x . We define the operation by ac ; a·b
c·d d
1
a
operation. It is not difficult to verify 1 is unit. We see 0; 0, b and ab ; 0, 0.
Application of associativity, commutativity for integers, and the relation of equality defined above,
allow us to prove ac ; ac , xx . Proofs for associativity and commutativity are a direct application of the
defintion of product for rationals. So now, we turn to find inverse, under the product. We readily verify
that the inverse of ab is ab .
There is one more thing we wish to prove in this section. That is, if we multiply ab by any two
rationals that are the same with respect to =, then the results are the same. That is, given dc = yx , we
have to verify (a · c) · (b · y) and (a · x) · (b · d) are the same object. These expressions are rewritten as
(a · b) · (c · y) and (a · b) · (x · d) which are both the same, since c · y and x · d are the same object. Also,
a·c
= a·x
, then dc = yx . Let us now return to the matter of transitivty for the relation = defined above.
if b·d
b·y
This means we have the equalities ac = db and db = ef , and we wish to prove ac = ef . The equalities give
a
· f = db · f = ef · f = e.
c
Theorem 7.5. The system Q, with rational numbers as objects of operation, is a commutative group
under the product. As with the sum, the product is also a functor; in this case · : Q → QFQ.
Proof. The condition ·, ·; ◦(·y), ·y is the statement that ·(x · y) is the same function as ·x ◦ ·y. Again, this is
proven by applying commutativity once to the expression a, x; a · y, y · x, of associativity for the product.
The result is a, x; a · y, x · y.

7.5 Sum for Rational Systems
Now, given that arrows of the form
rationals is defined in the last step

a
0

are not rationals, we do not define the sum for these. The sum for
a
c
a
c
a
c
a
c
a
c

;
;
;
;
;

a b b
+ ,
c d d
a d b c b
· + · ,
c d d c d
a·d b·c b
+
,
c·d d·c d
a·d b·c b
+
,
c·d c·d d
a·d+b·c b
, .
c·d
d

7. RATIONAL SYSTEMS

55

Once we multiply by cc and dd , the rest is straightforward. But why did we choose to multiply by that,
and not by aa and bb ? Because we have guarantee that c, d are both not 0. To prove commutativity and
associativity for this operation, we proceed as follows, first with commutativity:
a·d+b·c b
,
c·d
d
b·c+a·d b
;
,
d·c
d
b a b
;
+ ,
d c d
b b
;
, .
d d

a
c
a
c
a
c
a a
,
c c

;

For associativity,
a
c
a
c
a
c
a
c
a
c
a
c
a
c
a b
,
c d

;
;
;
;
;
;
;
;

a x·d+b·y x b
+
, +
c
y·d
y d
a · (y · d) + (x · d + b · y) · c x b
, +
c · (y · d)
y d
a · (y · d) + [(x · d) · c + (b · y) · c] x b
, +
c · (d · y)
y d
b · (y · c) + [(x · c) · d + (a · y) · d] x b
, +
d · (y · c)
y d
!
b
x a x b
+
+ , +
d
y c y d
!
b
a x x b
+
+ , +
d
c y y d
!
b x b
a x
+ , +
+
c y
d y d
a x x b
+ , + .
c y y d

As before, the object 0 which absorbs with product, serves as unit for sum. This is verified by
a
c
a
c
a
c
a
c
a
c

;
;
;
;
;

a 0 0
+ ,
c x x
a·x+0·c 0
,
c·x
x
a·x 0
,
c·x x
a x 0
· ,
c x x
a 0
, .
c x

In light of the fact that we consider 0x to be the same element for all x, we represent each such rational
by 0, and we verify that objects dual with respect to the unit 0, are objects ab and −a
. Of course, our
b
a
−a
a
dual. In the same manner, −a
is
dual
with
and
.
equivalence relation makes ba and −b
−b
b
−b

CHAPTER II. CATEGORY

56

7.6 Embedding
Define a bijective function ι : Z → Z×{1} such that x 7→ 1x . It is not difficult to prove ι is an isomorphism
for the operations sum and product. We follow the definition of sum to prove 1x + 1y is x+y
. This is also
1
x·y
x y
true for the product because 1 · 1 and 1 are the same.
b·c
b·c
The order for objects of operation, in Q, is defined by ac ≤ db if and only if a·d
≤ d·c
= c·d
. This
c·d
means that a · d ≤ b · c if and only if we have c · d > 0, and b · c ≤ a · d if and only if c · d < 0.
In this case, ι is a functor for Z≤ as a partial order and not an algebraic category. Additionally,
we will prove that the system Q is a natural order. We know exactly one arrow is assigned to any two
objects of Q; this is given from the definition. We must prove transitivity for the order of Q.
Proposition 7.6.

a
c

≤

b
d

⇐⇒

ax
cx

≤

b
d

b·c
≤ d·c
; this is the definition of the order in Q≤ . Then, c · d < 0 if
Proof. We have ac ≤ db if and only if a·d
c·d
and only if b · c ≤ a · d.
First, we take x > 0 which means (c · x) · d = d · (c · x) = (c · d) · x < 0. Since b · c ≤ a · d we also
b·(c·x)
have (b · c) · x ≤ (a · d) · x which is the same as b · (c · x) ≤ (a · x) · d. We conlude that (a·x)·d
≤ d·(c·x)
.
(c·x)·d
Now we let x < 0 and we get 0 < (c · x) · d = d · (c · x) = (c · d) · x. Here, x reverses inequalities, so
that (a · x) · d ≤ b · (c · x). The conclusion is the same.
The reader can similarly treat the case for c · d > 0.

Proposition 7.7.
1) If

x
y

> 0, then

a
c

≤

b
d

⇐⇒

ax
cy

≤

bx
dy

2) If

x
y

< 0, then

a
c

≤

b
d

⇐⇒

bx
dy

≤

ax
cy

Proof. Suppose c · y, d · y < 0 which means 0 < (c · y) · (d · y) and 0 < c · d. If ac ≤ db we then have
a · d ≤ b · c. From 0 < yx we can easily see 0 < x · y. This means that (a · x) · (d · y) ≤ (b · x) · (c · y) and
we may conclude a·x
≤ b·x
.
c·y
d·y
Let us make 0 < d · y so that (c · y) · (d · y) < 0 and c · d < 0. Hence, (b · x) · (c · y) ≤ (a · x) · (d · y).
The conclusion is the same as before. The reader may follow a similar proof for 2).
Proposition 7.8. The order of Q is transitive.
b· f
b·c
Proof. Supposing ac ≤ db ≤ ef , we have a·d
≤ d·c
and d·
≤ e·d
. Let 0 < c · d and f · d < 0, then
c·d
f
f ·d
a · d ≤ b · c and e · d ≤ b · f . We also have c · f < 0. The inequality a · d ≤ b · c is the equivalent
(a · f ) · (d · f ) ≤ (b · f ) · (c · f ). The inequality e · d ≤ b · f is true if and only if (b · f ) · (c · f ) ≤ (e · d) · (c · f ).
We apply transitivity for Z≤ , and get (a · f ) · (d · f ) ≤ (e · d) · (c · f ) = (e · c) · (d · f ). This last expression
is the same as e · c ≤ a · f . Since c · f < 0 we conclude ac ≤ ef .
The remainding cases 1) c · d < 0, and f · d > 0, 2) 0 < c · d, f · d, 3) c · d, f · d < 0. Can be treated
in a similar manner.

Theorem 7.9. Q is a natural order and there is an embedding of Z into Q for +, ·, ≤.
We can say more about the order of the rationals. Because, we have already seen that the orders
of (III.2) are dual. Daulity appears in many forms in Q, but the real duality here is what we did at
the beginning by defining columns dually to rows at the beginning of the section Dual Orders. In the
right side of system (III.2), we have a system such that rows and columns are dual. The rows are order
isomorphic to N and the columns are dual to N.

III | Set Theory
In the foregoing, and to maintain the rigor of mathematics, we will use the ⇒ relation that is representative of implication. We will not use it in a rigorous sense as of yet; for now ⇒ is representative for i f .
We will say the collection of all objects is Obj. Consider the system Obj∈ whose collection of objects
is Obj; the relations of the system are x ∈ A if and only if A is a collection and x is an object of A. We
say x is element o f A; of course < will be used in the opposite manner in such cases x is not element of
A. Two collections A, B are related A ⊆ B if for every arrow x ∈ A, we also have x ∈ B. If the arrow ⊆
has been ruled out to be reflexive we will write A ⊂ B. In case we have A ⊆ B and B ⊆ A we will say
A = B; this is saying that the arrow between A, B is double ended and when that happens we regard the
two collections to be the same.
Any collection or object is said to be normal if it is not an elment of itself. First of all, we have
a case because the collection of all collections is an object in itself. Furthermore, any collection can
be turned into a normal collection; if O ∈ O we make the new collection O by taking away the object
O. Now consider the collection of normal objects, denote it by R. This collection is elusive in nature.
Suppose R ∈ R, then R < R. If R < R, then by definition, R ∈ R. We cannot establish if this collection
contains itself or not; both conclusions are simultaneously true and, therefore, simultaneously not true.
Let U be a normal subcollection of Obj that will be called the universe of sets. We will use V as
the collection which is obtained from U by adding one object: U. If two sets are related A ⊆ B, we
say A is a subset of B. If x ∈ X, for some set X ∈ X, we say X is a family. The union of a family is the
S
collection of objects that consists of objects that belong to any member of the family; we write X.
The collection of all subsets of A is PA.
Definition 8. The following poperties define U.
1) A|Z ⊆ U
2) x ∈ A ∈ U ⇒ x ∈ U
3) A ⊆ B ∈ U ⇒ A ∈ U
4) A, B ∈ U ⇒ A →× B ∈ U
5) A ∈ U ⇒ PA ∈ U
S
6) X ∈ U ⇒ X ∈ U

7) If a function f : A → B ⊆ U is onto and A ∈ U, then B ∈ U.
We ask 3) and 7) hold because we do not want sets to have too many objects; we want to keep them
small so as to distinguish them from arbitrary collections, which can be unimaginably large.
57

CHAPTER III. SET THEORY

58

Definition 9. A set is any object of U. A set function is any function f : A → B, where A, B ∈ U.
We see that the properties defining the universe allow us to find that any set function is an object in
the universe because f ⊆ A →× B. This allows us to define a category where the collection of objects
is U and the collection of arrows is the set of all set functions. This is the category of small sets and
it will be written as Set. A set A may be represented by the notation A = {x} x∈A . If, for example a set
consists of two objects, we then have A = {x, y} = {y, x}. A set that consists of one element is called a
singleton; if the element of the singleton is x, then the singleton is {x}.

§8 Set Operations
8.1 First Generation
S
Union Take A, B ∈ V. We will establish as an operation V → V f V. When we are considering
S
such a union, we will write A ∪ B in place of {A, B}.
Proposition 8.1. For any A, B, C ∈ V and X ⊆ Y ∈ V we verify
S
S
1)
X⊆ Y
2) A ∪ B = B ∪ A

3) A ∪ (B ∪ C) = (A ∪ B) ∪ C = A ∪ B ∪ C.
Notice that we have a special case for 1); namely that A ⊆

S

X, for every A ∈ X.

Difference The union has an inverse operation, just as the sum has. The function ∪B adds the
objects of B to A. Well, in view that systems are created by adding and taking objects, it is natural to
give a function −B that takes the objects of B from A. Of course, A − B ⊆ A.
It is easily verified that the difference is not symmetric, just as the operation − is not symmetric; we
recall that a − b and b − a are not the same. Also, the difference is not associative, just as (a − b) − c is
not the same as a − (b − c):
(A − B) − C = A − (B ∪ C)
A − (B − C) = (A − B) ∪ [A − (A − C)].
To reason this, let us examine the expression A − (A − C). It is the collection of objects obtained
by taking from A the objects of A − C ⊆ A. We are leaving only those objects that are in C. That is,
x ∈ A − (A − C) if and only if x is in A and C because A − C consists of all objects in A and not in C.

8.2 Second Generation
Intersection In set theory there will be an analogy between sum and product. The corresponding
operations to sum and product, here, are union and intersection.
A ∩ B = A − (A − B).
In general we say x ∈

T

X if and only if x ∈ A, for every A ∈ X.

8. SET OPERATIONS

59

Proposition 8.2. For any A, B, C ∈ V and X ⊆ Y ∈ V we verify
T
T
1)
Y⊆ X
2) A ∩ B = B ∩ A

3) A ∩ (B ∩ C) = (A ∩ B) ∩ C = A ∩ B ∩ C.
And we see that 1) gives for a special case;

T

X ⊆ A, for every A ∈ X.

Complement Now, we consider the function that is left operation U−. The image of A may be
represented by Ac .
Proposition 8.3. For any A ∈ V we have
1) A ∪ Ac = U
2) (Ac )c = A
We see that 2) takes the form A = U − (U − A) = U ∩ A

8.3 Properties
Unit We now study the units of these operations, starting with the union. Notice that A ∪ B = A if
and only if B ⊆ A. Since ∅ is a subset of any set, we have found the unit of the union operation to be ∅.
If we consider the intersection, we see that A ∩ B = A − (A − B) = A if and only if A ⊆ B. We need
not look any further to find the unit, U.
It is easily seen that A = A− B if and only if A ⊆ A− B and this is true if and only if ∅ = A−(A− B) =
A ∩ B. Thus, ∅ is a right unit for the difference. In the case of the left operation, we are unable to find a
unit; clearly there is no set B such that B − A = A.
Inverse It is now desireable to find the inverse set of A, for each of the operations. However, after
a quick inspection we see that this is impossible. For the union we must find B such that A ∪ B = ∅, and
for the intersection C must satisfy A ∩ C = U.
We will find a way around this, but the developments here will not give us an inverse set, in the strict
sense. We will say A and A−1 are inverse sets for the union if A ∪ A−1 = U. We say they are inverse sets
for intersection if A ∩ A−1 = ∅. We say that Ac is the exact inverse of A.
Other Representations We have an interesting consequence of our definition for the operations −
and ∩. Each of these operations takes away objects from the source and this is in such a way that

A = (A ∩ B) ∪ (A − B)
∅ = (A ∩ B) ∩ (A − B).
We have a similar decomposition for A ∪ B:

(III.1)

CHAPTER III. SET THEORY

60

A ∪ B = A ∪ (B − A)
∅ = A ∩ (B − A).

(III.2)

We also have
A−B =
=
=
=

A − (U − Bc )
(A − U) ∪ [A − (A − Bc )]
A − (A − Bc )
A ∩ Bc

(III.3)

We are stating that the functions −A, ∩Ac are the same, for any A ∈ U. Of course we can also say
A ∩ B = A − Bc
Distributions In the foregoing we will accept a notation that will allow us to express some general
relations for set operations:
[

X =

\

X =

[

A

\

A

A∈X

A∈X

Of course there is a natural distribution for the union and intersection; as we had mentioned, there
would be a clear parallelism with sum and product. However, the distribution here is both ways:
A∪

\

B =

[

B =

B∈X

A∩

\

(A ∪ B)

[

(A ∩ B)

(III.4)

B∈X

B∈X

B∈X

Now we give the distributions that involve the difference.
A−

[

B =

\

B =

B∈X

A−

\

(A − B)

[

(A − B)

(III.5)

B∈X

B∈X

B∈X

Naturally, the complement has a distribution rule, following that it is a special case of difference.
U−

[

B =

(U − B)

B∈X

\

\

B =

[

U−

(U − B)

B∈X

B∈X

B∈X

9. CATEGORIES

61

This is re-written as,


\
[ c
 A =
Ac
A∈X

(III.6)

A∈X



[
\ c
 A =
Ac

(III.7)

A∈X

A∈X

These last expressions are the laws of DeMorgan. The following relations are not difficult to prove.
[

A−

\

A−

A∈X

A∈X

[

B ⊆

[

(X − Y)

\

B ⊆

\

(X − Y).

B∈Y

B∈Y

§9 Categories
We have constructed the category of sets Set, and the main objective in this section is to give other
descriptions of sets in terms of categories. That is, any set can be viewed as either a collection category
or a partial order.

9.1 Collection Category
Unless it is otherwise specified, we define {{A}} := {{a}}a∈A, for any set A. We will build a category A
whose collection of c-objects is the family {{A}}. Consider a selection function for {{A}}; this function
must send every set {a} into the object a. We have exactly one selection function f and it is defined by
Dom f = {{A}}, Range f = A and {a} 7→ f a. This is clearly a category; the unit arrow of each object is
the only arrow corresponding to it.
Let A, B be two collection categories and suppose there is an operation ∗ on each of the collections.
We have a natural way of defining a functor F : A → B, given a function f : A → B such that
f, f ; ∗ f x, ∗x. When considering the collection category of a power set we will write PA.

9.2 Partial Order, Under Inclusion
Let us consider the partial order defined on collection V; we form a category Set⊆ where the objects
are ordered by inclusion. In other words, arrows are A ⊆ B. We see that we have a category because
A ⊆ A and if A ⊆ B ⊆ C, then A ⊆ C. Recall that in a partial order we are dealing with non-discernible
arrows. In light of this, associativity of the composition holds. We note that a partial order may have
objects which are not related; and in this order, that is the case. There are no arrows between {1} and
{2}, for example. Given a set A, we can identify it with a partial order, where the collection of objects
is PA; this order is a simplified version of Set⊆ , and we denote it by PA.

CHAPTER III. SET THEORY

62

9.3 Concrete Category
We had the idea that given a discrete number system, there is a category such that the objects of the
system are automorphisms of the category. After all, categories are quite large. So, we will consider
the universe of sets in order to formailze the concept of a category whose arrows are functions. A
category C is concrete if we can provide a faithful functor C : C → Set. We are sending the cobjects of the category into sets, while the arrows are sent into functions. Parallel arrows are sent into
different functions of the same form. There have been several instances in which we have used arrows
of categories as functions of one component. We have really been trying to represent the arrows as
functions to define an equality of compositions in terms of natural pair of functions. A particular case
was the second request in the definition of functors. What happens if the category is concrete?
We are giving a way of studying absract categories in terms of a well defined category. We had
previously said that some algebraic categories can be seen as consisting of a category as c-object, and
automorphisms of that category as arrows. For a concrete category, all the c-objects x, y, z, ... can be seen
as sets, and all the arrows can be seen as set functions, in such a way that the transformation is a functor.
This means we will not study a general abstract category with objects and arrows. We are going to study
a collection of domains and ranges and set functions. This is a concrete concept because sets are well
defined. The composition in set functions can be described as an operation ◦ : A|Set → A|Set f A|Set
such that f 7→◦ ◦ f , where g 7→◦ f g ◦ f .
Hom Set Recall {a → c} is the collection of arrows in C, such that a is source and c is target. Also,
we have defined {a →} and {→ c} as the collections of arrows from a, and arrows into c, respectively.
If {a → c} is a set, for every pair of c-objects in the category, we say C has all Hom sets.
Definition 10. Let x be any c-object of C, and define the contravariant functor R⋉x : C → Set, where
a 7→ {a → x}; every arrow f : a → c is sent into the set function ∗ f : {c → x} → {a → x}, of Hom sets.
Define the covariant functor Lx : C → Set such that a 7→ {x → a}, so that f is sent into a set function
f ∗ : {x → a} → {x → c}.
Lemma I. Let F : C1 × C2 → D be a functor. Then, every arrow f : a → c, in C1 , determines a natural
transfomation τ f : Fa → Fc that sends x 7→ F( f, 1 x ). The functors are of the form Fa , Fc : C2 → D.
A similar result can be formulated if C2 takes the place of C1 .
Proof. The functors of the natural transformation are defined by the object functions Fa x := F(a, x)
and Fc x := F(c, x). Let g be an arrow in C2 , then the arrow functions are Fa g := F(1a , g) and
Fc g := F(1c , g). We will show τy, τx; Fc g, Fa g for any arrow g : x → y in C2 .
τy
τy
τy
τy
τy
τy
τy, τx

;
;
;
;
;
;
;

τy ∗ Fa g, Fa g
F( f, 1y ) ∗ F(1a , g), Fa g
F( f ∗ 1a , 1y ∗ g), Fa g
F(1c ∗ f, g ∗ 1 x ), Fa g
F(1c , g) ∗ F( f, 1 x ), Fa g
Fc g ∗ τx, Fa g
Fc g, Fa g.

9. CATEGORIES

63

Lemma II. Let C1 , C2, D be categories. For every x in C1 , and y in C2, let R x , Ly : C2 , C1 → D be
functors such that y, Ly ; x, Rx . There exists a functor F : C1 × C2 → D, such that F x is Rx and Fy is
Ly , if and only if for every arrow f →× g : a →× b −→ c → d, in C1 × C2 , we verify
Ld f, Lb f ; Rc g, Ra g.

(III.8)

We define F( f, g) := Ld f ∗ Ra g, and F(a, b) := Ra b.
Proof. We will first suppose the condition (III.8). First of all, 1D ◦ FO is the same as FA ◦ 1C1 ×C2 :
a →×
a →×
a →×
a →×
a →×
a →×
a →×
a →×
a →×

b
b
b
b
b
b
b
b
b

;
;
;
;
;
;
;
;
;

(1D ◦ FO )(a →× b), 1D ◦ FO
1D (F(a, b)), 1D ◦ FO
1D (Ra b), 1D ◦ FO
1(Ra b) , 1D ◦ FO
1(Ra b) ∗ 1(Ra b) , 1D ◦ FO
1(Lb a) ∗ 1(Ra b) , 1D ◦ FO
Lb 1a ∗ Ra 1b , 1D ◦ FO
FA (1a , 1b ), 1D ◦ FO
(FA ◦ 1C1 ×C2 )(a →× b), 1D ◦ FO .

Given an arrow f →× g : a →× b −→ c →× d, we have F( f, g) : F(a, b) → F(c, d). To prove this,
notice Ra g, Ld f : Ra b, Ld a → Ra d, Ld c. Since d, Ld ; a, Ra and d, Ld ; c, Rc are true, we may conlcude
F( f, g) : Fa b → Rc d. We move on to prove the third condition of functors. Let h : c → x and i : d → y,
h →×
h →×
h →×
h →×
h →×
h →×
h →×
h →×

i∗
i∗
i∗
i∗
i∗
i∗
i∗
i∗

f
f
f
f
f
f
f
f

→×
→×
→×
→×
→×
→×
→×
→×

g
g
g
g
g
g
g
g

;
;
;
;
;
;
;
;

F(h ∗ f, i ∗ g), F
Ly (h ∗ f ) ∗ Ra (i ∗ g), F
Ly h ∗ (Ly f ∗ Ra i) ∗ Ra g, F
Ly h ∗ F( f, i) ∗ Ra g, F
Ly h ∗ (Rc i ∗ Ld f ) ∗ Ra g, F
(Ly h ∗ Rc i) ∗ (Ld f ∗ Ra g), F
F(h, i) ∗ F( f, g), F
F(h →× i) ∗ F( f →× g), F

Finally, we must show F x is the same functor as R x , and Fy is the same as Ly . The observation is
trivial for the object function; F x y is F(x, y), whom we have defined as R x y. This implies that Ly x is
Fy x := F(x, y). For the arrow functions, we have
i∗g
i∗g
i∗g
i∗g
i∗g
i∗g
i∗g
i∗g

;
;
;
;
;
;
;
;

F x (i ∗ g), Fx
F(1 x , i ∗ g), Fx
Ly 1 x ∗ Rx (i ∗ g), Fx
1(Ly x) ∗ R x (i ∗ g), Fx
1(Rx y) ∗ R x (i ∗ g), Fx
R x 1y ∗ R x (i ∗ g), Fx
R x [1y ∗ (i ∗ g)], Fx
R x (i ∗ g), Fx .

CHAPTER III. SET THEORY

64
h∗
h∗
h∗
h∗
h∗
h∗
h∗
h∗

f
f
f
f
f
f
f
f

;
;
;
;
;
;
;
;

Fy (h ∗ f ), Fy
F(h ∗ f, 1y), F x
R x (1y ) ∗ Ly (h ∗ f ), Fy
1(Rx y) ∗ Ly (h ∗ f ), Fy
1(Ly x) ∗ Ly (h ∗ f ), Fy
Ly 1 x ∗ Ly (h ∗ f ), Fy
Ly [1 x ∗ (h ∗ f )], Fy
Ly (h ∗ f ), Fy .

Now, suppose the contrary and prove (III.8)
Ld f
Ld f
Ld f
Ld f
Ld f
Ld f
Ld f
Ld f

;
;
;
;
;
;
;
;

Ld f ∗ Ra g, Ra g
Fd f ∗ Fa g, Ra g
F( f, 1d ) ∗ F(1a , g), Ra g
F( f ∗ 1a , 1d ∗ g), Ra g
F(1c ∗ f, g ∗ 1b ), Ra g
F(1c , g) ∗ F( f, 1b ), Ra g
Fc g ∗ Fb f, Ra g
Rc g ∗ Lb f, Ra g.

Theorem 9.1. Given any category with all Hom sets, we can form a bifunctor Hom : C × C → Set;
referred to as the Hom bifunctor.
The two functors that constitute Hom, are called the contravariant and covariant Hom functors.
Given an arrow f : a → c in C, we have natural transformations f † : Lc → La and f† : R⋉a → R⋉c .
Proof. For every x in C, there are covariant functors R x : Cop → Set and Lx : C → Set; the functor
Rx is defined by Rx (gop ) := (R⋉x g)op . Notice that Ld f is the function f ∗ : {d → a} → {d → c} that
sends h : d → a into f ∗ h. On the other hand, Ra (gop ) is (R⋉a g)op : {b → a} → {d → a} that sends
iop : b →op a into iop ∗ gop . Therefore, Ld f ◦ Ra (gop ) is the function ( f ∗) ◦ (∗gop ) : {b → a} → {d → c};
the arrow function sends i into f ∗ (iop ∗ gop ), which is f ∗ (g ∗ i).
One can just as easily prove Rc (gop ) ◦ Lb f is the function (∗gop ) ◦ ( f ∗) : {b → a} → {d → c}
that sends i into ( f ∗ iop ) ∗ gop which is f ∗ (iop ∗ gop ). Using the second lemma, we find a functor
F : Cop × C → Set; consequently, we have a bifunctor Hom : C × C → Set.
Finally, apply the first lemma to the functor F. For any arrow f op : a →op c in Cop , we have a
natural transformation f † : Lc → La . The reader can find f† : Ra → Rc in the same way.
Yoneda’s Lemma Here we will see that the construction provided for the natural numbers is not
a coincidince. It is a specific application of the following result that generalizes even results from
group theory (Cayley’s Theorem). We will try to see why Yoneda’s Lemma generalizes this result. The
Yoneda embedding is provided as a corollary to the lemma and it enables us to prove Cayley’s theorem.
Let E : Cat(C, Set) × C → Set, be defined by E(C, x) := Cx as object function. If τ →× f is an
arrow in the domain, with τ : C → D as a natural transformation and f : a → c, then the arrow function
of E is defined by the element given in τc, τa; D f, C f . That is to say, E(τ, f ) := τc ◦ C f .

9. CATEGORIES

65

Now let N : Cat(C, Set) × C → Set such that N(C, x) := Nat(L x , C). Suppose C →× a and D →× c
are c-objects in the domain such that τ : C → D and f : a → c. If we want for N to be a functor, we
have to give an arrow function that sends τ →× f into a function N(τ, f ) : Nat(La , C) → Nat(Lc , D).
Take any α in Nat(La , C) and define N(τ, f )α := τ · α · f † ; this is the vertical composition of natural
transformations where we recall f † : Lc → La .
We say that a natural transformation is a natural isomorphism if all the components τx are isomorphisms of the category in the range of the functors. This serves as a natural transformation from each
functor to the other so that we can jump from one functor to the other and back.
Yoneda Lemma. Let a be any c-object in a category C, with all Hom sets.
1) Let C : C → Set be a functor, then there is a bijective function φCa : Nat(La , C) → Ca.
2) E, N are functors and the functions φCa are components of a natural isomorphism Φ : N → E.
Proof.
1) Let us define the function φ so that τ : La → C is transformed by τ 7→ τa(1a ). We know τ
sends any c-object x, in C, into the function τx : {a → x} → Cx. This means τa(1a ) is an
element of Ca. We also know that for any f : a → c, the relation τc, τa; C f, f ∗ holds in terms of
composition of functions; recall La f is a function f ∗ : {a → a} → {a → c}. Therefore, we may
say τc( f ∗ 1a ) is the same as C f [τa(1a )]. If we use the notation for applying functions, we express
f ; C f [τa(1a )], τc. Let us suppose τ and σ are different natural transformations in Nat(La , C); that
is, there exists an object c such that τc and σc are different set functions. As a consequence, we
can give an arrow f ∈ {a → c} and we verify τc f , σc f . Thus, C f (φτ) , C f (φσ), which implies
φτ , φσ, and we conlcude φ is monic.
Let x ∈ Ca, and define τx : O|C → A|Set such that τx c : {a → c} → Cc. The function τx c
transforms f 7→ C f (x). We will show this defines a natural transformation in Nat(La , C). Apply
the function τx c ◦ f ∗ to an arrow g ∈ {a → a}:
g
g
g
g
g
g
g
g

;
;
;
;
;
;
;
;

(τx c ◦ f ∗)g, τx c ◦ f ∗
τx c( f ∗ g), τx c ◦ f ∗
C( f ∗ g)(x), τx c ◦ f ∗
(C f ◦ Cg)(x), τx c ◦ f ∗
C f [Cg(x)], τx c ◦ f ∗
C f [τx a(g)], τx c ◦ f ∗
(C f ◦ τx a)g, τx c ◦ f ∗
(C f ◦ τx a)g, τx c ◦ f ∗ .

We have thus proven τx c, τx a; C f, La f and we conclude φ is bijective.
2) Now, we would like to show E, N are functors. We begin with E, verifying 1Set E(C, x) is the
identity function. The same results from sending C →× x into its unit arrow, and transforming
that with E; this results in (1C x) ◦ (C1 x ), which is the composition of the identity function IC x
with itself. Take a c-object in the domain, say C →× a and D →× c, then the second condition of

CHAPTER III. SET THEORY

66

functors is given by E(τ, f ) := τc ◦ C f : Ca → Cc → Dc. The last condition is not difficult to
prove either; let τ →× f and σ →× g be composable arrows in the domain:
σ →×
σ →×
σ →×
σ →×
σ →×
σ →×

g ∗ τ →×
g ∗ τ →×
g ∗ τ →×
g ∗ τ →×
g ∗ τ →×
g ∗ τ →×

f
f
f
f
f
f

;
;
;
;
;
;

E(σ →× g ∗ τ →× f ), E
E(σ · τ, g ∗ f ), E
(σ · τ)c ◦ C(g ∗ f ), E
σc ◦ τc ◦ Cg ◦ C f, E
σc ◦ Dg ◦ τb ◦ C f, E
E(σ, g) ◦ E(τ, f ), E.

To show the first condition of functros is valid for N, notice (1Set ◦ N)(C, x) results in the identity
function of Nat(Lx , C). On the other hand, if we apply N to the unit arrow of C →× x, we get a
function N(1C , 1 x ) : Nat(L x , C) → Nat(L x , C) such that α 7→ 1C · α · 1†x . Since 1†x is the natural
transformation 1Lx : Lx → Lx , we say 1) for functors is true. The second condition for N to
be a functor has been shown to be true, by construction. We are left to prove 3); we must show
N(σ · τ, g ∗ f ) is the same function as N(σ, g) ◦ N(τ, f ).
α
α
α
α
α
α

;
;
;
;
;
;

N(σ · τ, g ∗ f )α, N(σ · τ, g ∗ f )
(σ · τ) · α · (g ∗ f )† , N(σ · τ, g ∗ f )
(σ · τ) · α · ( f † · g† ), N(σ · τ, g ∗ f )
σ · (τ · α · f †) · g† , N(σ · τ, g ∗ f )
N(σ, g)(τ · α · f †), N(σ · τ, g ∗ f )
[N(σ, g) ◦ N(τ, f )]α, N(σ · τ, g ∗ f ).

Here, we are considering that for composable arrows f, g : a, b → b, c we have the natural
transfomations f † : Lb → La and g† : Lb → Lc .
Now we prove there is a natural transformation from Φ : N → E. To verify this, let τ →× f be
an arrow C →× a into D →× b and let α : La → C:
α
α
α
α
α

;
;
;
;
;

[Φ(C, a) ◦ N(τ, f )]α, Φ(C, a) ◦ N(τ, f )
φCa (τ · α · f †), Φ(C, a) ◦ N(τ, f )
[(τ · α · f † )b](1b ), Φ(C, a) ◦ N(τ, f )
[(τ · α)b ◦ f †b](1b ), Φ(C, a) ◦ N(τ, f )
[(τ · α)b] f, Φ(C, a) ◦ N(τ, f )

Since f † is a natural transformation that sends c-objects in C, into set functions, we know f †b is a
function {b →op b} → {b →op a}, so that f † b(1b ) is defined as f op ∗ 1op
b , which is f . We continue,
α
α
α
α
α
α
α

;
;
;
;
;
;
;

(τb ◦ αb) f, Φ(C, a) ◦ N(τ, f )
τb(αb f ), Φ(C, a) ◦ N(τ, f )
τb[C f (αa(1a ))], Φ(C, a) ◦ N(τ, f )
(τb ◦ C f )(αa1a ), Φ(C, a) ◦ N(τ, f )
E(τ, f )(φCa α), Φ(C, a) ◦ N(τ, f )
E(τ, f )[Φ(C, a)α], Φ(C, a) ◦ N(τ, f )
[E(τ, f ) ◦ Φ(C, a)]α, Φ(C, a) ◦ N(τ, f ).

9. CATEGORIES

67

Notice we are using the fact that αb f is the same as C f [αa(1a )]. With this we have proven Φ is
natural. Now, we only need to notice that the components are bijective functions, to conclude Φ
is a natural isomorphism.

The result presented below has been proven above, for the most part; it is commonly known as the
Yoneda Embedding.
Corollary. There is a contravariant functor Y † : C → Cat(C, Set) such that Y † x := L x . There is a
covariant functor Y† : C → Cat(Cop, Set) that makes Y† x := R x . The functors Y † and Y† are full
embeddings, with the arrow functions f 7→Y † f † and f 7→Y† f† .
Proof. We only need to prove the arrow function is bijective. In the lemma, make C := Lb , so that we
have a bijective function φ : Nat(La , Lb ) → Lb a; this is a bijection {b → a} → Nat(La , Lb ). Given any
arrow f , we know there is a natural transformation f † in Nat(La , Lb ). Additionally, we have proven
φ f † := f †a(1a ) = f .
Corollary. Suppose G is a group such that the collection of objects of operation is a set, A|G ∈ Set.
Then G is isomorphic to a group of transformations G† , G† : {e → e} → {e → e}.
Proof. Let C := G, be the group. The functor C := Le : G → Set is as we have described before;
the c-object e is sent into a set S , while objects of operation are sent into set functions S →iso S . The
Yoneda embedding provides a functor Y † : G → Cat(G, Set), where the c-object is transformed into
the Hom functor Le . The existence of inverse objects of operation, in the group G, implies f ∗ and ∗ f
are isomorphisms (bijective function) for the set A|G; this was proven in proposition (4.2). This means
we indeed have a group of transformations for A|G, if we replace the image by a category where S is
c-object, instead of Le .
In building the group of integers, we took a category Z† as the c-object of the group. The objects of
operation are of course the integers which we considered as automorphisms for the category mentioned.
Then, the group of functors Z† was constructed as compositions and inverses of +1. This is the functor
we used to later prove that we can view the discrete number system as a group. This is the functor that
gave an operation.
Representable Functors An object in the collection C →× Nat(L x , C), is said to be a representation of C : C → Set. The functor is said to be representable and x is called a representing object.
We see that given two representations of a functor, it is possible to find an isomorphism, in C, that
relates the natural transformations.
Proposition 9.2. Let (x, β) and (y, γ) be two representations of a functor F : C → Set. Then there is a
unique isomorphism f : x → y such that γ = β · f † .
Proof. We can define a composition of natural isomorphisms, β−1 ◦ γ : Ly → C → Lx , where β−1 is the
natural isomorphism of inverse arrows. From Yoneda’s embedding, we know there is an arrow f such
that β−1 ◦ γ = f †. We have proven that functors send isomorphisms into isomorphisms; proposition
5.1.

CHAPTER III. SET THEORY

68

§10 Set Function
10.1 Image
Here we will give relations for the image and preimage of set functions. If we have an object in f A, for
some A ⊆ Dom f , then there is an x ∈ A such that our original object, in f A, is the object f x. For this
reason, we will be justified in denoting our object of interest with ( f x) ∈ f A. The notation says that
( f x) is an object in Range f , such that ( f x) = f x.
When considering a family of sets, we also consider another family, to be regarded as the image of
the original. Let X = {A}A∈X be a family of subsets of Dom f . The image of family X, is the family that
consists of the images of sets in X. This means, f [[X]] = { f A}A∈X. Let us suppose we have a family
Y = {B}B∈Y of subsets B ⊆ Range f . We define the inverse image of family Y, as the family consisting
of the sets that are inverse image of sets in Y. Let f −1 [[Y]] be the inverse image of Y, and take an
object of it. Then there exists B ∈ Y such that our original object is the inverse image of B. We are
justified in representing an arbitrary object in f −1 [[Y]], with ( f −1 B).
Image and Inclusions The image and preimage preserve subsets. That is, f A ⊆ f B and f −1 A ⊆
f −1 B; the first relation holds given A ⊆ B ⊆ Dom f and the second holds given A ⊆ B ⊆ Range f .
Proposition 10.1. Let f : Dom f → Range f be a set function. Then, for every A ⊆ Dom f and
B ⊆ Range f we verify
1) A ⊆ f −1 f A, and A = f −1 f A if f is monic.
2) B ⊇ f f −1 B, and B = f f −1 B if f is onto.
Proof. x ∈ A implies f x ∈ f A, which is true if and only if x ∈ f −1 f A. If f is monic, then x ∈ A if and
only if f x ∈ f A, which proves the equality holds.
We have ( f x) ∈ f f −1 B if and only if there exists x ∈ f −1 B such that ( f x) = f x ∈ B. Let f be onto,
then for every ( f x) ∈ B there exists x ∈ f −1 B such that ( f x) = f x, which proves ( f x) ∈ f f −1 B.
Using the results so far given, we get
f A ⊆ B ⇐⇒ A ⊆ f −1 B
which was to be expected since we define the inverse image by x ∈ f −1 A ⇔ f x ∈ A. If f is onto,

f −1 B ⊆ A =⇒ B ⊆ f A.
If f is monic, then

B ⊆ f A =⇒ f −1 B ⊆ A.

10. SET FUNCTION

69

Image and Set Operations The difference is preserved under preimage; x ∈ f −1 (B − A) ⇔ f x ∈
B − A ⇔ f x ∈ B and f x < A ⇔ x ∈ f −1 B and x < f −1 A ⇔ x ∈ f −1 B − f −1 A. We get the following
result, as a consequence of this:
f −1 (Range f − A) = Dom f − f −1 A.
We will generally say Ac is X − A if we accept that all work will be done in a certain set X. If we are
considering the sets Dom f and Range f , we may re-write the above expression as f −1 Ac = ( f −1 A)c .
−1
c c
−1 c
−1
c
−1
Let B ⊆ Range f , then f |−1
A B = f | A [(B ) ] = A − f | A B = A − ( f | A B) = A ∩ f | A B. It is easy to prove
−1
A ∩ f |−1
A B = A ∩ f B, so we conclude
−1
f |−1
A B = A ∩ f B.

(III.9)

This means the inverse image of B, under f |A , is equal to A ∩ f −1 B.
Proposition 10.2. Let X = {A}A∈X a family of subsets A ⊆ Dom f and Y = {B}B∈Y a family of subsets
B ⊆ Range f . Then
[
[
f
A =
fA
(III.10)
A∈X

f A∈ f [[X]]

f

\

A ⊆

f −1

[

B =

\

B =

A∈X

B∈Y

fA

f A∈ f [[X]]

[

f −1 B

\

f −1 B.

f −1 B∈ f −1 [[Y]]

B∈Y

f −1

\

f −1 B∈ f −1 [[Y]]

We verify equality in the second relation, given f is monic.
Proof.
S
S
1) We know ( f x) ∈ f A∈X A if and only if there exists x ∈ A∈X A such that ( f x) = f x. This is the
same as saying ( f x) ∈ f A, for some f A ∈ f [[X]].
T
T
2) The relation ( f x) ∈ f A∈X A holds if and only if ( f x) = f x, for some x ∈ A∈X A. Now,
let ( f A) ∈ f [[X]]. Then ( f A) = f A, for some A ∈ X such that f x ∈ f A. In other words,
( f x) ∈ ( f A), for every ( f A) ∈ f [[X]].
T
Take ( f x) ∈ f A∈ f [[X]] f A. This is stating that ( f x) is in the image of every A ∈ X. This holds
if and only if, for every A ∈ X, there exists xa ∈ A such that ( f x) = f xa . If f is monic, then
T
xa = x, for some x that is the same for all A ∈ X. We conclude ( f x) = f x ∈ f A∈X A because
T
x ∈ A∈X A.
S
S
3) It is from the definition of inverse image that we have f x ∈ B∈Y B, for every x ∈ f −1 B∈Y B.
S
Then, x ∈ f −1 B, for some B ∈ Y. We conclude x ∈ B∈Y f −1 B. All the implications in the
argument are ⇔.
T
T
4) x ∈ f −1 B∈Y B if and only if f x ∈ B∈Y B. It follows from this that x ∈ f −1 B, for every B.

CHAPTER III. SET THEORY

70

Fiber We say that the preimage of a singleton {z} ⊆ Im f is the fiber for z, under f . We will
express this by f −1 {z} or f −1 [z], in place of the strict notation f −1 [{z}]. We notice that x ∈ f −1 [z] ⇔ x ∈
f −1 {z} ⇔ f x ∈ {z} ⇔ f x = z. It is clear that f −1 [z] = ∅ implies z ∈ Range f − Im f . From the definition
of function we know every object in the domain belongs to exactly one fiber of f . If f A = z ∈ Im f ,
then A ⊆ f −1 [z]. A function with z ∈ Im f such that f −1[z] = Dom f is called constant function to z and
we write → z.
A function is onto if and only if every fiber of f is non-empty. Let f be a bijective function and let
g be the inverse function of f , then x ∈ f −1[z] if and only if z ∈ g−1 [x]. Said differently, this last means
x ∈ f −1 {z} if and only if z ∈ ( f −1 )−1 {x}; we take notice that f −1 {z} is the inverse image of {z}, under f ,
while ( f −1 )−1 {x} is representative of the inverse image of {x} under f −1 .
Let us consider the family f −1 {{B}} := f −1[[{{b}}b∈B]] = { f −1{b}}b∈B, which represents inverse image
of the family {{b}}b∈B.
S
Proposition 10.3. Let f be a monic function and take A ⊆ Dom f . Then f A = B ⇔ A = f −1 {{B}}.
S
S
Proof. Suppose A = f −1 {{B}} = { f −1{b}}b∈B, then
[
fA = f
{ f −1{b}}b∈B
[
=
f { f −1{b}}b∈B
[
=
{{b}}b∈B
[
=
{b}.
b∈B

If on the contrary, f A = B, then
A =
=

[
{a}

a∈A
[

f −1 f {a}

a∈A

=

[

f −1 {b}

b∈ f A

[
=
{ f −1{b}}b∈B.

10.2 Quotient Sets and Decomposition of Functions
We start this section by giving a result that characterizes onto functions as functions that have and right
inverse. Consider the family {{Im f }} = {{x}} x∈Im f , which means it consists of the sets {x}, where
x ∈ Im f . The inverse image, f −1 [[{Im f }]], is a family of sets in Dom f which turn out to be the fibers
of f . We will view f −1 [[{{Im f }}]] as a simple set, in which we will not take into account what the
objects of the sets in the family are; we only care for the sets of the family.
A function can always be expressed as a composition of an inmersion and an onto function; a
composition of one onto function and one monic function. Let f |Im f : Dom f → Im f , denote the
function f restricted to the image.

10. SET FUNCTION

71

Lemma I. For any f and ι f : Im f → Range f we verify f = ι f ◦ f |Im f .
Further on, we will complete this description by expressing a function as the composition of three
functions, one of each type: onto, bijective, and monic.
Given a set function f , we will give an equivalence relation E f defined for Dom f . We say two
objects x, y ∈ Dom f are related, xE f y, if f x = f y. We call such a relation the image equivalence of f.
Another way of seeing this is
xE f y ⇐⇒ x, y ∈ f −1 [z],
for some z ∈ Im f . We may conclude that the fibers of f form the simple equivalence reations of E f .
Define a new domain Dom f /E f := f −1 [[{{Im f }}]], for the function
f /E f : Dom f /E f → Im f.
Naturally, we define f −1 [z] 7→ f /E f z, because for every x ∈ f −1 [z], we have x 7→ f z.
Lemma II. The function f /E f is said to be the function f module E f and it is bijective.
Proof. The function is onto because every fiber of Im f is non-empty. To see that it is also monic, take
two different fibers f −1[w] and f −1 [z]. These two fibers consist of objects x 7→ f w and y 7→ f z and they
form simple equivalence relations under E f . Therefore, w , z.
Let p f : Dom f → Dom f /E f that sends an object to its fiber. We can do this because we have
already stated that every object in Dom f is associated one fiber. We know the function is onto because
every fiber in f −1 [[{Im f }]] is non-empty.
Theorem 10.4. Given a function f , we can decompose it as f = ι f ◦ f /E f ◦ p f

10.3 Sequence
From this point on, we may use N to refer either to the collection or N≤ . A sequence is a set function
s : N → A. A general sequence is a sequence in which the image A is a collection, not necesarilly a set.
We will say a set function is a sequence, if Dom s is N0 instead of N. Let n ∈ N, and define n as the set
of all x ∈ N such that 1 ≤ x ≤ n. A finite sequence is a function n → A. Also, a set A is said to be finite
if there exists n ∈ N such that there is a bijective function n → A.
Consider now the category N which stands for the partial order. Let S : N → N be a functor on the
order. Then s ◦ S is a sequence and we will call it a subsequence of s. We request S to be a functor so
that the the order of N is preseved.
Representation A sequence is, informally, an ordered collection. It makes sense to, for example,
write a sequence of two numbers as (a, b) and not {a, b} which is a simple set. In general, to express a
sequence with components n 7→ xn , we will write (xi )i . If the sequence is finite, we will write (xi )ni=1 .
When we write (x)i , we are expressing that the sequence is a constant function, → x.
Monotonic Sequence Suppose we define a functor N → A, where A is a partial order. Then, the
object function of such a functor is called a increasing sequence in A. If there is a functor N → Aop , we
will call the object function of such a functor, a decreasing sequence in A.

CHAPTER III. SET THEORY

72

Sequence of Objects for an Operation We can give a general form of expressing the operation
union and intersection for sets. Let I be a set, the index set, and let I → X such that i 7→ Ai . The
following may be used as a common notation
[
[
X=
Ai .
i∈I

Similar remarks hold for the intersection. We will use the set of integers as an index set, in order to
express general operations. Let ⊕ be an operation ⊕ : O → O f O and let ON represent the collection of
N
n
sequences N → O. We will give, for n + 1 ∈ N0 , a function Λn+1
i=1 : O → O such that (xi )i 7→ Λi=1 (xi )i ⊕
xn+1 , where Λ1i=1 (xi )i = x1 . These functions are called the finite operators. The sequence Λ : N → ON f O
is defined by n 7→Λ Λni=1 ; we call it the general operator. For any sequence of sets, we can give union
S
T
S
and intersection and this is expressed by i∈N Ai or i∈N Ai . We define ΛO = n∈N Im Λn. If there is a
sensible way of defining a function ΛN : A ⊆ ON → O, we may say the series of (xi )i is the result in
(xi )i ; Λi∈N xi , ΛN. We may also represent the series by Λ∞
i=1 xi .
We may use this development to express the general sum of multiple rational numbers. Just as we
use the notation ON , we will say On stands for the collection of all finite sequences n → O. Thus the
sum of a finite sequence of rational numbers, (xi )i ∈ Qn , is given by
n
X

xi =

i=1

n−1
X

xi + xn

i=1

and from this we get
a·n=

n
X

a.

i=1

Pn

We are making it clear that ·n and i=1 are the same function when applied, respectively, to a ∈ Q
P
and the sequence (a)i ∈ Qn . Note that every natural number a ∈ N is represented as a = ai=1 1.
Sequence of Functions We have just defined a sequence of functions, that can be applied to a
sequence, and the result is another sequence. We study this with a general view. A sequence of objects,
in a collection of functions, is called a sequence of functions. A sequence of functions from O into Q
is a function Φ : N → O f Q. Let n 7→Φ fn be the components of Φ, and define φ : O → QN such that
x 7→φ ( fi x)i ; it is the sequence function.
In the case of series, the general operator Λ : N → ON f O is the sequence of functions Φ. The
sequence function is φ : ON → ON . The image of (xi )i , under φ, is the sequence of partial operations
for


n
n
(xi )i and we represent it with (φi )i . Clearly, every φn is Λi=1 (xi )i , so we have stated φ(xi )i is Λi=1 (xi )i .
n
We will consider an important special case of this. Let (a)i ∈ ON be a constant sequence, and suppose
there is an operation on the collection, called the product operation. Then the sequence of powers is
Q
defined as the sequence of partial products. For the operation of product · in Q, we use as the general
operator and
n

a =

n
Y

a,

i=1

in representing the finite operator of product, applied to (a)i .

10. SET FUNCTION

73

Sequence for Composition There is something important to be noticed in the last paragraph. For
a fixed sequence (xi )i ∈ ON , we have a sequence of functions (⊕xi )i which we compose to find Λni=1 (xi )i .
This sequence of functions has something particular about it. If the operation is full, each one of these
functions is of the form O → O. Let us make the case for a more general situation.
Let ( fi )i be a sequence of functions such that Im fn = Dom fn+1 . This is a composable sequence
of functions and to better understand this definition we will give a more specific description of the
composition of functions. Let f : Dom f → Range f and g : Dom g ⊆ Range f → Range g. Let D =
f −1 [Im f ∩ Dom g], then the composition is g ◦ f : D → Range g; we are assured x 7→ f f x 7→g g( f x).
The composition is onto if and only if g is onto, and it is monic if and only if both f, g are monic.
n
1
The compositions of a sequence are n+1
i=1 ( fi )i 7→ i=1 ( fi )i ◦ fn+1 , remembering that i=1 ( fi )i is f1 .
We have a special case, when we take a constant sequence ( f )i , consisting of only one function f . The
composition ni=1 ( f )i is the function f n . We see that Im f 2 = f [Im f ], Im f 3 = f [ f [Im f ]], etc...
If x 7→ f x, then we say x is an invariant object under f. If f A = A, then A is an invariant subset
under f. Notice that it is not the same to say A is an invariant subset under f as opposed to saying A
is a set of invariant objects under f . In this last case we say that A is a strongly invariant subset; these
are subsets of Inv f which is the set of invariant objects. If Im f is strongly invariant, Im f ⊆ Inv f ,
then the function is said to be once-effective. The situation is that f 2 : Im f → f [Im f ] = Im f and
x 7→ f 2 f x because f x is invariant under f . This means the sequence of compositions ( f i )i is the constant
sequence of the function f |Im f .
Let a be invariant under f and suppose that for every x ∈ Dom f there exists n ∈ N such that
x 7→ f n a; we say f stableizes at a. If there is n ∈ N such that x 7→ f n a, for every x ∈ Dom f , then f is
nilpotent into a.
Sequence and Cartesian Product From this point on, we make the convention of writing A × B
in the place of A →× B. The cartesian product of two collections A, B is a collection of arrows a →× b,
with a, b ∈ A, B respectively. Let 2 f (A⊔ B) be the collection of two part functions 2 → A∪ B that send 1
to an object in A and send 2 into object of B. We have a bijective function of the form A×B → 2 f (A⊔B).
Let us now consider the cartesian product of a sequence of sets; that is, A = ×n+1
i=1 Ai . This is the set
of all arrows a1 −→ an+1 : (a1 −→ an ) →× an+1 , where a1 −→ a2 is a1 →× a2 and ai ∈ Ai . We see that
F
each of these arrows a1 −→ an+1 is a finite sequence n+1 → n+1
i=1 Ai with i 7→ ai .
If we limit ourselves to Ai = A, for all i ∈ n+1, then we have a finite sequence on A. In making
n+1
such considerations, we have a bijective function ×n+1
, where An+1 is the collection of all
i=1 A → A
sequences n+1 → A. We define AN = ×i∈N A as the collection of all sequences for A.

10.4 Net
We will be working with functions that have a kind of special domain. This will lead to a useful
generalization of sequence. Sequence is generalized because we generalize the concept of ordered
index set; where we have used N we will now use a general kind of set called directed set.
Bounds Let X be a set that forms a partial order with some relation ≤. A subset A ⊆ X has a
unique object max A ∈ A that is maximum if a ≤ max A, for every a ∈ A. Now consider the set ↓ A of
all x ∈ X such that a ≤ x, for every a ∈ A. This is the set of upper bounds of A and it need not have
a minimum, defined dually to the maximum. Therefore, we cannot always say that there is an upper
bound; if ↓ A , ∅ we still cannot say their is a least upper bound min ↓ A; even if min ↓ A does exist

CHAPTER III. SET THEORY

74

we cannot say that it is in A. When this most important object min ↓ A, exists in X, we say it is the
supremum and denote it by sup A. The infimum, denoted inf A is defined, when it exists, as max ↑ A.
Of course, if the supremum is in A, then it is the same as the maximum.
If ↓ A = ∅, then A is not bounded by above. Similarly, we define sets that are not bounded by below.
If a set is not bounded by below and is not bounded by above it is simply not bounded.
Directed Set A set I that has defined a preorder is said to be a directed set if for every i, j ∈ I there
is a k ∈ I such that i, j ≤ k. We give an equivalent definition for directed set, in terms of bounds.
Proposition 10.5. A partial order is directed if and only if every finite subset has an upper bound.
Proposition 10.6. Q ⊇ Z ⊇ N are directed sets. In general, a natural order is a directed set.
We already know of an important directed set that is not the set of integers or rationals. The category
PN is directed, under inclusion.
Proposition 10.7. For any set A, the category PA gives a directed set. Let x ↑ x0 represent the set of
objects x ∈ X such that x ≤ x0 ∈ X. Then x ↑ x0 is a directed set.
Given preorders ≤1 , ≤2 on sets I, J, we can form the new order ≤ by defining (i1 , j1 ) ≤ (i2 , j2 ) if and
only if i1 ≤ i2 and j1 ≤ j2 .
Proposition 10.8. If I, J are two directed sets with orders ≤1 , ≤2 , then the cartesian product I × J is
also a directed set under the corresponding product order.
Definition A net is a function η : I → O, where I is a directed set. The concept of net generalizes
that of a sequence because we know N is a directed set.
When considering a finite sequence, we now think in a broader sense. A finite sequence is a function
N → O, where N ⊆ N is bijective to n, for some n ∈ N. A general definition of a sequence, but less
general than a net, is to replace the set N with any directed subset I ⊆ N. But, it turns out that any
subset of N is directed. So, a sequence is a function I ⊆ N → O. A net generalizes this definition. The
first thing we will do to put to use the conpcept of net, is to give a definition of of matrix.

10.5 Matrix
The reason why we did not consider the object 00 in our grid of the rational numbers, (II.5), is that we
did not have any way of considering this strange object in terms of our operation. So we leave it out,
and in fact, we make changes to the normal behavior of the grid, along the border. This does not mean,
however, that we are not able to define a good order in Z × Z, if we just ignore the operation in this
process. Again, representing a →× b with ba , we say Z2≤ is the matrix order, defined by ac ≤ db if and only
if a < b or, if this fails to be true, c ≤ d. This order is a natural order.
Definition 11. Let I, J ⊆ Z, then we say the function (aij )i, j : J × I ⊆ Z2≤ → A is a matrix for the objects
of A. If i, j ∈ I, J respectively, then the image of ij , under the matrix, is represented by aij .
A matrix is said to be finite if I, J are bijective to sets m, n ⊆ N respectively. The matrix is regular
if it is of the special form m × n → A, that is, if I = m and J = n. In any case, we say the matrix is of
order m × n.

11. SPECIAL FAMILIES

75

If we restrict the matrix to one of the sets m × { j}, then we have a matrix (aij )i = (aij )i, j |m×{ j} , of the
form m × { j} → A and we say (aij )i is the j-th column of the matrix (aij )i, j . A similar remark holds for
the restriction of (aij )i, j to a set {i} × n; in this case we say (aij ) j is the i-th row of (aij )i, j .
Proposition 10.9.
1) Every column or row is a matrix
2) Every matrix is uniquely identified with a sequence of rows and with a sequence of columns.
3) Any sequence can be uniquely identified with one column matrix and one row matrix.

§11 Special Families
11.1 Power Set
Power Functor We move on to study the power set P. We will find a functor P : Set → Set such
that its object function is given by B 7→ PB. Since we are to give a functor, we need to specify an arrow
function such that f : B → C is assigned a function P f : PB → PC. To this end, we define the arrow
function such that P f is the function that makes A 7→ f [A]. We verify that P is indeed a functor. We
must first prove that 1Set , 1Set ; P, P, where 1Set B is the identity function for B. That is, (1Set ◦ P)B and
(P ◦ 1Set)B are the same functions, for every B ∈ Set. We also observe that P(g ◦ f ) is the same function
as Pg ◦ P f . Let A ⊆ B, then P(g ◦ f )A = (g ◦ f )[A] = g[ f [A]] = g[P f A] = Pg(P f A) = (Pg ◦ P f )A.
Properties and Relations Here we find equalities that involve expressions of power sets. We first
note that for any family of sets X = {A}A∈X,
[
X⊆P
A.
A∈X

S
We verify the validity of this. If A ∈ X, then every object of A is in X. Therefore, A is an object
in the power set of such union.
In particular, we have
{A} ⊆ PA.
(III.11)
S
S
S
We know A = {A} ⊆ PA. Also, X ⊆ A, for every X ∈ PA, we may conlcude A = PA.
The arrow in (III.11) leads to the trivial relation A ∈ PA. The relation A ∈ PA implies PA ∈ PPA.
We will give a generalization of this last relation.
Proposition 11.1. Let A be any set and XA ⊆ PA any family of subsets of A. Then XA ∈ PPA.
S
Consider a family X, and an element A ∈ X. We wish to prove PA ⊆ P X. This is clear because
S
PA is a family of subsets of A ⊆ X. Applying the last proposition,
S
Proposition 11.2. For A ∈ X ∈ U, we verify PA ∈ PP X.
Proposition 11.3. The object function of the power functor, satisfies
P(A ∩ B) = PA ∩ PB
PA ∪ PB ⊆ P(A ∪ B).

CHAPTER III. SET THEORY

76

Direct Image Now we define the direct image of a family of sets as the collection f [X] of all
B ⊆ Range f such that f −1 B ∈ X. Of course, the direct inverse image of a family Y, is the collection
f −1 [Y] of sets A ⊆ Dom f such that f A ∈ Y. Let f → A be the collection of all subsets of the range,
whose inverse image is A, and f ← B be the collection of all subsets of the domain, whose image is B.
Let P f −1 {B} be the fiber of B ⊆ Range f , for the function P f . Then the fiber has a maximum M =
S −1
S
P f {B}. All we need to verify is that B = P f M. This is straightforward, f M = f [ P f −1 {B}] =
S
S
X∈P f −1 {B} B = B.
X∈P f −1 {B} f X =
S
Lemma I. Let B ∈ Im P f , then f −1 B = P f −1 {B}.

Proof. We know M ⊆ f −1 f M = f −1 B. Also, f −1 B ∈ P f −1 {B} because P f ( f −1 B) = B. This implies
S
f −1 B ⊆ P f −1 {B}.
Lemma II.

P f −1 {B} ∈ X
S
2) Let f be a monic function, A ∈ f −1[Y] if and only if A = f −1{{B}}, for some B ∈ Y.

1) Let f be an onto function, then B ∈ f [X] if and only if

S

Proof. By definition of direct image and lemma I, B ∈ f [X] if and only if M = f −1 B ∈ X.
S
On the other hand, A ∈ f −1 [Y] if and only if f A ∈ Y. From proposition 10.3, we get A = f −1 {{B}},
for B = f A ∈ Y.
Define f ∅ := Range f − Im f , and let f (A ∪∅) be the collection of all Y such that f A ⊆ Y ⊆ f A ∪ f ∅.
Lemma III.
1) If f is onto, then f ← B = P f −1 {B}
2) f → A ⊆ f (A ∪ ∅) and equality holds given f is monic.
Proof. The first result is a direct consequence of the definitions of f ← B and P f .
To prove the second result we first take B such that A = f −1 B. We get f A = f f −1 B ⊆ B. Suppose
that ( f x) ∈ B and ( f x) < f A ∪ f ∅. This means ( f x) ∈ ( f A ∪ f ∅)c = ( f A)c ∩ Im f = Im f − f A. But, we
have A = f −1 B which is equivalent to saying f x ∈ B if and only if x ∈ A. This is a clear contradiction,
therefore B ⊆ f A ∪ f ∅. We conlcude B ∈ f (A ∪ ∅).
If we wanted to prove f (A ∪ ∅) ⊆ f → A by taking Y that satisfies the conditions of being an object
of f (A ∪ ∅), then A ⊆ f −1 f A ⊆ f −1Y ⊆ f −1 ( f A ∪ f ∅) = f −1 f A. We would get x ∈ f −1 Y ⇒ f x ∈ f A,
but f x ∈ f A does not imply x ∈ A. We request the function be monic.
Theorem 11.4. Suppose X is a family of non-empty subsets of Dom f and Y is a family of non-empty
subsets of Range f . If B ⊆ Im f , then
[
B ∈ f [X] ⇐⇒
f ← B ∈ X.
If f is monic, we have

A ∈ f −1 [Y] ⇐⇒

\

f → A ∈ Y.

Proof. The first result follows from lemmas II,III.
T
T
We know that A ∈ f −1[Y] if and only if B = f A = f (A ∪ ∅) = f → A, for some B ∈ Y.

We see that there is a duality relationship for fiber and image in the forms of f ← B and f → A.

11. SPECIAL FAMILIES

77

Another Functor We form yet another functor, using the power set P as object function of this
functor Set⊆ → Set⊆ . This means the second condition is satisfied because the functor applied to any
arrow A ⊆ B results in PA ⊆ PB. Since the first condition is trivial, we are left to give a proof of
condition 3) for functors. It means that transitivity is preserved. This is verified by

P[(A ⊆ B) ◦ (B ⊆ C)] =
=
=
=

P(A ⊆ C)
PA ⊆ PC
(PA ⊆ PB) ◦ (PB ⊆ PC)
P(A ⊆ B) ◦ P(B ⊆ C).

11.2 Family of Families
We will now give two basic results in applying the operations of sets to families of families of sets. We
will be using X = {X}X∈X to represent the family that consists of families, such that X = {A}A∈X. This is
to say, we have a two generation family of sets.
[\
[[
X⊆
X
(III.12)
\[

\\
X⊆
X.
T
S
Both of these follow from the fact that X ⊆ X.

(III.13)

11.3 Nest
We have pointed out that the power set is a partial order under inclusion. The objects of study in the
present section are those families of sets that form a natural order, under inclusion. In particular, there
are two cases of main interest. We will use this context to extend results (III.1) and (III.2).
Increasing Nest The first case happens when we have an infinite chain going forward. This means
that there is a sequence of sets {Ai }i∈N such that An ⊆ An+1 . When such a family is encountered, one
usually needs to find the union; the intersection is clearly A1 . The union will be expressed in terms of
S
S
a family of disjoint sets. Consider the family Bi = Ai − Ai−1 . We know i Bi ⊆ i Ai because each
S
Bi ⊆ Ai . Also, if x ∈ i Ai , then x ∈ Bm , where m is the smallest integer such that x ∈ Am . We conclude
[

Ai =

i

[

Bi

\

Bi .

(III.14)

i

∅ =

i

Decreasing Nest Now we analyze a sequence of sets such that An+1 ⊆ An . We are able to express
[
A1 =
(Ai − Ai+1 )
(III.15)
i

CHAPTER III. SET THEORY

78

To prove this, we begin with A1 = (A1 ∩A2 )∪(A1 −A2 ) = A2 ∪(A1 −A2 ). Then, since A2 = A3 ∪(A2 −A3 )
we can say A1 = (A1 − A2 ) ∪ (A2 − A3 ) ∪ A3 . We continue in this manner and see that this is the union
of a disjoint family.
Often, when using nests, one needs to find the intersection. It is expressed by

\
i

Ai



[ c c
=  Ai 
i

c


[ c
=  (Ai − Aci−1 )

(III.16)

i

This is obtained by using the sequence of Aci as a growing nest.

11.4 σ-Algebra
A set of subsets of some A ∈ U can be such that it is closed for the operations of union, intersection and
complement. Formally, a σ − algebra, A, is an object of PPA such that 1) A ∈ A, 2) If X ∈ A, then
S
X c ∈ A, and 3) For any sequence B ⊆ A we verify B ∈ A. This is similar to having a group, where
the objects of operation are the objects of the σ−algebra. Remember, however, that the complement is
not the inverse in the sense defined for categories.
T
T
S
For the same subset B, we have B ∈ A. The proof is B = Bc , since the objects of Bc are
also in A.
Generated σ−algebra Let B ∈ PPA, then the σ−algebra generated by B is represented by σ(B).
We define it as the smallest σ−algebra that contains all the objects of B. In other words, if B ⊆ A,
where A is a σ−algebra, then B ⊆ σ(B) ⊆ A.
Let Σ(B) be the collection of all σ−algebras that contain all the objects of B.
Proposition 11.5. The σ−algebra generated by a collection B, of subsets of A, is expressed by
σ(B) =
Proof. We know σ(B) ⊆
because σ(B) ∈ Σ(B).

T

\

Σ(B)

Σ(B) because σ(B) ⊆ A, for every A ∈ Σ(B). Also,

T

Σ(B) ⊆ σ(B)

11.5 Set Filter
A filter F is a non-empty family of non-empty subsets (there is at least one set in the filter and each set
has at least one object) of X such that for every F, G ∈ F and any H ⊇ F:
A) F ∩ G ∈ F
B) H ∈ F
A filter base is a non-empty family of non-empty subsets of X such that A) holds. We say a) holds
if for every F, G ∈ F there exists an H ∈ F such that

11. SPECIAL FAMILIES

79

a) H ⊆ F ∩ G.
Condition A) can be taken to be the finite intersection property because for any finite family of sets
T
X ⊆ F we have X ∈ F . A base filter can be defined equivalently, if we ask for the condition a)
instead of condition A). So, a filter may also be defined as a family that verifies conditions a) and B).
Filter Generated by a Base We will now give a construction that sheds light on the terms selected.
We will at times be justified in saying that a certain filter base, is base of some filter. Let B ∈ FBX
be an element in the set of all filter bases for X, and say hBi ∈ PPX consists of those sets A such that
F ⊆ A, for some F ∈ B. We note that B ⊆ hBi.
Proposition 11.6. The family hBi is a filter and we will say the filter base is B.
Proof. We only need to prove that condition B) in the definition of filter, holds. Take B ⊇ A ∈ hBi.
Then, there is F ∈ B such that F ⊆ A ⊆ B. This means B ∈ hBi.
Let FBX and FX represent the collections of filter bases and filters for X. Then, the last proposition
is simply stating that there is a function from FBX onto FX, because every filter is also a filter base
and the filter generated by any filter is itself. Two base filters that generate the same filter are called
equivalent bases. For any X ∈ U, we have FiltX : (FBX) → (FX), and FiltX B = hBi. All we have said
with respect to this is that for every F ∈ FX we also have F ∈ FBX and FiltX F = F .
Proposition 11.7. For any B ∈ FBX, we have hBi = B if and only if B ∈ FX.
What is more, for any filter base B we find that the filter FiltX B is the smallest filter that contains
the filter base.
Proposition 11.8. Let B ∈ FBX and F ∈ FX. If B ⊆ F , then B ⊆ hBi ⊆ F .
Principal Filter and Filter Generated by a Point It is clear that a family {F} consisting of one
non-empty set is a filter base. The filter generated from such a filter base is called a principal filter. Of
course, if we consider the inclusion order, we have h{F}i =↓ F.
Lemma. Let F ∈ F , then FiltX {F} ⊆ F .
From this, we get the following result, where we consider the filter as an index set by noting the
function F → PPX that makes F 7→ hFi = FiltX {F}.
Theorem 11.9. Any filter is the union of principal filters. In particular,
[
F =
hFi.
F∈F

In case we have F = {x}, for some x ∈ X, then we write hxi instead of the strict notation FiltX {{x}} =
h{{x}}i. These are called point generated filters.

80

CHAPTER III. SET THEORY

Cofinite Filter Consider the family of all finite subsets, of X, and denote it by F c . Then, the family
F = {F}Fc ∈F c , is called the cofinite filter of X. We are using F to represent the complement of F c .
Proposition 11.10. The cofinite filter of X is a filter of X.
Proof. First, we see that F c ∩ Gc = (F ∪ G)c , where F c , Gc ∈ F c . We know F ∪ G is finite because A, B
are finite. This proves that F c ∩ Gc ∈ F .
Now, let F ⊆ H. This means H c ⊆ F c , thus proving H c is finite.
Fréchet Filter Base and Filter Let I be a directed set and consider, for every i ∈ I, the set of
objects i that consists of all x ∈ I such that x ≤ i. Let i, j ∈ I, then we can find k ∈ I such that i, j ≤ k.
This means that kc is a subset of ic and jc . This proves that {ic }i∈I is the Fréchet filter base of I.
If {i}i∈I is a family of finite sets, then the cofinite filter of I is called the Fréchet filter of I and we
will write Fr(I) = {ic }i∈I .
Filter as a Directed Set A filter can easily be seen as a directed set, if we consider the partial order
PX, with arrows reversed. This new partial order can of course be written as P−1 X. That is why we
may say that a filter is downward directed.
We now give a proof for our assertion. Let F be our filter and define an order for this family, where
F ≤ G if G ⊆ F. We know we have a partial ordering and all that needs to be shown is that given
F, G ∈ F , we have H ∈ F such that F, G ≤ H. This follows from condition a) for filters.
Image The image of a filter base behaves in a good manner. By this we mean that functions send
bases into bases. However, filters are not sent into filters. They are sent into base filters, but this is not
a problem because we already have a construction that sends base filters into filters!
Proposition 11.11. Let f : X → Y be a set function. Also, let B ∈ FBX and F ∈ FX. Then
f [[B]], f [[F ]] ∈ FBY.
Proof. Take ( f F), ( f G) ∈ f [[B]], then there exist F, G ∈ B for which f F = ( f F) and f G = ( f G).
Therefore, ( f F) ∩ ( f G) = f F ∩ f G ⊆ f (F ∩ G) ∈ f [[B]]. In particular, this conclusion also holds for
filters in place of bases.
We will say that the generated image h f F i, of the filter F , is the filter generated by the corresponding image, which is a filter base; this is h f F i = FiltY f [[F ]].
The preimage of a filter base behaves well, under certain conditions.
Proposition 11.12. Let f : X → Y be a set function and B ∈ FBY. Then f −1 [[B]] ∈ FBX if and only if
F ∩ f X , ∅, for every F ∈ B.
Proof. If we suppose f −1 [[B]] is a filter base of X, then for every F ∈ B we have f −1 F , ∅. This
implies that there exists an x ∈ X such that f x ∈ F.
If ( f −1 F), ( f −1G) ∈ f −1 [[B]], then there exist F, G ∈ B such that ( f −1 F) ∩ ( f −1G) = f −1 F ∩ f −1G =
f −1 (F ∩ G) ∈ f −1 [[B]].
The generated inverse image of F ∈ FY is defined as h f −1 F i = FiltX f −1 [[F ]]; given, of course,
F ∩ f X , ∅, for every F ∈ F .

11. SPECIAL FAMILIES

81

Elementary Filter of a Net Given a net η : I → X, we can give a filter associated to it,
η[FiltX {ic }i∈I ]. This is nothing more than the direct image, under η, of the filter generated by {ic }i∈I .
In case we have a Fréchet filter, we will of course write η[Fr(I)]. In any case, the filter given is called
the elementary filter of η.
Ultrafilter We have seen how a filter is a partial order, that is filters have an internal order. Well it
turns out that the concept of filter gives rise to another type of order, an external order. This has already
been manifest in that we have enconutered a minimal filter hBi that contains B. In this paragraph we
will dedicate ourselves to the study of a special kind of maximal filters. In the next section we will
study the order defined on FX, using a more general definition of filter.
Definition 12. If B, C ∈ FBX are such that for every B ∈ B there is C ∈ C such that C ⊆ B then we say
C is finer than B, or that C is a refinement of B. This is represented by B  C.
A filter F is an ultrafilter if for every A ⊆ X we have A ∈ F or Ac ∈ F . The collection of ultrafilters
on a set X is UFX.
Proposition 11.13. The relation of refinement  is a preorder for FBX.
Proof. This follows from reflexivity and transitivty for set inclusion.
Proposition 11.14. Let F , G ∈ FX. Then F ⊆ G if and only if F  G.
Proof. Take F ∈ F ⊆ G, then for F ∈ G we have F ⊆ F.
Now suppose G is finer than F and let F ∈ F . We have G ⊆ F for some G ∈ G. Since G is a filter
we have F ∈ G.
Corollary. The relation  for filters is a partial order.
We do not generally have anti-symmetry for the refinement relation in FBX but we do have the
following important result.
Proposition 11.15. Let B, C ∈ FBX. Then B  C and C  B if and only if hBi = hCi.
Proof. Let F ∈ hBi. Then B  C is true if and only if there exists B ∈ B, and consequently C ∈ C, such
that C ⊆ B ⊆ F. Therefore F ∈ hCi and we may conlcude hBi ⊆ hCi.
Theorem 11.16. A filter F is ultrafilter if and only if for every G ∈ FX such that F ≤ G, then G = F .
Proof. Suppose F is an ultrafilter. Since  is a partial order relation, we only need to prove that G  F .
As we have just seen, this is equivalent to proving G ⊆ F . Let G ∈ G, then G or Gc are in F ; we cannot
have both in F because that would imply ∅ = G ∩ Gc ∈ F which is a contradiction to the definition of
filter. So, we suppose Gc ∈ F . Since G is finer than F we have H ∈ G such that H ⊆ Gc . This leads to
a contradiction because ∅ = G ∩ H ∈ G.
Now, we would like to show that F is an utrafilter, given the second condition. Let G be a filter
that contains F in the strict sense, F ≺ G. That is, there exists G ∈ G such that G < F . If it were the
case Gc ∈ F we would have H ∈ G, such that H ⊆ Gc , because G is finer than F , but this would imply
∅ = G ∩ H ∈ G. Therefore, no such G exists and F is maximal.
We see that the subcollection of ultrafilters absorbs under union of sets. Let us make a general and
fomal statement, for this last observation.

CHAPTER III. SET THEORY

82

Theorem 11.17. Let F , G be two filters on a set X such that F ∪G ∈ UFX, then F ∈ UFX or G ∈ UFX.
Also, if F ∈ UFX and G ∈ FX, then F ∪ G ∈ UFX given F ∪ G ∈ FX.
Proof. Suppose F ∪ G is an ultrafilter and G is not an ultrafilter. So we take F ⊆ X such that F, F c are
not both G; we have F ∈ F ∪ G or F c ∈ F ∪ G. From this it follows that F ∈ F or F c ∈ F .
Now let F be an ultrafilter and G a filter. Take H ⊆ X and suppose H < F ∪G, then H c ∈ F ⊆ F ∪G.
This means F ∪ G is an ultrafilter.
We have a similar result on the internal structure of filters.
Proposition 11.18. F ∈ UFX if and only if F ∪ G ∈ F implies F ∈ F or G ∈ F .
Proof. Let F be an ultrafilter and let F, G ⊆ X such that F ∪ G ∈ F . We know F or F c is in F , the
same is true of G, Gc . Of course we cannot have F c , Gc both in F .
Now suppose F ∪ G ∈ F ⇒ F ∈ F or G ∈ F for any F, G ⊆ X and any F ∈ FX. Consider the
special case F ∪ F c = X ⊆ X which means F ∈ F or F c ∈ F . We conclude F is an ultrafilter.
We give the easiest example of an ultrafilter in the following result.
Proposition 11.19. If x ∈ X then hxi =↓ {x} ∈ UFX and we call it a principal ultrafilter.
This is to say that a point generated filter is an ultrafilter.
Proposition 11.20. If F is an ultrafilter on a finite set X, then F is a principal ultrafilter.

§12 Zorn’s Lemma and the Axiom of Choice
Here, we will formulate the axiom in terms of partial order. Essentially, we will suppose that given a
partial order, we are able to take away objects and relations so as to build a new system that is a natural
order. Of course we can take away so few objects and relations so as to be left with an order that is not
necessarily natural. The important aspect of the way in which we will take away objects and relations
is that we can take away many enough to get a natural order but just enough so that if we take away any
less, then we don’t get a natural order.
Axiom of Choice. Given a non-trivial partial order P and a natural order N ⊆ P, there exists at least
one maximal natural order M such that N ⊆ M ⊆ P.
Maximality of M means that if Q ⊇ M is a natural order then Q = M. If we have a maximal
natural order then any upper bound of the natural order is the maximum. Having a natural order that is
maximal means we are not able to add any objects to it and conserve the status of natural order. This
means that any object we add will not be comparable with the objects of the order. Therefore, if M is
an upper bound we must have M in the natural order and we conclude it is the maximum.
Zorn’s Lemma. Suppose for every natural order N ⊆ P we have ↓ N , ∅. Then there exists a maximal
element in P.
Proof. If the partial order is trivial then we have maximal elements. Suppose it is not trivial, then there
is a natural order consisting of the comparabale objects x, y. We know that there is a maximal natural
order M ⊇ {x, y} and M has an upper bound, call it M. This object M is the maximum of M and it is
maximal in P because M is maximal.

IV | Universal Concepts
The topics we have covered in sequences and filters are of relation to a concept known as limit. The
notion of limit has been found to be most general in the setting of categories, and this is a case of
universal properties. We will see how instances of this occur when defining the functor of common
domain, and a bifunctor. We will discuss here, how filter limits arise from the general definition. We
will build the real number system, with the tools provided. Then, we will retake this subject in a later
chapter for topologies.
Although the general concept of comma category was not trivial to develop, it has arisen aleady in
certain occasions; we call them arrow categories. The instances in which it has appeared have been
very particular cases. Let f, g : C1 , C2 → D be two functors with common range. An arrow category
D(f, g) is a category such that the c-objects are all the arrows fa → gb, for any (a, b) ∈ O|C1 × O|C2 . The
arrows of D(f, g) are τ → σ : fa → gb −→ fc → gd, such that σ, τ; gi, fh for h, i : a, b → c, d.

83

84

CHAPTER IV. UNIVERSAL CONCEPTS

V | Lattice
In this chapter we will study certain partial orders that satisfy certain properties in regards to the their
bounds or supremum/infimum.
Lattices are a special type of order and one of the main reasons why it is special is that it can be
viewed as an algebraic structure. That is, the supremum concept of the order is described in terms of an
operation. Here, we will denote partial orders with L, or the like.
In a sense, we may think that the main idea behind this chapter is that the procedure of saying a is
greater than b, c is greater than a,... can be viewed as an operation.

§13 Supremum and Infimum
We recall that in the study of bounds we define a special bound, whether it be for upper/lower bounds.
These bounds are the supremum and infimum. Here we will write the supremum of {x, y} as x ∨ y, and
W
V
the infimum as x ∧ y. More generally, A = min ↓ A and A = max ↑ A. As we know, a set can be
W
V
written as A = {x} x∈A and in such cases we may write x∈A x = min ↓ A and x∈A x = max ↑ A.
Before moving on, we take on the problem of defining the supremum/infimum of empty set/universe.
Let us consider the empty set, first. The supremum is, by definition, the least among upperbounds of ∅.
W
We take the posture that, by default, any object is an upper bound of ∅, so that ∅ = min L = m. We
V
can just as easily say ∅ = max L = M. Now, consider the set of upper bounds of L; it is obviously
W
V
the maximum of L. Therefore, L = M, while L = m.
We provide some properties for supremum and infimum. The proof to the first three is trivial and
always follows directly from the definition. Result 4), in the next proposition, requires little knowledge
from sets, to reason.
Proposition 13.1. Let L be a partial order and A ⊆ B be subsets of L such that their supremum and
infimum exist.
1) For every a ∈ A we have

V

A≤a≤

2) For every x ∈ L, we have x ≤
3) For every x ∈ L, we have
4)

W

A≤

W

B and

V

B≤

V

W

V

W

A

A if and only if x ≤ a, for every a ∈ A.

A ≤ x if and only if a ≤ x, for every a ∈ A.

A.

85

CHAPTER V. LATTICE

86

§14 Lattice
W
Consider a partial order with a full operation : L → L f L that sends x 7→∨y x ∨ y = min ↓ {x, y}. All
this means is that the supremum exists for every pair of objects in the order and we make a commutative
V
operation from this. If we are also able to build
: L → L f L, for the infimum, we say that L is a
lattice. Let us be more specific. Take a lattice L and H ⊆ L, where x ∨ y ∈ H, for every x, y ∈ H.
Then H is called an upper sublattice. If, instead, the infimum exists for every pair, we have a lower
sublattice. In the case H is both upper and lower sublattice of L, we simply say H is sublattice of L.
Consider a bounded partial order; we will seek properties of unit. For the supremum, we have as
unit, the minimum. That is, x ∨ m = x. In case of the infimum operation, the operation has M for
unit, this is, x ∧ M = x. Also, for the supremum, we have x ∨ M = M, and for the infimum operation,
x ∧ m = m. The reader should be able to relate this with the situation encountered in sets.
Recall that the left and right operations of a given object are functions. The following result leaves
it clear that a given object may be invariant under more than one right/left operation.
Proposition 14.1. Let L be a lattice, then x ≤ y if and only if x ∨ y = y and x ∧ y = x.
Proof. If x ≤ y, then y is a the maximum of {x, y} and x is the minimum. We conclude x ∨ y = y and
x ∧ y = x. On the contrary, if x ∨ y = y we know that y is an upper bound of {x, y} which gives x ≤ y.
Proposition 14.2. The functions ∨x, ∧x, of a lattice, preserve the order.
Proof. Suppose x ≤ a ≤ b, then a ∨ x = a ≤ b = b ∨ x. If a ≤ x ≤ b, then a ∨ x = x ≤ b = b ∨ x.
Finally, a ≤ b ≤ x implies a ∨ x = x = b ∨ x.
The next proposition gives a special case of proposition (14.1). We will say that a constant function,
for some object x ∈ Range f , is the function onto x. Also, the compositions ∨x ◦ ∧x and ∧x ◦ ∨x
are the constant function that sends every a ∈ L into x and manifests that the supremum and infimum
operations are commutative and associative. If we have an operation ∗ : O → O f O, such that for some
object e of O, the notation yields e; e, e, then we will say e is a primitive unit for ∗.
Proposition 14.3. For any lattice L, and any a, b ∈ L, we have
1) a is primitve unit under both operations.
2) The functions ∨a ◦ ∧a and ∧a ◦ ∨a are the function onto a.
3) Both operations are commutative.
4) Both operations ae associative.
W
W
Proof. From 1), we have a = a ∨ a = {a, a} ≤ {a, b} = a ∨ b, because {a, a} = {a} ⊆ {a, b}. Using
proposition (14.1) in the last inequality proves the first part of 2); the second part is similar.
Proposition (14.2) gives a ∨ y ≤ (x ∨ a) ∨ y and x ≤ x ∨ y ≤ (x ∨ a) ∨ y. We use (14.2) and the first
inequality, then we use (14.1) and the second inequality to prove
x ∨ (a ∨ y) ≤ x ∨ [(x ∨ a) ∨ y]
= (x ∨ a) ∨ y
We can just as easily say (x ∨ a) ∨ y ≤ x ∨ (a ∨ y).

15. SEMILATTICE AND ALGEBRAIC ASPECTS

87

The following result states that the supremum of a finite union of sets, is supremum of supremums.
Proposition 14.4. If (Ai )ni=1 is a sequence of bounded subsets of a lattice, then their union is also
bounded and
n W
n
W
WS
Ai
Ai =
1)
i=1

i=1

2)

n
VS

i=1

Ai =

n V
V

Ai .

i=1

W W
W
W
Proof. Let A, B ⊆ L, then A, B ≤ A∨ B; this follows from 4) in proposition (13.1). Therefore,
W
W
W
W
every object in the union is less than or equal to A ∨ B. This means that A ∨ B is an upper
W
W
W
bound of A ∪ B, and we conclude (A ∪ B) ≤ A ∨ B.
W
We wish to prove the other inequality and it is sufficient to prove (A ∪ B) is greater than or equal
W
W
to A and B; this also follows from 4).

We give a characterization of the supremum in terms of the 3-diagram; the result will be rather
useful dealing with supremum and infimum. This result inverts 2) and 3) in proposition (13.1).
Proposition 14.5. Let L ⊆ N, be a lattice, subset of a natural order N.
W
W
1) For every x ∈ L, we have x ≤ A if and only if there exists a ∈ A such that x ≤ a ≤ A.
V
V
2) For every x ∈ L, we have A ≤ x if and only if there exists a ∈ A such that A ≤ a ≤ x.

Proof. Let L ⊆ N, be a lattice, subset of a natural order N.
W
x ≤ A means x is not an upperbound of A. So then we know that there is some element a ∈ A
such that x is not greater than it. But, a, x are comparable so that x ≤ a.
The proof of 2) is similar.
One can see that it is crucial to have a natural order, otherwise we cannot assure comparability for
the objects in the proof.

§15 Semilattice and Algebraic Aspects
A semilattice is a, commutative, associative category with every object as a primitive unit. A semilattice
with unit is a commutative algebraic category with every object as a primitive unit. When we describe
a lattice as an algebraic structure, we will consider two, dual, semilattices.

15.1 Order of a Semilattice
A semilattice always has an order defined in terms of the operation. Let ⋄ be the operation of the
semilattice. We define an order on the collection of objects, x ≤ y if and only if x; y, y. In this case,
our operation will act as the supremum of the order. We could have just as well said that the order is
defined by y ≤ x if and only if x; y, y and in such instance the operation is infimum.
Proposition 15.1. A semilattice L defines two, opposite, partial orders and the operation acts as supremum or infimum, respectively.

CHAPTER V. LATTICE

88

Proof. We will first prove that the semilattice defines the supremum operation. Let x, y ∈ L, we wish
to prove x ∨ y = x ⋄ y. It is quite obvious that x ⋄ (x ⋄ y) = x ⋄ y means x ≤ x ⋄ y. Of course, we also
have y ≤ x ⋄ y and therefore x ∨ y ≤ x ⋄ y. On the other hand, (x ∨ y) ⋄ (x ⋄ y) = [(x ∨ y) ⋄ x] ⋄ y = x ∨ y
because of associativity and the definition of the order; this means that x ⋄ y ≤ x ∨ y. We have associated
an order to ⋄, such that ⋄ is the supremum operation of the order.
The order just used is defined as x ≤ y if x; y, y and we denote it by L, as well. The order that is
defined as y ≤ x, under the same conditions, is the opposite order Lop . Now we wish to prove that ⋄
acts as infimum for Lop . From x ⋄ (x ⋄ y) = x ⋄ y we get x ⋄ y ≤ x, and similarly x ⋄ y ≤ y. Finally, to
prove that x ∧ y = x ⋄ y we need only show that x ∧ y ≤ x ⋄ y. We again have (x ∧ y) ⋄ (x ⋄ y) = x ∧ y,
so we are done.
In this last result we see a strong relation between supremum and infimum; namely, supremum and
infimum are the same operation on opposite orders. Further on, we shall establish a more precise statement to this observation, in terms of a functor. The following theorem states every lattice determines
two semilattices.
Proposition 15.2. Let L be a partial order such that the least upper bound exists for every pair of
objects, then the supremum operation defines a semilattice.
A similar remark holds if the greatest lower bound exists for every pair.
Proof. We know that the operation of supremum is commutative and associative. Also, it is easily seen
that any object in the partial order is a primitive unit.

15.2 Lattice as an Algebraic Structure
What we have done is to show that an order can induce a pair of operations that have a certain algebraic
aspect to them. Two semilattices, on the same collection of objects, with operations ⋄, ♦, are dual if
they satisfy condition 2) of proposition (14.3).
Proposition 15.3. Two dual semilattices of operations ⋄, ♦ verify x ⋄ y = y if and only if x♦y = x.
Proof. Let the conditions of proposition (14.3) hold for the operations. We have x♦y = x♦(x ⋄ y) = x.
If x♦y = x, then we can say x ⋄ y = (x♦y) ⋄ y = y becuase of commutativity in the operations.
Now we will see that the algebraic implications of the lattice are actually determinant in the structure
of a lattice. That is, if we have an associative category, for two operations that satisfy 1)-4) of (14.3),
then we have a lattice. This following result holds if L is replaced with an associative category, but in
such cases the order will not be bounded.
Theorem 15.4. Let ⋄, ♦ be two dual semilattices, both with unit and both on the collection L, and define
an order such that x ≤ y if and only if x ⋄ y = y. Then the order is a lattice with x ∨ y = x ⋄ y and
x ∧ y = x♦y. Additionally, the units are maximum and minimum of the order.
If L is a bounded lattice, then we have two dual semilattices. The operations for these are supremum
and infimum; the maximum and minimum are units.
Proof. From proposition (15.1) we can say that ⋄ is supremum, on the order defined by x ≤ y if
x; y, y. By the same proposition, the operation ♦ is the supremum or infimum, on the order already
defined. Because of proposition (15.3) and duality of operations, we know that x♦y = x; therefore ♦

16. COMPLETENESS

89

is the infimum. This proves that supremum and infimum are full operations because the operation of a
semilattice is full.
Using proposition (15.2) we have two sublattices defined by supremum and infimum. Since supremum and infimum satisfy condition 2) of proposition (14.3), which means the sublattices are dual. It is
not difficult to see that minimum and maximum of orders are units for supremum and infimum, respectively. In fact, one can also prove that minimum absorbs infimum and maximum absorbs supremum.

§16 Completeness
In this section we develop notions that guarantee some existence of supremum.

16.1 Complete Partial Order
The concept of completeness is best studied for a lattice in terms of the order, and not the operation.
Therefore, before we introduce completeness in the context of lattice, we will give definitions for partial
order. First, we establish a notion for diected subsets of a partial order. After this, we do so for bounded
subsets of the order. The following proposition will help prove some results in this section.
Proposition 16.1. The following are equivalent statements
1) The maximum of A exists
2) The supremum of A exists and
3) The supremum of A exists and

W

W

A = max A
A ∈ A.

Proof. The maximum is upper bound and if any other object is greater than the maximum, it fails to be
in the set. This means that 1) implies 2). Of course 2) implies 1), trivially. To verify 2) implies 3), we
simply note that max A ∈ A. If 3), then 2) is true; the supremum is greater than every x ∈ A.
Directed Complete If L is a directed set, it is a non-empty partial order such that for every pair
of objects x, y ∈ L we have ↓ {x, y} , ∅. The definition of semilattice, is more specific, requiring that
min ↓ {x, y} exist for every pair. We can conclude that a partial order which is not a directed set, cannot
be a semilattice either.
Let DL be the non-empty collection of directed subsets of some partial order L. Suppose we have
a function DL ⊆ PL → L that sends every object in the domain into its supremum; we are of course
making it implicit that the supremum exists for every directed subset of the order. In such cases we
say that L is directed complete. If, additionally, L has a minimum, we say it is a complete partial
order. We restate this: a partial order is complete if and only if it has a minimum and there is a function
W
sup : DL → L such that I 7→sup
I. This can be stated in terms of the infimum operation if we
consider the opposite order. Since the set I is directed, for every x, y ∈ Lop we have k ∈ Lop such
that k ≤ x, y. By proposition (15.1) we conclude that the order has a maximum and there is a function
V
inf : DLop → Lop such that I 7→inf I.
We recall that a set L is finite if there a bijective function n → L, for some n ∈ N.
Proposition 16.2. If L is a finite partial order, then it is directed complete.

90

CHAPTER V. LATTICE

Proof. To prove that the order is directed complete, we take any directed subset I ⊆ L. The set is finite
so we know that there is finite sequence of the form n → L. We represent I with (xi )ni=1 and since it is
directed, for every pair xi , x j ∈ I, we have xi , x j ≤ xk ∈ I.
Take x1 , x2 and find xk1 such that x1 , x2 ≤ xk1 . Suppose xk1 is not maximum of I. Then there is xk2
such that xk1 , x3 ≤ xk2 and xk1 < xk2 . If xk2 , max I, then there is xk3 such that xk2 , x4 ≤ xk3 and xk1 <
xk2 < xk3 . We can continue in this manner and if we get to xn , then xk1 < xk2 < · · · < xkn−1 < xn = max I.
There is, however, the possibility that we find max I = xkm at some step m < n. This means that there is
W
a function sup : DL → L that makes I 7→sup max I = I; use proposition (16.1).
Naturally Complete We say that a partial order P is naturally complete if and only if every natural
order N ⊆ P has supremum. That is, if min ↓ N exists for every N. Zorn’s lemma is applied to a partial
order whose natural orders are bounded; ↓ N , ∅ for every N. Thus, we can apply Zorn’s lemma to
any naturally complete order and conclude that it has a maximal element.
There is a more particular definition, and it will be useful since it will help to take the concept of
completeness into the realm of sequences. Define the collection IS L of all natural order N ⊆ L such
that there exists a functor s : N → N; this means that we are considering the collection of natural orders
that can be arranged in a growing sequence. If there is a function sup : IS L ⊆ PL → L, we will say L
is IS-complete.
Proposition 16.3. If L is directed complete, then it is also naturally complete. This last implies that L
is IS -complete.
No proof is needed for this last result; this is not the case is the next result, however.
Proposition 16.4. A partial order L is naturally complete if and only if min Inv F exists for every
functor F : L → L.
Bounded Complete If we are to consider a lattice that is not bounded, the question may arise:
does supremum and infimum exist for the bounded subsets of the lattice? We are compelled to make
definitions in such direction, and we do so in the same manner as we did in the last subdivision. A
partial order is upper bound complete if and only if ↓ A , ∅ implies the existence of min ↓ A, for any
A ⊆ P. We also define the dual concept of lower bound complete for partial orders such that ↑ A , ∅
implies the existence of max ↑ A.
Proposition 16.5. A partial order is upper bound complete if and only if it is lower bound complete.
Proof. Let us prove P is lower bound complete, given that it is upper bound complete. Let A , ∅ such
W
that ↑ A , ∅. We know ↑ A exists given ↑ A is bounded above. Since A , ∅ we know that ↑ A is
V
W
bounded above by some a ∈ A. Now we show that A =
↑ A. First of all, if x is upper bound of
W
W
↑ A, then ↑ A ≤ x. Since any object of A is upper bound of ↑ A, we have ↑ A ≤ x, for all x ∈ A.
W
This is equivalent to saying ↑ A ∈↑ A, and if we recall proposition (16.1) we see that it is the same
W
as ↑ A = max ↑ A.

This means that there is maximum and minimum if the order is upper or lower bound complete. In
light of the previous proposition, we say L is bounded complete if it is upper or lower bound complete.
Given a set L, let us define an order, for the objects of L f L, by f ≤ g if there exists A ⊆ L such
that f is the function g|A ; we are defining an order in terms of complicated versions of systems.

16. COMPLETENESS

91

Proposition 16.6. The order defined for L f L is complete and bounded complete.
Proof. If we are to show that the order is complete we must prove it is directed complete and there is
a minimum. Let I ⊆ L f L be directed; this is I ∈ DL f L . If f, g ∈ I we have h ∈ I such that f, g ≤ h,
which means f, g are h|A , h|B , respectively for sets A, B ⊆ L. So, if a ∈ Dom f ∩ Dom g we have
S
a, g; a, f . Thus, for any a ∈ i∈I Dom i we can write Ia in place of the image, under any function of I
S
that is defined for a. Consider the set function sup I : i∈I Dom i → L that makes a 7→ Ia.
W
We shall prove that sup I = I. It is not difficult to see that sup I is an upper bound of I. This is,
S
every i ∈ I is a simplified version of sup I. If f < sup I, then there exists a ∈ i∈I Dom i − Dom f .
This object is in some g ∈ I. For this, f is not an upper bound of I and we may conclude that there is a
function sup : DL f L → L f L that sends every object in the domain into its supremum. The minimum
of this order is the function min L f L : ∅ → L.
We are left to prove the order is bounded complete. Take a set X ⊆ L f L that is bounded by above;
there is h ∈↓ X such that every function x ∈ X is a simplified version of h. We can restate this saying
S
every x ∈ X is of the form h|Ax . Denote with sup X : x∈X A x → L the function that is a simplified
W
version of h; the arrows are a 7→ ha. Proving sup X =
X is similar to what was done above.

16.2 Complete Lattice
The main idea in the concept of complete lattice is that any subset of a lattice has supremum and
infimum. We now give a duality for supremum and infimum. Consider any function sup ∈ (PL) f L
W
such that A 7→sup A. The function is order preserving; this follows from 4) in proposition (13.1).
W
A, we are able to construct
Theorem 16.7. Given a function sup : PL → L, such that A 7→sup
V
inf : PL → L, such that A 7→inf
A, for every A ⊆ L. In other words, inf A = sup ↑ A and
sup A = inf ↓ A.
Moreover, sup is order preserving and inf is order reversing.
Proof. We will show that infimum is sup ↑ A. Let x ∈ A, then x is an upper bound of ↑ A. This means
W
sup ↑ A ≤ x. Therefore, sup ↑ A is a lower bound of A; this is equivalent to ↑ A = sup ↑ A ∈↑ A.
W
W
V
Recall that A ∈ A if and only if A = max A, so that A = max ↑ A = sup ↑ A.
The reader can just as easily prove that sup A = inf ↓ A. The second part of this result is 4) from
proposition (13.1).
A partial order that has functions sup and inf is a complete lattice. Of course, any complete lattice
is a lattice. We see that complete lattices are, trivially, bounded complete.
Proposition 16.8. Let L be a complete lattice, then L and Lop are directed complete.
Proof. By definition, a complete lattice is obviously directed complete. Since L is complete, we know
that the infimum of every subset exists. But, this is the same as saying that the supremum exists for
every subset of Lop . In particular, the supremum exists for every directed subset and therefore Lop is
directed complete.

92

CHAPTER V. LATTICE

VI | Group
§17 Subcollections
We will sometimes express G instead of the collection of objects of operation, A|G. Given a group G,
we can consider systems obtained from G by taking away objects of operation. These systems are the
object of study in the present discussion.

17.1 Power operation
We define an operation such that source and target objects are the objects of operation of G. It is a
non-commutative operation; that is why sometimes we decide to treat it as an ordered collection of
functions. We define this operation in a way that generalizes the definition of product in terms of sum.
Given a group G and any object x, in Z, let ↑ x : G → G. For x ≥ 0, we define a; a↑ x ∗ a, x + 1
and a; (a x )−1 , −x. We accept a; 1, 0 which means a↑ 0 is the unit of the group, for every object a of G
that is not the unit. In case G is abelian, we have a functor ↑ x : G → G. To prove this, we must prove
↑ ↑
x, x; ∗(b↑ x), ∗b. We see that the relation holds for 0, so now we shall verify it holds for x + 1, given it
holds for x.
a∗b
a∗b
a∗b
a∗b

;
;
;
;

[(a ∗ b)↑ x] ∗ (a ∗ b), x + 1
[(a↑ x) ∗ (b↑ x)] ∗ (a ∗ b), x + 1
[(a↑ x) ∗ a] ∗ [(b↑ x) ∗ b], x + 1
[a↑ (x + 1)] ∗ [b↑ (x + 1)], x + 1.

So, we are defining a function Z → GFG, which is an operation that we will call the power
operation of G. Notice that this operation is almost full, in fact, for it to be full we only need to define
1 ↑ 0 but there is no consistent way so we leave the operation as it is. If e is a primitve unit, then for all
x ∈ N, we have e; e, x.
The product operation, defined for integers, is the power for Z. We note this because a; a· x+a, x+1.
We now wish to find the power operation of Q. We see that this is the operation ↑ : Z → QFQ, where
we define a; a x · a, x + 1.

17.2 Subgroup
For any subcollection A, of a group G, and n ∈ Z, we will write An to represent the collection of objects
of the form a↑ n, where a is any object of A. We write AB to express the collection of all objects of the
form a ∗ b, where a, b ∈ A, B. For any group, G = G−1 . A subgroup of G is a group H such that H ⊆ G.
The collection of all subgroups of G is represented by G⊆ .
93

CHAPTER VI. GROUP

94
Theorem 17.1. The following are equivalent statements
1) H ∈ G⊆
2) HH −1 ⊆ H
3) H 2 , H −1 ⊆ H

Proof. It is clear from the definition of a group, that 1) ⇒ 2), 3). We shall prove 2), 3) ⇒ 1). Supposing
3) to be true, we find HH −1 ⊆ H 2 ⊆ H. So, all we need to prove is 2) implies 1). Suppose H has at least
one object x:
x ; 1, x−1
1 ; x−1 , x−1
x ; x · y, (y−1 )−1
These three statements indicate 1, x−1 , x · y are all objects of HH −1 ⊆ H.
Theorem 17.2. Let a x ⊆ G represent the collection of objects of such form, for fixed a ∈ G and every
x ∈ Z. Then a x is an abelian subgroup of G.
Proof. First we will prove cummutativity with a, and then we will prove a x (a x )−1 ⊆ a x . Due to the last
theorem, this proves a x is a group. After that we will verify commutatvity.
1) Suppose that for the product we have a, a; an, an:

a
a
a
a
a
a, a

;
;
;
;
;
;

a ∗ an+1 , an+1
a ∗ (an ∗ a), an+1
(a ∗ an ) ∗ a, an+1
(an ∗ a) ∗ a, an+1
an+1 ∗ a, an+1
an+1 , an+1

2) Given n, suppose an ; an−m , a−m , for any m:

an+1
an+1
an+1
an+1
an+1
an+1

;
;
;
;
;
;

(an ∗ a) ∗ a−m , (am )−1
(a ∗ an ) ∗ a−m , (am )−1
a ∗ (an ∗ a−m ), (am )−1
a ∗ an−m , (am )−1
an−m ∗ a, (am )−1
an−m+1 , (am )−1

17. SUBCOLLECTIONS

95

3)
an
an
an
an
an , an

;
;
;
;
;

an ∗ a−m , a−m
an−m , a−m
a−m+n , a−m
a−m ∗ an , a−m
a−m , a−m

17.3 Congruence Class
Given an equivalence relation ↔ for a collection A, carry out a seperation of this system, without losing
information. The systems obtained are the subcollections of all equivalent objects. That is, we have all
simple equivalence relations. For objects of the same simple equivalence relation we will express
a≡b

mod ↔ .

Let H ∈ G⊆ , and define a ∼ x if h; a, x for some h ∈ H. This is, the collection of objects x such
that we have an arrow h →∗x a. In other words, x such that its right operation has an arrow with source
object in H and target is a.
Theorem 17.3. The relation ∼ is an equivalence relation and a ∼ b will be expressed by
a ≡ b mod Hx.
Each simple equivalence relation resulting from ∼ will be called a right congruence class. Every right
congruence class is the subcollection Hx, for any x in the class. For every x ∈ G, the subcollection Hx
is the right congruence class that contains x and, in particular, H is a congruence class.
Proof.
1) We will prove ∼ is indeed an equivalence relation. It is obvious that the reflexive property holds;
if we take h to be the unit of G we have h; a, a. To prove symmetry, suppose h; a, b:
h−1 ; h−1 ∗ (h ∗ b), a
h−1 ; (h−1 ∗ h) ∗ b, a
h−1 ; b, a.
The result follows from h−1 ∈ H. Finally, let h1 , h2 ∈ H such that h1 ; a, b and h2 ; b, c. From this,
h1 ∗ h2
h1 ∗ h2
h1 ∗ h2
h1 ∗ h2
We may conclude because h1 ∗ h2 ∈ H.

;
;
;
;

(h1 ∗ h2 ) ∗ c, c
h1 ∗ (h2 ∗ c), c
h1 ∗ b, c
a, c.

CHAPTER VI. GROUP

96

2) Let x be an element of a right congruence class. Then, a ∈ Hx ⇔ h; a, x ⇔ h−1 ; x, a ⇔ a is
in the right congruence class of x.
If x ∈ G, then x is in some right equivalence class; this is guaranteed by the reflexive property.
But this class is the subcollection Hx, because x is an object of it.

Theorem 17.4. There is a bijective function H → Hx, for every x ∈ G.
Proof. Our bijective function is ∗x. Let y ∈ Hx, then there is a unique solution to h; y, x, for h. This
means ∗x is monic and onto Hx.
It is clear that we still have work to do in the subject matter of congruence classes. We can take an
analogous path to prove similar theorems for the left congruence class, xH. The equivalence relation in
this context is given by a ∼ x if x; a, h. Similar theorems hold for the left congruence class. Of course
this is the collection of objects x ∈ G such that x →∗h a, for some h ∈ H.

17.4 Invariant subspace
A subgroup N ⊆ G is called invariant or normal if xN = N x, for every x ∈ G. Simply put, it is any
subgroup such that the equivalence relation it defines yields the same right and left congruence classes.
The collection of all invariant subgroups of G is denoted by Ĝ⊆ .
Theorem 17.5. The following are equivalent:
1) xN = N x, for every x ∈ G.
2) xN x−1 = N, for every x ∈ G
3) xN x−1 ⊆ N, for every x ∈ G.
Proof.
1)⇒2) For n1 ∈ N, we find n2 ∈ N such that
x ∗ n1
x ∗ n1
x ∗ n1
x ∗ n1

;
;
;
;

(x ∗ n1 ) ∗ x−1 , x−1
(n2 ∗ x) ∗ x−1 , x−1
n2 ∗ (x ∗ x−1 ), x−1
n2 , x−1

which proves that xN x−1 ⊆ N. Now, to prove N ⊆ xN x−1 :

n1 ; n1 ∗ (x ∗ x−1 ), 1
n1 ; (n1 ∗ x) ∗ x−1 , 1
n1 ; (x ∗ n2 ) ∗ x−1 , 1.

18. QUOTIENT GROUP

97

3) ⇒ 1) We wish to prove xN ⊆ N x:

x
x
x
x

;
;
;
;

(x ∗ n1 ) ∗ 1, n1
(x ∗ n1 ) ∗ (x−1 ∗ x), n1
[(x ∗ n1 ) ∗ x−1 ] ∗ x, n1
n2 ∗ x, n1 .

Similarly, we verify N x ⊆ xN.

§18 Quotient group
Given an invariant subgroup N, consider the collection of congruence classes. We say congruence
classes because the classes on the right and left are the same. Thus, we can write
a≡b

mod N

if there is an n ∈ N such that n; a, b. We see that every class N x is related to N in the same manner,
so we will consider each class to be a reflexive arrow for N. Let G/N be the algebraic category with
one c-object, N, and objects of operation are the congruence classes. The operation for the classes is
defined by N x; N(x ∗ y), Ny. It is left to the reader to verify that the definition is consistent.
Theorem 18.1. The algebraic category G/N is a group. Moreover, if G is abelian so is G/N.
Proof.
1) We first verify that the operation has a unit and the objects are dual to it. After that we will prove
associativity. The unit in G/N is the invariant subspace N = Ne:

N x ; N x ∗ Ne, N
N x ; N(x ∗ e), N
N x ; N x, N.
Duality amongst the objects is determined by

N x ; N x ∗ N x−1 , N x−1
N x ; N(x ∗ x−1 ), N
N x ; Ne, N x−1 .
We turn to associativity:

CHAPTER VI. GROUP

98

Na
Na
Na
Na
Na
Na, Nc

;
;
;
;
;
;

Na ∗ N(b ∗ c), Nb ∗ Nc
N[a ∗ (b ∗ c)], Nb ∗ Nc
N[(a ∗ b) ∗ c], Nb ∗ Nc
N(a ∗ b) ∗ Nc, Nb ∗ Nc
(Na ∗ Nb) ∗ Nc, Nb ∗ Nc
Na ∗ Nb, Nb ∗ Nc.

2) Supposing G is abelian:

Na
Na
Na
Na, Na

;
;
;
;

N(a ∗ b), Nb
N(b ∗ a), Nb
Nb ∗ Na, Nb
Nb, Nb

We will now construct the two trivial quotient groups of G, obtained by considering N to be the
subgroup that consists of the unit, and the subgroup G. The quotient group G/1 is the same group as G.
We verify this because we only have one solution to 1; x, y, for y. The solution is x and that means all
the relations are reflexive:
x ≡ x mod 1.
Another way of seeing this is by finding the class of x by xe. In other words, every x ∈ G is its
congruence class.
If we turn to find G/G, we see its the subgroup e. This is true due to the fact that we always have a
solution h ∈ G for h; x, y. That is any x, y ∈ G are related. We also see that this is due to Gx = G.

§19 Commutator
We go on to study the more general cases of an abelian group, in which not necessarilly all objects of
operation commute with all the rest.
We know that the inverse of an object a ∗ b is unique and we find it by
a∗b
a∗b
a∗b
a∗b
a∗b

;
;
;
;
;

(a ∗ b) ∗ (b−1 ∗ a−1 ), (b−1 ∗ a−1 )
a ∗ [b ∗ (b−1 ∗ a−1 )], (b−1 ∗ a−1 )
a ∗ [(b ∗ b−1 ) ∗ a−1 ], (b−1 ∗ a−1 )
a ∗ a−1 , (b−1 ∗ a−1 )
e, (b−1 ∗ a−1 ).

For the following definition, note that a, b commute if and only if (a ∗ b); e, (a−1 ∗ b−1 ).

19. COMMUTATOR

99

Definition 13. Define the operation  : G → G f G such that ab 7→ (a ∗ b) ∗ (a−1 ∗ b−1 ), for a, b ∈ G.
The image of b, under a is [a, b] and we call it the commutator of a, b. In other words, the notation for
∗ expresses a ∗ b; [a, b], a−1 ∗ b−1 . The object a is said to be commutable if a : G → G is the function
into e. Define Comm(G) as the subcollection of commutable objects and call it the center of G.
Notice that the center of G is, by definition, the fiber corresponding to the function into e. That is,
if we represent the function into e with → e, then Comm(G) = −1 [→ e]
Proposition 19.1. The center of G verifies the relation Comm(G) ∈ G⊆ and we say it is the central
subgroup of G.
Proof. Take a ∈ Comm(G) and b−1 ∈ [Comm(G)]−1 . We shall verify [a ∗ b−1 , x] is e, for every x ∈ G.
(a ∗ b−1 ) ∗ x
(a ∗ b−1 ) ∗ x
(a ∗ b−1 ) ∗ x
(a ∗ b−1 ) ∗ x
(a ∗ b−1 ) ∗ x

[(a ∗ b−1 ) ∗ x] ∗ [(b ∗ a−1 ) ∗ x−1 ], (a ∗ b−1 )−1 ∗ x−1
[(a ∗ b−1 ) ∗ b] ∗ [(x ∗ a−1 ) ∗ x−1 ], (a ∗ b−1 )−1 ∗ x−1
(a ∗ x) ∗ (a−1 ∗ x−1 ), (a ∗ b−1 )−1 ∗ x−1
(x ∗ a) ∗ (a−1 ∗ x−1 ), (a ∗ b−1 )−1 ∗ x−1
e, (a ∗ b−1 )−1 ∗ x−1 .

;
;
;
;
;

We have shown that a ∗ b−1 is commutable; this proves Comm(G) ∈ G⊆ .
Proposition 19.2. If C ⊆ Comm(G) is a subgroup, then C ∈ Ĝ⊆ ; we say C is a central invariant
subgroup of G.
Proof. Observe xC = Cx, for any x ∈ G.
We now build the collection generated by the commutators of G. Take the collection of all commutators [a, b], this is the subcollection [x, y]x,y∈G . We recall the notation Λ([x, y]x,y∈G ), where Λ is
the generailzed operation function of the operation of the group, represents the image of all the operators Λni=1 in the image of Λ. We will represent it with [G, G]. Of course, if a group contains all the
commutators, it also contains [G, G].
Proposition 19.3. The subcollection [G, G] ⊆ G is called the commutant of G and [G, G] ∈ Ĝ⊆ .
Proof. We first want to prove that [G, G] is a subgroup. We will give a proof that [G, G]2 and [G, G]−1
Q
Q
are subcollections of [G, G]. If c, d ∈ [G, G] then they can be represented by mi=1 Ci and nj=1 D j ,
where Ci , D j are all commutators of G. This means c ∗ d is of the same form as each of the factors c, d.
Q
For the second part, we can easily find the inverse of ni=1 xi , for xi ∈ G, by the following. Suppose
Qn −1
Qn
i=1 xn+1−i . Then, we find
i=1 xi ; e,
 n 
 
 n+1
 n+1
n+1
Y
Y 
  −1 Y
 Y −1
−1
xi ; 
xi  ∗ xn+1  ∗  xn+1 ∗ 
xn+2−i  ,
xn+2−i
i=1

i=1

xi

n+1
Y

xi ; e,

i=1

i=1

i=2

 n+1
 n   n
Y  Y −1  Y
x−1
xn+1−i  ,
xi  ∗ 
; 
n+2−i

n+1
Y

i=1
n+1
Y
i=1

i=1

x−1
n+2−i .

i=1

i=1

CHAPTER VI. GROUP

100
If [a, b] ∈ [x, y]x,y∈G , then [a, b]−1 ∈ [x, y]x,y∈G . In fact,
(a ∗ b) ∗ (a−1 ∗ b−1 )
(a ∗ b) ∗ (a−1 ∗ b−1 )
(a ∗ b) ∗ (a−1 ∗ b−1 )
(a ∗ b) ∗ (a−1 ∗ b−1 )
(a ∗ b) ∗ (a−1 ∗ b−1 )

[(a ∗ b) ∗ (a−1 ∗ b−1 )] ∗ [(b ∗ a) ∗ (b−1 ∗ a−1 )], (b ∗ a) ∗ (b−1 ∗ a−1 )
[(a ∗ b) ∗ a−1 ] ∗ [a ∗ (b−1 ∗ a−1 )], (b ∗ a) ∗ (b−1 ∗ a−1 )
(a ∗ b) ∗ (b−1 ∗ a−1 ), (b ∗ a) ∗ (b−1 ∗ a−1 )
a ∗ a−1 , (b ∗ a) ∗ (b−1 ∗ a−1 )
e, (b ∗ a) ∗ (b−1 ∗ a−1 )
Q
−1
We can now say c−1 ∈ [G, G] because c−1 ; ni=1 Cn+1−i
, e.
Q
Next we need to prove [G, G] is invariant. It is easy to see that x ∗ c ∗ x−1 ; ni=1 x ∗ Ci ∗ x−1 , e. Also,
x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]

;
;
;
;
;

;
;
;
;
;

(x ∗ [a, b]) ∗ x−1 , x−1
[x ∗ (a ∗ b) ∗ (a−1 ∗ b−1 )] ∗ x−1 , x−1
x ∗ (a ∗ x−1 ) ∗ (x ∗ b) ∗ (x−1 ∗ x) ∗ (a−1 ∗ x−1 ) ∗ (x ∗ b−1 ) ∗ x−1 , x−1
(x ∗ a ∗ x−1 ) ∗ (x ∗ b ∗ x−1 ) ∗ (x ∗ a−1 ∗ x−1 ) ∗ (x ∗ b−1 ∗ x−1 ), x−1
(x ∗ a ∗ x−1 ) ∗ (x ∗ b ∗ x−1 ) ∗ (x ∗ a ∗ x−1 )−1 ∗ (x ∗ b ∗ x−1 )−1 , x−1

This means that x ∗ [a, b] ∗ x−1 is the same as [xax−1 , xbx−1 ] ∈ [x, y]x,y∈G . This is, x ∗ c ∗ x−1 ∈ [G, G].
The commutant of G turns out to be a special subgroup. We cannot say [G, G] is abelian. However,
it does generate an abelian quotient group and it is the smallest subgroup of G to do so.
Theorem 19.4. Let N ∈ Ĝ⊆ . Then
1) G/[G, G] ∈ AbG⊆
2) G/N ∈ AbG⊆ ⇒ [G, G] ⊆ N
3) [N, N] ∈ Ĝ⊆ .
Proof.
1) To prove that G/[G, G] is a commutative subgroup of G we take [G, G]a and [G, G]b, for some
a, b ∈ G. We will show that their commutator is [G, G], the unit in G/[G, G].

[G, G]a ∗ [G, G]b ; [G, G](a ∗ b) ∗ [G, G](a−1 ∗ b−1 ), [G, G]a−1 ∗ [G, G]b−1
[G, G]a ∗ [G, G]b ; [G, G][a, b], [G, G]a−1 ∗ [G, G]b−1
[G, G]a ∗ [G, G]b ; [G, G], [G, G]a−1 ∗ [G, G]b−1 .
2) Suppose [G, G] is not a subset of N, then there is [a, b] ∈ [x, y]x,y∈G such that [a, b] < N. The class
[G, G][a, b] is not N and therefore [[G, G]a, [G, G]b] do not commute.

20. TRANSFORMATION

101

§20 Transformation
We have proven there is a functor + : Z → ZFZ, for groups. The main objective of the present section
is to build the tools necessary in order to generalize and clarify that situation.

20.1 Homomorphism.
Definition 14. We will say that a functor h : G1 → G2 is a homomorphism if G1 , G2 are groups.
Condition 1) for functors means 1; 1, h. Also, for the product in G2 ,
hx−1
hx−1
hx−1
hx−1
hx−1

;
;
;
;
;

hx−1 ∗ [hx ∗ (hx)−1 ], 1
[hx−1 ∗ hx] ∗ (hx)−1 , 1
h(x ∗ x−1 ) ∗ (hx)−1 , 1
h1 ∗ (hx)−1 , 1
(hx)−1 , 1.

Here, 1 represents the unit, for both groups. A homomorphism with monic arrow function is called
monomorphism. If the arrow function of the homomorphism is onto, we will say it is an epimorphism.
Theorem 20.1. Let h : G1 → G2 be a homomorphism and g : G1 → G2 an epimorphism.
1) If H1 ∈ G1⊆ , then hH1 ∈ G2⊆ . And, if N1 ∈ Ĝ1⊆ , then gN1 ∈ Ĝ2⊆ .
2) If H2 ∈ G2⊆ then h−1 H2 ∈ G1⊆ . And, if N2 ∈ Ĝ2⊆ , then h−1 N2 ∈ Ĝ1⊆ .
Proof.
1) We take two objects in hH1 and we wish to see if their product is, again in hH1 . That is,

hh1 ; hh1 ∗ hh2 , hh2
hh1 ; h(h1 ∗ h2 ), hh2
hh1 ; hh, hh2
for some h ∈ H1 . Now, we suppose N1 is an invariant subspace; that is xN1 x−1 ⊆ N1 , for every
x ∈ G1 . We shall prove gN1 is invariant as well. We wish to verify gx(gN1 )gx−1 ⊆ gN1 , for every
x ∈ G2 . Any object of G2 can be represented by gx, for some x ∈ G1 , because g is onto.Take an
object in gN1 , say gn1 where n1 ∈ N1 .
gx ∗ gn1 ; (gx ∗ gn1 ) ∗ gx−1 , (gx)−1
gx ∗ gn1 ; g[(x ∗ n1 ) ∗ x−1 ], (gx)−1
gx ∗ gn1 ; gn2 , (gx)−1
for some n2 ∈ N1 . Therefore, (gx ∗ gn1 ) ∗ gx−1 ∈ gN1 .

CHAPTER VI. GROUP

102

2) We follow the same line of thought as in 1). Thus, we take h1 , h2 ∈ h−1 H2 and we see that
hh1 ; hh1 ∗ hh2 , hh2
hh1 ; h(h1 ∗ h2 ), hh2
which means h1 ∗ h2 ∈ h−1 H2 , because hh1 ∗ hh2 ∈ H2 .
We now prove h−1 N2 is invariant given N2 is invariant. Let n1 ∈ h−1 N2 , then
(x ∗ n1 ) ∗ x−1 ; h[(x ∗ n1 ) ∗ x−1 ], h
(x ∗ n1 ) ∗ x−1 ; (hx ∗ hn1 ) ∗ hx−1 , h
(x ∗ n1 ) ∗ x−1 ; n2 , h
for some n2 ∈ N2 . This is the same as (x ∗ n1 ) ∗ x−1 ∈ h−1 N2 .

20.2 Isomorphism
Theorem 20.2. Let h : G1 → G2 a homomorphism, and let Nul h = h−1 1. Then,
1) Nul h ∈ Ĝ1⊆
2) There exists an isomorphism φ : G1 /Nul h → Im h such that for every congruence, we have
(Nul h)x 7→φ hx. This isomorphism is called the natural isomorphism for G1 /Nul h and Im h.
Proof.
1) We first prove Nul h is a subgroup of G1 . For e1 , e2 ∈ Nul h, we have
e1 ∗ e−1
2
e1 ∗ e−1
2
e1 ∗ e−1
2
e1 ∗ e−1
2

;
;
;
;

h(e1 ∗ e−1
2 ), h
he1 ∗ he−1
2 ,h
1 ∗ (he2 )−1 , h
1 ∗ 1, h

−1
which means e1 ∗ e−1
∈ Nul h,
2 ∈ Nul h. To verify that Nul h is invariant we must prove (x ∗ e) ∗ x
for any e ∈ Nul h.

(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1

;
;
;
;
;

h[(x ∗ e) ∗ x−1 ], h
(hx ∗ he) ∗ hx−1 , h
(hx ∗ 1) ∗ (hx)−1 , h
hx ∗ (hx)−1 , h
1, h

20. TRANSFORMATION

103

2) To see that φ is a functor:

(Nul h)a ∗ (Nul h)b
(Nul h)a ∗ (Nul h)b
(Nul h)a ∗ (Nul h)b
(Nul h)a ∗ (Nul h)b
(Nul h)a ∗ (Nul h)b

;
;
;
;
;

φ[Nul h(a) ∗ Nul h(b)], φ
φ[Nul h(a ∗ b)], φ
h(a ∗ b), φ
ha ∗ hb, φ
φ[(Nul h)a] ∗ φ[(Nul h)b], φ

We now prove that φ is onto. Every object Im h is of the form hx such that x ∈ G1 . So we have,
for every hx ∈ Im h an object (Nul h)x ∈ G1 /Nul h such that (Nul h)x 7→φ hx.
To verify we have an isomorphism, we look at the explicit relation between two objects in the
same congruence class. We have
a ≡ b mod Nul h
if and only if e; a, b where e; 1, h. So, supposing a, b ∈ G1 are related, we get

ha
ha
ha
ha
ha
ha
ha
ha

;
;
;
;
;
;
;
;

ha ∗ hb−1 , (hb)−1
φ[(Nul h)a] ∗ φ[(Nul h)b−1 ], (hb)−1
φ[(Nul h)a ∗ (Nul h)b−1 ], (hb)−1
φ[(Nul h)(a ∗ b−1 )], (hb)−1
φ[(Nul h)((e ∗ b) ∗ b−1 )], (hb)−1
φ[(Nul h)e], (hb)−1
he, (hb)−1
1, (hb)−1

That is, a, b are related if and only if ha, hb are the same object. Therefore, if (Nul h)a and (Nul h)b
are not the same class, then the image under φ are not the same object. We have thus proven the
functor is monic.

Theorem 20.3. An epimorphism g : G1 → G2 such that Nul g = {1} ⊆ G1 , is an isomorphism.
Proof. We have an isomorphism G1 /Nul g → G2 . All we need is an isomorphism G1 → G1 /Nul g. As
we have already seen, G1 /Nul g = G1 /1 = G1 .

CHAPTER VI. GROUP

104

20.3 Automorphism
Given a group G, and an object x ∈ G, we will define an internal automorphism for G. It is defined by
a 7→ (x ∗ a) ∗ x−1 , and we will express it with a x .
Theorem 20.4. Let G be any group. Then,
1) The collection of internal automorphisms is a subcollection of {GFisoG}, and we denote it by aG .
2) The functor G → aG that makes x 7→ ax , is an epimorphism.
3) aG is an invariant subgroup of {GFisoG}.
Proof.
1) We see that, for a given x ∈ G, the internal automorphism a x is bijective. Let a x a and ax b be the
same object in the image of a x , then:

1, a x a
1, (x ∗ a) ∗ x−1
1, [(x ∗ a) ∗ x−1 ] ∗ x
1, x ∗ a
1, 1
x ∗ b, 1
−1
x ∗ (x ∗ b), 1
b, 1
1, 1
1, a

;
;
;
;
;
;
;
;
;
;

1, ax b
1, (x ∗ b) ∗ x−1
1, [(x ∗ b) ∗ x−1 ] ∗ x
1, x ∗ b
x ∗ a, x ∗ b
x ∗ a, 1
x−1 ∗ (x ∗ a), 1
a, 1
a, b
1, b

Now, to prove a x is onto, we see that for any a ∈ G, there exists x−1 ∗ (a ∗ x) ∈ G such that
(x−1 ∗ a) ∗ x ; (x ∗ [x−1 ∗ (a ∗ x)]) ∗ x−1 , ax
(x−1 ∗ a) ∗ x ; (a ∗ x) ∗ x−1 , a x
(x−1 ∗ a) ∗ x ; a, ax .
We see that we have a functor because
ax a
ax a
ax a
ax a
ax a
ax a

;
;
;
;
;
;

[(x ∗ a) ∗ x−1 ] ∗ [(x ∗ b) ∗ x−1 ], a x b
[(x ∗ a) ∗ x−1 ] ∗ [x ∗ (b ∗ x−1 )], a x b
(x ∗ a) ∗ (b ∗ x−1 ), ax b
[(x ∗ a) ∗ b] ∗ x−1 , ax b
[x ∗ (a ∗ b)] ∗ x−1 , ax b
a x (a ∗ b), ax b.

20. TRANSFORMATION

105

2) We note that aG is an algebraic category. As a result, we can define a functor G → aG , such that
the function for objects of operation is defined by x 7→ a x . We assert that this is a functor because,
for every a ∈ G:

a
a
a
a
a

;
;
;
;
;

[(x ∗ y) ∗ a] ∗ (x ∗ y)−1 , a x∗y
[x ∗ (y ∗ a)] ∗ (y−1 ∗ x−1 ), ax∗y
([x ∗ (y ∗ a)] ∗ y−1 ) ∗ x−1 , ax∗y
(x ∗ [(y ∗ a) ∗ y−1 ]) ∗ x−1 , ax∗y
(a x ◦ ay )a, ax∗y

The facts proven thus far, and theorem 7, imply that aG is a subgroup of {GFisoG}.

20.4 Action Group
Definition 15. A group G, with operation ∗, is an action group of X if there exists a homomorphism ∗¯
from G into the group of transformations of X. We will write a 7→ a¯∗ to represent the images. The null
space of ∗¯ is called the nucleus of non-effectivity for G. If ∗¯ is an isomorphism, then we will say G is an
effective action group of X.
An action group is called transitive if for every x, y ∈ X there exists a ∈ G such that x; y, a¯∗.
Let f : X → Y be a bijective set function and f : G → H an isomorphism such that G, H is an action
group of X, Y, and the operations are ∗1 , ∗2 . If f, f ; fa¯∗2 , a¯∗1 we say (X, G) and (Y, H) are similar pairs.
All that is being said is f (a¯∗1 x) and (fa)¯∗2 ( f x) are the same object, for every x ∈ X.
The definition of action group is one of the main reasons why defining the operation as a function
O1 → O2 f O3 is convenient; to some extent it is easier to see the deep relation between operation and
group. Recall that the objects of O1 were called the actions of the operation; they are the objects that
act on the objects of O2 . We conclude with the observation that providing ∗¯ is, in a way, extending the
operation of the group, so as to let objects of the collection be acted upon by objects of G.
Group, Action Group and Group of Transformations First of all, any action group of X is
homomorphic to the group of transformations of X. Also notice that any group of transformations of X
is an action group of X.
Any group G may be seen as the action group of any one object set {1}; we define the homomorphism
∗¯ as the trivial x 7→ I, where I : {1} → {1}, for all x ∈ G. We see that the images allowed for a
homomorphism ∗¯ , depends on the objects of the collection X because this is what defines the diversity
of functions X → X. For example, we have the extreme case in which a group G is an action group of
a set with one object, {x}. In this case Nul ∗¯ = G because all functions are the same, by definition.
Similarity We see that a similar pair is the best thing that can happen, when considering two action
groups. One is entirely justified in considering these two as the same group, to far extent. The situation
is as follows, in considering a similar pair. Not only are the groups isomorphic, the collections for
which they are defined are also bijective. And on top of this, the function and isomorphism commute
well, in the following sense. We can first apply a¯∗1 and then f , or we can first apply f and then (fa)¯∗2 .

CHAPTER VI. GROUP

106

Transitive Action Groups In the following we will consider the collection of left congruence
classes. Such a collection of classes, with respect to H ⊆ G, is represented by G/xH.
Theorem 20.5. Let H ∈ G⊆ , with operation ∗. Let ∗¯ : G → (G/xH) fiso (G/xH) be such that a 7→∗¯ a¯∗
and xH 7→a¯∗ (a ∗ x)H, for every a ∈ G. Then,
1) G is a transitive action group of G/xH, by the homomorphism ∗¯
2) H; H, x¯∗ ⇔ x ∈ H
3) N ∈ Ĥ⊆ ⇒ N ⊆ Nul ∗¯ ⊆ H.
Proof.
1) We will see that ∗¯ is a homomorphism. We are left to prove a ∗ b; (a¯∗) ◦ (b¯∗), ∗¯ . The domain and
image of the functions (a ∗ b)¯∗ and (a¯∗) ◦ (b¯∗) are the same, respectively. Let xH ∈ G/xH, for
some x ∈ G,

xH
xH
xH
xH
xH

;
;
;
;
;

(a ∗ b)¯∗ xH, (a ∗ b)¯∗
[(a ∗ b) ∗ x]H, (a ∗ b)¯∗
[a ∗ (b ∗ x)]H, (a ∗ b)¯∗
a¯∗(b ∗ x)H, (a ∗ b)¯∗
a¯∗(b¯∗ xH), (a ∗ b)¯∗

Now our aim is to give a proof that G is transitive. Let aH, bH ∈ G/xH, since G is a group,
b ∗ a−1 ∈ G so that

aH ; (b ∗ a−1 )¯∗aH, (b ∗ a−1 )¯∗
aH ; [(b ∗ a−1 ) ∗ a]H, (b ∗ a−1 )¯∗
aH ; bH, (b ∗ a−1 )¯∗.
2) x ∈ H if and only if x ∗ h ∈ H, for any h ∈ H. This last condition is true if and only if: a)
x¯∗H = xH ⊆ H, and b) H ⊆ xH = x¯∗H.
Suppose x ∗ h ∈ H, for every h ∈ H, then xH ⊆ H. We can equivalently say x ∈ H, and this means
that h ∈ H is the same as x ∗ (x−1 ∗ h) ∈ xH because x ∗ (x−1 ∗ h) is the same as (x ∗ x−1 ) ∗ h ∈ H.
Let us now suppose that conditions a) and b) are true, then x ∗ h ∈ xH = H, for any h ∈ H. We
may now conclude x ∈ H if and only if x¯∗ H = H.
T
3) If we prove Nul ∗¯ = x∈G xHx−1 , we are done proving 3), for the following reasons. From this
we get Nul ∗¯ ⊆ H, for any x ∈ G, because H = eHe−1 . Also, consider any invariant subgroup N,
of H, and let n ∈ N ⊆ H. Let x ∈ G, then there exists m ∈ N ⊆ H such that n is (x ∗ m) ∗ x−1 .
T
Therefore, n ∈ xHx−1 and we can say N ⊆ x∈G xHx−1 .

20. TRANSFORMATION

107

We know a ∈ Nul ∗¯ if and only if (a ∗ x)H = a¯∗ xH = xH, for every x ∈ G. We have
H =
=
=
=
=
=
=

eH
(x−1 ∗ x)H
(x−1 ∗ x)¯∗ H
x−1 ∗¯ (x¯∗H)
x−1 ∗¯ xH
x−1 ∗¯ (a ∗ x)H
[x−1 ∗ (a ∗ x)]H,

and because of the first theorem in the section for congruence classes, x−1 ∗ (a ∗ x) ∈ H. From
this we have a ∗ x ∈ xH and after that, a ∈ xHx−1 . All the implications are reversible, so we also
T
have x∈G xHx−1 ⊆ Nul ∗¯ .
Suppose G is a transitive action group of X and take a ∈ X. Define, Ga7→b , for any b ∈ X, as the
subcollection of all x ∈ G such that a; b, x¯∗; transitivty of G assures that Ga7→b , ∅.
Proposition 20.6. If a ∈ X and G is an action group of X, we will say that Ga7→a is the stable subgroup
for a, and represent it by Inv(a), in view of Inv(a) ∈ G⊆ .
Proof. All we need to prove is that Inv(a)Inv(a)−1 ⊆ Inv(a). Let x ∈ Inv(a) and y−1 ∈ Inv(a)−1 , for
some y ∈ Inv(a). We must verify (x ∗ y−1 )¯∗ applies a to a.

a
a
a
a
a

;
;
;
;
;

(x ∗ y−1 )¯∗a, (x ∗ y−1 )¯∗
x¯∗(y−1 ∗¯ a), (x ∗ y−1 )¯∗
x¯∗[(y¯∗)−1 a], (x ∗ y−1 )¯∗
x¯∗a, (x ∗ y−1 )¯∗
a, (x ∗ y−1 )¯∗

Notice we are using the inverse function (y¯∗)−1 in virtue that y¯∗ is bijective. We use the fact that (y¯∗)−1 ,
just as y, applies a to a.
We get a another representation of the nucleus of non-effectivity for G; again, as an intersection.
\
Nul ∗¯ =
Inv(x).
x∈X

Now, consider the operation φ : X → X f PG that makes a 7→φ aφ and define aφ : X → PG as
the function that makes b 7→aφ Ga7→b . The notation for this operation yields a; Ga7→b, b. Another way of
saying this is in terms of the function is b; Ga7→b, aφ.
Theorem 20.7. Let G be a transitive action group of X and I : G → G be the identity functor.
1) Im aφ = G/x Inv(a) and aφ|Im aφ = aφ|G/x Inv(a) is bijective

108

CHAPTER VI. GROUP

2) The pairs (X, G) and (G/x Inv(a), G) are similar, in virtue of aφ|G/x Inv(a) , I
3) x ∈ Ga7→b ⇒ Inv(b) = x Inv(a) x−1 .
Proof.
1)
2)
3)
4)

VII | Linear Space
Definition 16. Let K(+, ·) be a field and VG (∗) an abelian group. Represent the underlying set of VG
with V and recall that {VG Fiso VG } is the group of automorphisms for VG . Let K(·) be the group under
the product, for the field, and suppose there is a homomorphism ∗¯ : K(·) → {VG Fiso VG }, such that
a + b; (a¯∗u) ∗ (b¯∗u), u.

(VII.1)

This last condition means (a + b)¯∗u is the same as (a¯∗u) ∗ (b¯∗u) where a, b ∈ K and u ∈ VG . The abelian
group VG , together with the homomorphism ∗¯ : K(·) → {VG Fiso VG } forms a linear space.
In other words we have a linear space iff we have a field that under product is homomorphic to the
group of automorphisms of an abelian group, in such a manner that (VII.1) holds. The linear space is
represented by V. The following establishes equivalence with the usual definition of linear space.
Proposition 20.8. A linear space V exists iff there is an abelian group VG (∗) and a field K(+, ·) such
that there is an operation ∗¯ : A|K → {A|VG f A|VG } defined so that (VII.1) holds, as well as
a ; (a¯∗u) ∗ (a¯∗v), u ∗ v
1 ; u, u
a · b ; a¯∗(b¯∗u), u,

(VII.2)
(VII.3)
(VII.4)

in terms of the notation for ∗¯ and for 1 ∈ K(·).
Proof. Since the image of ∗¯ consists of automorphisms, we can say a¯∗(u ∗ v) is the same as (a¯∗u) ∗ (a¯∗v)
for every a in the field and u, v in the abelian group VG . Secondly, since ∗¯ is a homomoprhism, we can
say 1¯∗ : VG → VG is the identity automorphism. Finally, the fact that ∗¯ is a homomorphism implies that
(a · b)¯∗ is the same automorphism as a¯∗ ◦ b¯∗, which is the same as saying (a · b)¯∗u is equal to a¯∗(b¯∗u).

109

110

CHAPTER VII. LINEAR SPACE

VIII | Topological System
Let X be a set and let X be an algebraic category with the c-object defined as O|X := X. For every subset
A ⊆ X, we define an arrow in X, also denoted A, and we call it the arrow subset. If there is no fear for
confusion we may say it is a subset of X. To make sure X is a category, we must provide a composition
operation for the arrows. We know union is associative, and the emptyset acts as unit. Also, the union
of any two subsets of X, is also a subset of X. This means that X is an algebraic category with subsets
as objects of operation, and X as c-object.
Now we want to consider a subcategory of X. This will be the category that consists of the arrow
subset corresponding to the singletons of X. The category will be represented by {{X}}. The arrows
of this category are called points of X. We will include ∅ and X in the category of points. We are
identifying each subset (in the strict sense) of X, with the arrow subset, in X. We are doing this so that
we can view subsets as arrows in a category.

§21 Two Descriptions, One System
21.1 Closure
Let T be a subcategory of X, such that ∅, X are arrow subsetes in T. We say T is the topological space,
while a topological system is a functor ClX : T → T so that for any point x, and any subset A, in T:
1) x ; x, ClX
2) ClX A ; ClX A, ClX .
Both 1) and 2) can be expressed as one condition. We are saying {{T}} is strongly invariant under
ClX , and ClX is a once effective functor. Of course, we use {{T}} to represent the points of T. Simply
put, Im ClX ∪ {{T}} is strongly invariant. The concept of stongly invariant and once effective function
is presented in the subdivision Sequence for Composition. In view of the last statements, the two
conditions are replaced by the condition that any arrow subset A, in Im ClX ∪ {{T}}, satisfies A; A, ClX .
A topological system is an algebraic functor that leaves Im ClX ∪ {{T}} strongly invariant.
Any D in T such that D; D, ClX is said to be closed. The collection of all closed subsets of X is
represented by C. A subset V ⊆ X, complement of a closed subset, is in the collection of open sets, O.
Proposition 21.1. For any A, B ⊆ X, we have
1) A ⊆ ClX A
2) A ⊆ B ⇒ ClX A ⊆ ClX B.
111

CHAPTER VIII. TOPOLOGICAL SYSTEM

112

Proof. A point x, of the space is adherent to A ⊆ X if x ∈ ClX A. We say ClX A is the adherence of A.
1) Let x ∈ A, then
A ; ClX (A ∪ {x}), ClX
A ; ClX A ∪ ClX {x}, ClX
A ; ClX A ∪ {x}, ClX .
This last expression is ClX A = ClX A ∪ {x}, which is equivalent to x ∈ ClX A.
2) If A ⊆ B, we have
B ; ClX (A ∪ B), ClX
B ; ClX A ∪ ClX B, ClX
⇔ ClX B = ClX A ∪ ClX B
⇔ ClX A ⊆ ClX B.

Theorem 21.2. For any finite subcollections {Di }ni=1 ⊆ C or {Vi }ni=1 ⊆ O, we have
S
1) i Di ∈ C
T
2) i Vi ∈ O.

Proof.

1)

D1 ∪ D2 ; ClX (D1 ∪ D2 ), ClX
D1 ∪ D2 ; ClX D1 ∪ ClX D2 , ClX
D1 ∪ D2 ; D1 ∪ D2 , ClX .
The ressult follows for n + 1 subsets if we suppose that it holds for n.
2)

c
[
\ 
Vic , ClX
 Vi  ; ClX
i

i


c
[
\ 
 Vi  ; ClX
Di , ClX
i

i



[
\ c
Di , ClX
 Vi  ;
i

i



[
\ c
 Vi  ;
Vic , ClX
i



\ c
 Vi  ;
i

i



\ c
 Vi  , ClX .

This means (∩i Vi )c ∈ C, which proves ∩i Vi ∈ O.

i

22. NEIGHBORHOODS

113

Theorem 21.3. For any subcollections {Di }i ⊆ C or {Vi }i ⊆ O, we have
T
1) i Di ∈ C
S
2) i Vi ∈ O.

Proof. We know that ∩i Di ⊆ ClX ∩i Di . Thus, all we need to prove is ClX ∩i Di ⊆ ∩i Di . From 2) in
proposition 21.1, we get ClX ∩i Di ⊆ ClX D, for every D ∈ {Di }i . Then, ClX ∩i Di ⊆ ∩iClX Di = ∩i Di .
We can prove 2) as we did in the last theorem.
T
Theorem 21.4. Let A ⊆ X and CA the collection of all D such that A ⊆ D ∈ C. Then A; CA , ClX .

Proof. We know ClX A ∈ C, and since A ⊆ ClX A, we also have ClX A ∈ CA . This implies ∩CA ⊆ ClX A.
On the other hand, A ⊆ D, for every D ∈ CA , means A ⊆ ∩CA . From this, and the fact that ∩CA ∈ C,
we get ClX A ⊆ ClX ∩ CA = ∩CA .

21.2 Interior
To establish a topological system, a closure operation must be defined for the subsets of X. However, it
is not absolutely necessary to define the closure for all subsets. If we define the collection of closed sets,
we will be able to say what the closure of any subset is; this is provided by the last theorem. Simply
put, to every family of subsets of X, that includes ∅, X ∈ C, there corresponds a topological sysytem.
Now, in view of the fact that a topological system can be established by defining the closed sets, we see
that it is perfectly acceptable to give the topological system by defining the dual objects of these. That
is, a topological system is defined by defining the collection of open sets for X.

§22 Neighborhoods
For any point x ∈ X, the family Ox consists of all V such that x ∈ V ∈ O. Also, OA is the family of all V
such that A ⊇ V ∈ O.
Definition 17. A family B ⊆ O is called a base of the topological system ClX if for every ∅ , V ∈ O we
S
have V = (OV ∩ B). If x ∈ U ∈ B, we say U is a base-neighborhood of x. The subset N is called a
neighborhood of x if there exists V ∈ O such that x ∈ V ⊆ N. A family B x ⊆ O is a point base of x if for
every neighborhood N of x, there exists U ∈ B x such that x ∈ U ⊆ N.
Notice that in order to speak of base-neighborhoods, we must have a fixed base. So, anytime baseneighborhoods are discussed, we will presuppose the choice of a base.
We wish to see that every point of X is in some base-neighborhood. We can easily prove this for
any non-trivial case in which their are at least two points. In this case, we have proven X is open and
S
therefore X = B. From this it follows that every point x is in some N ∈ B.
Proposition 22.1. For any x ∈ X we verify

1) Any base of X is a point base of x.
2) The collection of all base-neighborhoods of x is a point base of x.

CHAPTER VIII. TOPOLOGICAL SYSTEM

114

Proof. We will not give a proof for 1); this is a trivial observation. Let N be a neighborhood of x,
S
then there is an open set V such that x ∈ V ⊆ N. We know V = V, where V is a subfamily of B.
Therefore, x ∈ U ⊆ N, for some subset U ∈ V.
Theorem 22.2. A subset is open if and only if it is a neighborhood of every point it contains.
Proof. Clearly, V ∈ O is a neighborhood of any x ∈ V because V ⊆ V.
Suppose V is a neighborhood of every x ∈ N. Consider, for each x, the open set x ∈ U x ⊆ V. It is
S
easily verified that V = x U x ∈ O.
Theorem 22.3. B is a base of CLX if and only if

x ∈ V ∈ O ⇒ (∃U ∈ B)(x ∈ U ⊆ V).
Proof. B is a base of X if and only if V =
U ∈ (OV ∩ B).

S

(OV ∩ B). This last holds if and only if x ∈ U, for some

Closure and Neighborhoods. Of course, once we have specified a base, we have also, unequivocally, specified a topological system. This is due to the fact that a base determines a collection O that
S
consists of β, for every β ⊆ B. Let ¯ : T → T be the functor that assigns A 7→ Ā, where x ∈ Ā if and
only if x ∈ U ∈ B implies the existence of some a ∈ A ∩ U. When such a functor is given, we call it a
closure in terms of a base.
Theorem 22.4. The closure operation, defined in terms of a base, forms a topological system which is
the same topological system determined by the open sets, generated from the base.
T
Proof. We must verify that Ā = CA , where the closed subsets are those corresponding to open sets
T
given by the base. Let x ∈ Ā, and take D ∈ CA . We show x < Dc ∈ O in order to prove x ∈ CA. If it
were true that x ∈ Dc , then there exists U ∈ B such that x ∈ U ⊆ Dc . But this means a ∈ U, for some
a ∈ A. This is a clear contradiction beacause A ⊆ D ⊆ U c .
T
For the opposite inclusion, suppose x ∈ CA and let x ∈ U ∈ B. If A ∩ U = ∅, then x < A ⊆ U c ∈ C.
T
which implies x < CA . Therefore, a ∈ A ∩ U, for some a. Thus, x ∈ Ā.
The collection of all the bases of a topological system is represented by B; in an analogous manner
we denote by O the collection of open sets that determine a topological system. Also, let T be the
collection of all topological systems of X. We will say CL : B → T is the function that assigns to each
base of X the unique closure in terms of the base. Represent by Cl : B → O → T, the function that
assigns to each base of X, the family of open sets, for which it is base, and then to that family, assigns
its corresponding closure function. The theorem says both are the same.

22. NEIGHBORHOODS

115

Acknowledgements
The present work began as a project to study several areas of mathematics using the perspective of
systems; objects and relations. The initial intention on the part of the author was to use this only as
a conceptual tool for personal understanding. In a series of talks with a fellow student, we came to
the conclusion that this focus was similar to the concept of category, where relations take the special
form of arrows. This enabled me to start writing out the present document. My thanks go out to Marco
Armenta, and several other costudents whom I had enriching conversations with.
The initial thoughts came about after reading a recommendation from my professor, Victor Pérez
Abreu. After making a project on axiomatic systems, for a class I was taking with the professor, he
recommended I read, An Eternal Golden Braid by Douglas R. Hofstadter. This book had profound
implications in my life and philosophical views. Since I am an undergraduate student of mathematics,
I decided to use this philosophy to start learning mathematics from scratch. Of course, lead by the
works of others in all areas of mathematics, I have tried to make an account of some basic principle of
mathematics. The professor was always giving great insight in his class and at talks in his office. His
patience and dedication to all his students is admirable.
After making some progress, I came across the work of Jouni Järvinen. This helped me to materialize the constructions of the integers and rationals. Although, I initially came across an article on
information systems, this article was not ultimately of much help but his article [VIII] turned out to
be of tremendous help. I went back and tried to properly define the construction using the definitions
provided in [VIII]. I have also made use of the online encyclopedia, Wikipedia.
Any error or misrepresentation of mathematical results that goes against established mathematical standards are sole responsibility of the author, whom does not wish to involve any of the above
mentioned, on negative feedback, that shall certainly come. Of course, all feedback will be more than
welcome by the author.

Bibliography
I. Mac Lane, Saunders. Categories for the Working Mathematician. New York: Springer-Verlag,
1971.
II. Asperti, Andrea and Longo, Giuseppe. Categories Types and Structures: An Introduction to
Category Theory for the Working Computer Scientist. MIT Press, 1991.
III. R. M. Dudley. Real Analysis and Probability. Cambridge: Cambridge University Press, 2004.
IV. Mac Lane, Saunders and Birkhoff, Garrett. Algebra. Providence, Rhode Island: AMS Chelsea
Publishing, Third edition 2004.
V. L. S. Pontriaguin. Grupos Continuos. Moscú: Editorial Mir, 1978.
VI. J. N. Sharma. Krishna’s Topology. Meerut: Krishna Prakashan Media (P) Ltd, 1979.
VII. Mariusz Wodzicki. Notes on Topology. December 3, 2010.
VIII Järvinen, Jouni. Lattice Theory for Rough Sets. Turku Centre for Computer Sciences. FI-20014
University of Turku, Finland.

116

CHAPTER VIII. TOPOLOGICAL SYSTEM

IX Bifunctor. V.E. Govorov (originator), Encyclopedia of Mathematics.
X A Concrete Introduction to Categories. William R. Schmitt. Department of Mathematics, George
Washington University.
XI Representable Functors and the Yoneda Lemma. Brown, Gordon. Spring 2015
XII math.stackexchange.com

