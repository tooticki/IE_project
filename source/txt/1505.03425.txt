DOMINATING THE ERDŐS-MOSER THEOREM
IN REVERSE MATHEMATICS

arXiv:1505.03425v2 [math.LO] 24 Oct 2016

LUDOVIC PATEY
Abstract. The Erdős-Moser theorem (EM) states that every infinite tournament has an infinite transitive subtournament. This principle plays an important role in the understanding
of the computational strength of Ramsey’s theorem for pairs (RT22 ) by providing an alternate
proof of RT22 in terms of EM and the ascending descending sequence principle (ADS). In this
paper, we study the computational weakness of EM and construct a standard model (ω-model)
of simultaneously EM, weak König’s lemma and the cohesiveness principle, which is not a model
of the atomic model theorem. This separation answers a question of Hirschfeldt, Shore and
Slaman, and shows that the weakness of the Erdös-Moser theorem goes beyond the separation
of EM from ADS proven by Lerman, Solomon and Towsner.

1. Introduction
Reverse mathematics is a mathematical program whose goal is to classify theorems in terms
of their provability strength. It uses the framework of subsystems of second-order arithmetic,
with the base theory RCA0 , standing for Recursive Comprehension Axiom. RCA0 is composed of
the basic first-order Peano axioms, together with ∆01 -comprehension and Σ01 -induction schemes.
RCA0 is usually thought of as capturing computational mathematics. This program led to two
important observations: First, most “ordinary” (i.e. non set-theoreric) theorems require only
very weak set existence axioms. Second, many of those theorems are actually equivalent to one
of five main subsystems over RCA0 , known as the “Big Five” [21].
However, Ramsey theory is known to provide a large class of theorems escaping this phenomenon. Indeed, consequences of Ramsey’s theorem for pairs (RT22 ) usually belong to their own
subsystem. Therefore, they received a lot of attention from the reverse mathematics community [3, 13, 14, 27]. This article focuses on Ramseyan principles below the arithmetic comprehension axiom (ACA). See Soare [29] for a general introduction to computability theory, and
Hirschfeldt [11] for a good introduction to the reverse mathematics below ACA.
1.1. Cohesiveness
Cohesiveness is a statement playing a central role in the analysis of Ramsey’s theorem for
pairs [3]. It can be seen as a sequential version of Ramsey’s theorem for singletons and admits
′
characterizations in terms of degrees whose jump computes a path through a Π10,∅ class [16].
The decomposition of RT22 in terms of COH and stable Ramsey’s theorem for pairs (SRT22 ) has
been reused in the analysis of many consequences of Ramsey’s theorem [14]. The link between
cohesiveness and SRT22 is still an active research subject [4, 8, 12, 26].
~
~ =
Definition 1.1 (Cohesiveness) An infinite set C is R-cohesive
for a sequence of sets R
∗
∗
~
R0 , R1 , . . . if for each i ∈ ω, C ⊆ Ri or C ⊆ Ri . A set C is p-cohesive if it is R-cohesive
~ is an enumeration of all primitive recursive sets. COH is the statement “Every uniform
where R
~ has an R-cohesive
~
sequence of sets R
set.”
Jockusch and Stephan [16] studied the degrees of unsolvability of cohesiveness and proved
that COH admits a universal instance whose solutions are the p-cohesive sets. They characterized their degrees as those whose jump is PA relative to ∅′ . The author extended this analysis
to every computable instance of COH and studied their degrees of unsolvability [26]. Cholak,
Jockush and Slaman [3] proved that RT22 is computably equivalent to SRT22 + COH. Mileti [20]
and Jockusch and Lempp [unpublished] formalized this equivalence over RCA0 . Hirschfeldt,
1

2

LUDOVIC PATEY

Jockusch, Kjos-Hanssen, Lempp and Slaman [13] proved that COH contains a model with no
diagonally non-computable function, thus COH does not imply SRT22 over RCA0 . Cooper [6]
proved that every degree above 0′ is the jump of a minimal degree. Therefore there exists a
p-cohesive set of minimal degree.
1.2. The Erdős-Moser theorem
The Erdős-Moser theorem is a principle coming from graph theory. It provides together with
the ascending descending principle (ADS) an alternative proof of Ramsey’s theorem for pairs
(RT22 ). Indeed, every coloring f : [ω]2 → 2 can be seen as a tournament R such that R(x, y)
holds if x < y and f (x, y) = 1, or x > y and f (y, x) = 0. Every infinite transitive subtournament
induces a linear order whose infinite ascending or descending sequences are homogeneous for f .
Definition 1.2 (Erdős-Moser theorem) A tournament T on a domain D ⊆ ω is an irreflexive
binary relation on D such that for all x, y ∈ D with x 6= y, exactly one of T (x, y) or T (y, x)
holds. A tournament T is transitive if the corresponding relation T is transitive in the usual
sense. A tournament T is stable if (∀x ∈ D)[(∀∞ s)T (x, s) ∨ (∀∞ s)T (s, x)]. EM is the statement
“Every infinite tournament T has an infinite transitive subtournament.” SEM is the restriction
of EM to stable tournaments.
Bovykin and Weiermann [1] introduced the Erdős-Moser theorem in reverse mathematics
and proved that EM together with the chain-antichain principle (CAC) is equivalent to RT22
over RCA0 . This was refined into an equivalence between EM + ADS and RT22 by Montalbán
(see [1]), and the equivalence still holds between the stable versions of the statements. Lerman,
Solomon and Towsner [19] proved that EM is strictly weaker than RT22 by constructing an ωmodel of EM which is not a model of the stable ascending descending sequence (SADS). SADS is
the restriction of ADS to linear orders of order type ω + ω ∗ [14]. The author noticed in [22] that
their construction can be adapted to obtain a separation of EM from the stable thin set theorem
for pairs (STS(2)). Wang strengthened this separation by constructing in [31] a standard model
of many theorems, including EM, COH and weak König’s lemma (WKL) which is neither a
model of STS(2) nor a model of SADS. The author later refined in [24, 26] the forcing technique
of Lerman, Solomon and Towsner and showed that it is strong enough to obtain the same
separations as Wang.
On the lower bounds side, Lerman, Solomon and Towsner [19] showed that EM implies
the omitting partial types principle (OPT) over RCA0 + BΣ02 and Kreuzer proved in [18] that
SEM implies BΣ02 over RCA0 . The statement OPT can be thought of as a stating for every
set X the existence of a set hyperimmune relative to X. Finally, the author proved in [25]
that RCA0 ⊢ EM → [STS(2) ∨ COH]. In particular, every model of EM which is not a model
of STS(2) is also a model of COH. This fact will be reused in this paper since STS(2) implies
the atomic model theorem over RCA0 [25].
1.3. Domination and the atomic model theorem
The atomic model theorem is a statement coming from model theory. It has been introduced
by Hirschfeldt, Shore and Slaman [15] in the settings of reverse mathematics.
Definition 1.3 (Atomic model theorem) A formula ϕ(x1 , . . . , xn ) of T is an atom of a theory
T if for each formula ψ(x1 , . . . , xn ) we have T ⊢ ϕ → ψ or T ⊢ ϕ → ¬ψ but not both. A theory
T is atomic if, for every formula ψ(x1 , . . . , xn ) consistent with T , there is an atom ϕ(x1 , . . . , xn )
of T extending it, i.e., one such that T ⊢ ϕ → ψ. A model A of T is atomic if every n-tuple
from A satisfies an atom of T . AMT is the statement “Every complete atomic theory has an
atomic model”.
This strength of the atomic model theorem received a lot of attention from the reverse
mathematics community and was subject to many refinements. On the upper bound side,
Hirschfeldt, Shore and Slaman [15] proved that AMT is a consequence of SADS over RCA0 . The
author [25] proved that the stable thin set theorem for pairs (STS(2)) implies AMT over RCA0 .

DOMINATING THE ERDŐS-MOSER THEOREM

3

On the lower bound side, Hirschfeldt, Shore and Slaman [15] proved that AMT implies the
omitting partial type theorem (OPT) over RCA0 . Hirschfeldt and Greenberg, and independently
Day, Dzhafarov and Miller, strengthened this result by proving that AMT implies the finite
intersection property (FIP) over RCA0 (see [11]). The principle FIP was first introduced by
Dzhafarov and Mummert [9]. Later, Downey, Diamondstone, Greenberg and Turetsky [7] and
Cholak, Downey and Igusa [2] proved that FIP is equivalent to the principle asserting, for every
set X, the existence of a 1-generic relative to X. In particular, every model of AMT contains
1-generic reals.
The computable analysis of the atomic model theorem revealed the genericity flavor of the
statement. More precisely, the atomic model theorem admits a pure computability-theoretic
characterization in terms of hyperimmunity relative to a fixed ∆02 function.
Definition 1.4 (Escape property) For every ∆02 function f , there exists a function g such that
f (x) < g(x) for infinitely many x.
The escape property is a statement in between hyperimmunity relative to ∅′ and hyperimmunity. The atomic model theorem is computably equivalent to the escape property, that is,
for every complete atomic theory T , there is a ∆0,T
function f such that for every function g
2
satisfying the escape property for f , T ⊕ g computes an atomic model of T . Conversely, for
every ∆02 approximation f˜ of a function f , there is a f˜-computable complete atomic theory
such that for every atomic model M, f˜⊕ M computes a function satisfying the escape property
for f . In particular, the ω-models satisfying AMT are exactly the ones satisfying the escape
property. However the formalization of this equivalence requires more than the Σ01 induction
scheme. It was proven to hold over RCA0 + IΣ02 but not RCA0 + BΣ02 [15, 5], where IΣ02 and BΣ02
are respectively the Σ02 induction scheme and the Σ02 bounding scheme.
Hirschfeldt, Shore and Slaman [15] asked the following question.
Question 1.5 Does the cohesiveness principle imply the atomic model theorem over RCA0 ?
Note that AMT is not computably reducible to COH, since there exists a cohesive set of
minimal degree [6], and a computable atomic theory whose computable atomic models bound
1-generic reals [11], but no minimal degree bounds a 1-generic real [32].
In this paper, we answer this question negatively. We shall take advantage of the characterization of AMT by the escape property to create an ω-model M of EM, WKL and COH
simultaneously, together with a ∆02 function f dominating every function in M. Therefore, any
∆02 approximation f˜ of the function f is a computable instance of the escape property belonging
to M, but with no solution in M. The function f witnesses in particular that M 6|= AMT. Our
main theorem is the following.
Theorem 1.6 (Main theorem) COH ∧ EM ∧ WKL does not imply AMT over RCA0 .
The proof techniques used to prove the main theorem will be introduced progressively by considering first computable non-reducibility, and then generalizing the diagonalization to Turing
ideals by using an effective iterative forcing.
1.4. Definitions and notation
String, sequence. Fix an integer k ∈ ω. A string (over k) is an ordered tuple of integers
a0 , . . . , an−1 (such that ai < k for every i < n). The empty string is written ε. A sequence (over
k) is an infinite listing of integers a0 , a1 , . . . (such that ai < k for every i ∈ ω). Given s ∈ ω, ks
is the set of strings of length s over k and k <s is the set of strings of length < s over k. Similarly,
k<ω is the set of finite strings over k and kω is the set of sequences (i.e. infinite strings) over k.
Given a string σ ∈ k<ω , we denote by |σ| its length. Given two strings σ, τ ∈ k<ω , σ is a prefix
of τ (written σ  τ ) if there exists a string ρ ∈ k<ω such that σρ = τ . Given a sequence X,
we write σ ≺ X if σ = X↾n for some n ∈ ω, where X↾n denotes the restriction of X to its first

4

LUDOVIC PATEY

n elements. A binary string is a string over 2. A real is a sequence over 2. We may identify a
real with a set of integers by considering that the real is its characteristic function.
Tree, path. A tree T ⊆ k<ω is a set downward-closed under the prefix relation. A binary tree
is a tree T ⊆ 2<ω . A sequence P ∈ kω is a path though T if for every σ ≺ P , σ ∈ T . A string
σ ∈ k<ω is a stem of a tree T if every τ ∈ T is comparable with σ. Given a tree T and a string
σ ∈ T , we denote by T [σ] the subtree {τ ∈ T : τ  σ ∨ τ  σ}.
Sets, partitions. Given two sets A and B, we denote by A < B the formula (∀x ∈ A)(∀y ∈
B)[x < y] and by A ⊆∗ B the formula (∀∞ x ∈ A)[x ∈ B], meaning that A is included in B
up to finitely many elements. Given a set X and some integer k, a k-cover of X is a k-uple
A0 , . . . , Ak−1 such that A0 ∪ · · · ∪ Ak−1 = X. We may simply say k-cover when the set X is
unambiguous. A k-partition is a k-cover whose sets are pairwise disjoint. A Mathias condition
is a pair (F, X) where F is a finite set, X is an infinite set and F < X. A condition (F1 , X1 )
extends (F, X) (written (F1 , X1 ) ≤ (F, X)) if F ⊆ F1 , X1 ⊆ X and F1 r F ⊂ X. A set G
satisfies a Mathias condition (F, X) if F ⊂ G and G r F ⊆ X. We refer the reader to Chapter
2 in Hirschfeldt [11] for a gentle introduction to effective forcing.
2. The weakness of cohesiveness under computable reducibility
Before proving that COH does not imply AMT over RCA0 , we illustrate the key features
of our construction by showing that AMT does not reduce to COH in one step. This onestep reducibility is known as computable reducibility [8, 12, 26]. The general construction will
consist of iterating this one-step diagonalization to construct a Turing ideal whose functions are
dominated by a single ∆02 function.
Definition 2.1 (Computable reducibility) A principle P is computably reducible to another
principle Q (written P ≤c Q) if every P-instance I computes a Q-instance J such that for every
solution X to J, X ⊕ I computes a solution to I.
The remainder of this section is devoted to the proof of the following theorem.
Theorem 2.2 AMT 6≤c COH
In order to prove Theorem 2.2, we need to construct a ∆02 function f such that for every
~ = R0 , R1 , . . . , there is an R-cohesive
~
uniformly computable sequence of sets R
set G such that
every G-computable function is dominated by f . Thankfully, Jockusch and Stephan [16] proved
~ every p-cohesive set computes an infinite R-cohesive
~
that for every such sequence of sets R,
set. The sequence of all primitive recursive sets is therefore called a universal instance. Hence
we only need to build a ∆02 function f and a p-cohesive set G such that every G-computable
function is dominated by f to obtain Theorem 2.2.
~ = R0 , R1 , . . . , the usual construction of
Given some uniformly computable sequence of sets R
~
an R-cohesive
set G is done by a computable Mathias forcing. The forcing conditions are pairs
(F, X), where F is a finite set representing the finite approximation of G and X is an infinite,
~
computable reservoir such that max(F ) < min(X). The construction of the R-cohesive
set is
obtained by building an infinite, decreasing sequence of Mathias conditions, starting with (∅, ω)
and interleaving two kinds of steps. Given some condition (F, X),
(S1) the extension step consists of taking an element x from X and adding it to F , thereby
forming the extension (F ∪ {x}, X r [0, x]);
(S2) the cohesiveness step consists of deciding which one of X ∩ Ri and X ∩ Ri is infinite,
and taking the chosen one as the new reservoir.
The first step ensures that the constructed set G will be infinite, whereas the second step
~
makes the set G R-cohesive.
Looking at the effectiveness of the construction, the step (S1) is
computable, assuming we are given some Turing index of the set X. The step (S2), on the other
hand, requires to decide which one of two computable sets is infinite, knowing that at least one
of them is. This decision requires the computational power of a PA degree relative to ∅′ (see [3,

DOMINATING THE ERDŐS-MOSER THEOREM

5

Lemma 4.2]). Since we want to build a ∆02 function f dominating every G-computable function,
we would like to make the construction of G ∆02 . Therefore the step (S2) has to be revised.
2.1. Effectively constructing a cohesive set
The above construction leads to two observations. First, at any stage of the construction,
the reservoir X of the Mathias condition (F, X) has a particular shape. Indeed, after the first
application of stage (S2), the set X is, up to finite changes, of the form ω ∩ R0 or ω ∩ R0 . After
the second application of (S2), it is in one of the following forms: ω ∩ R0 ∩ R1 , ω ∩ R0 ∩ R1 ,
ω ∩R0 ∩R1 , ω ∩R0 ∩R1 , and so on. More generally, given some string σ ∈ 2<ω , we can define Rσ
inductively as follows: First, Rε = ω, and then, if Rσ has already been defined for some string
σ of length i, Rσ0 = Rσ ∩ Ri and Rσ1 = Rσ ∩ Ri . By the first observation, we can replace
Mathias conditions by pairs (F, σ), where F is a finite set and σ ∈ 2<ω . The pair (F, σ) denotes
the Mathias condition (F, Rσ r [0, max(F )]). A pair (F, σ) is valid if Rσ is infinite. The step
(S2) can be reformulated as choosing, given some valid condition (F, σ), which one of (F, σ0)
and (F, σ1) is valid.
Second, we do not actually need to decide which one of Rσ0 and Rσ1 is infinite assuming
that Rσ is infinite. Our goal is to dominate every G-computable function with a ∆02 function f .
Therefore, given some G-computable function g, it is sufficient to find a finite set S of candidate
values for g(x) and make f (x) be greater than the maximum of S. Instead of choosing which
one of Rσ0 and Rσ1 is infinite, we will explore both cases in parallel. The step (S2) will split
some condition (F, σ) into two conditions (F, σ0) and (F, σ1). Our new forcing conditions are
therefore tuples (Fσ : σ ∈ 2n ) which have to be thought of as 2n parallel Mathias conditions
(Fσ , σ) for each σ ∈ 2n . Note that (Fσ , σ) may not denote a valid Mathias condition in general
since Rσ may be finite. Therefore, the step (S1) becomes ∆02 , since we first have to check
whether Rσ is non-empty before picking an element in Rσ . The whole construction is ∆02 and
yields a ∆02 infinite binary tree T . In particular, any degree PA relative to ∅′ bounds an infinite
path though T and therefore bounds a G-cohesive set. However, the degree of the set G is not
sensitive in our argument. We only care about the effectiveness of the tree T .
2.2. Dominating the functions computed by a cohesive set
We have seen in the previous section how to make the construction of a cohesive set more
effective by postponing the choices between forcing G ⊆∗ Ri and G ⊆∗ Ri to the end of the
construction. We now show how to dominate every G-computable function for every infinite
path G through the ∆02 tree constructed in the previous section. To do this, we will interleave
G
a third step deciding whether ΦG
e (n) halts, and if so, collecting the candidate values of Φe (n).
Given some Mathias precondition (F, X) (a precondition is a condition where we do not assume
that the reservoir is infinite) and some e, x ∈ ω, we can ∆02 -decide whether there is some set
E ⊆ X such that ΦFe ∪E (x) ↓. If this is the case, then we can effectively find this a finite
set E ⊆ X and compute the value ΦFe ∪E (x). If this is not the case, then for every infinite
set G satisfying the condition (F, X), the function ΦG
e will not be defined on input x. In this
will
not
be a function and therefore we do not
case, our goal is vacuously satisfied since ΦG
e
.
Let
us
go
back
to
the
previous
construction.
After some stage, we have
need do dominate ΦG
e
constructed a condition (Fσ : σ ∈ 2n ) inducing a finite tree of depth n. The step (S3) acts as
follows for some x ∈ ω:
(S3) Let S = {0}. For each σ ∈ 2n and each e ≤ x, decide whether there is some finite
set E ⊆ Rσ r [0, max(Fσ )] such that ΦeFσ ∪E (x) ↓. If this is the case, add the value
of ΦFe σ ∪E (x) to S and set F̃σ = Fσ ∪ E, otherwise set F̃σ = Fσ . Finally, set f (x) =
max(S) + 1 and take (F̃σ : σ ∈ 2n ) as the next condition.
Note that the step (S3) is ∆02 -computable uniformly in the condition (Fσ : σ ∈ 2n ). The
whole construction therefore remains ∆02 and so does the function f . Moreover, given some
G-computable function g, there is some Turing index e such that ΦG
e = g. For each x ≥ e,
G
the step (S3) is applied at a finite stage and decides whether Φe (x) halts or not for every set
satisfying one of the leaves of the finite tree. In particular, this is the case for the set G and

6

LUDOVIC PATEY

G
therefore ΦG
e (x) ∈ S. By definition of f , f (x) ≥ max(S) ≥ Φe (x). Therefore f dominates the
function g.

2.3. The formal construction
~ = R0 , R1 , . . . be the sequence of all primitive recursive sets. We define a ∆0 decreasing
Let R
2
sequence of conditions (∅, ε) ≥ c0 ≥ c1 . . . such that for each s ∈ ω
(i) cs = (Fσs : σ ∈ 2s ) and |Fσs | ≥ s if Rσ r [0, max(Fσs )] 6= ∅.
Fs
(ii) For every e ≤ s and every σ ∈ 2s , either Φe σ (s) ↓ or ΦG
e (s) ↑ for every set G satisfying
(Fσs , Rσ ).
S
Let P be a path through the tree T = {σ ∈ 2<ω : Rσ is infinite} and let G = s FPs ↾s . By (i),
for each s ∈ ω, |FPs ↾s | ≥ s since RP ↾s is infinite. Therefore the set G is infinite. Moreover, for
∗
each s ∈ ω, the set G satisfies the condition (FPs+1
↾s+1 , RP ↾s+1 ), so G ⊆ RP ↾s+1 ⊆ Rs if P (s) = 1
~
and G ⊆∗ RP ↾s+1 ⊆ Rs if P (s) = 0. Therefore G is R-cohesive.
Fs

For each s ∈ ω, let f (s) = 1 + max(Φe σ (s) : σ ∈ 2s , e ≤ s). The function f is ∆02 . We
claim that it dominates every G-computable function. Fix some e such that ΦG
e is total. For
Fs
every s ≥ e, let σ = P ↾ s. By (ii), either Φe σ (s) ↓ or ΦG
(s)
↑
for
every
set
G
satisfying
(Fσs , Rσ ).
e
s
Fσ
G
Since ΦG
e (s) ↓, the first case holds. By definition of f , f (s) ≥ Φe (s) = Φe (s). Therefore f
G
dominates the function Φe . This completes the proof of Theorem 2.2.
3. The weakness of EM under computable reducibility
We now strengthen the analysis of the previous section by proving that the atomic model
theorem is not computably reducible to the Erdős-Moser theorem. Theorem 2.2 is an immediate
consequence of this result since [AMT ∨ COH] ≤c EM (see [25]). After this section, we will be
ready to iterate the construction in order to build an ω-model of EM ∧ COH which is not a
model of AMT.
Theorem 3.1 AMT 6≤c EM
Before proving Theorem 3.1, we start with an analysis of the combinatorics of the ErdősMoser theorem. Just as we did for cohesiveness, we will show how to build solutions to EM
through ∆02 constructions, postponing the Π02 choices to the end.
3.1. The combinatorics of the Erdős-Moser theorem
The standard way of building an infinite object by forcing consists of defining an increasing
sequence of finite approximations, and taking the union of them. Unlike COH where every finite
set can be extended to an infinite cohesive set, some finite transitive subtournaments may not
be extensible to an infinite one. We therefore need to maintain some extra properties which
will guarantee that the finite approximations are extendible. The nature of these properties
constitue the core of the combinatorics of EM.
Lerman, Solomon and Towsner [19] proceeded to an analysis of the Erdős-Moser theorem.
They showed in particular that it suffices to ensure that the finite transitive subtournament F
has infinitely many one-point extensions, that is, infinitely many elements x such that F ∪ {x}
is transitive, to extend F to an infinite transitive subtournament (see [19, Lemma 3.4]). This
property is sufficient to add elements one by one to the finite approximation. However, when
adding elements by block, we shall maintain a stronger invariant. We will require that the
reservoir is included in a minimal interval of the finite approximation F . In this section, we
reintroduce the terminology of Lerman, Solomon and Towsner [19] and give a presentation of
the combinatorics of the Erdős-Moser theorem motivated by its computational analysis.
Definition 3.2 (Minimal interval) Let R be an infinite tournament and a, b ∈ R be such that
R(a, b) holds. The interval (a, b) is the set of all x ∈ R such that R(a, x) and R(x, b) hold. Let
F ⊆ R be a finite transitive subtournament of R. For a, b ∈ F such that R(a, b) holds, we say

DOMINATING THE ERDŐS-MOSER THEOREM

7

that (a, b) is a minimal interval of F if there is no c ∈ F ∩ (a, b), i.e., no c ∈ F such that R(a, c)
and R(c, b) both hold.
Fix a computable tournament R, and consider a pair (F, X) where
(i) F is a finite R-transitive set representing the finite approximation of the infinite Rtransitive subtournament we want to construct
(ii) X is an infinite set disjoint from F , included in a minimal interval of F and such that
F ∪ {x} is R-transitive for every x ∈ X. In other words, X is an infinite set of one-point
extensions. Such a set X represents the reservoir, that is, a set of candidate elements
we may add to F later on.
f

(−∞, a)

a
(a, b)
b
e

(b, c)

c
d

(c, +∞)

Figure 1. In this figure, F = {a, b, c} is a transitive set, X = {d, e, f, . . . } a set
of one-point extensions, (b, c) = {e, . . . } a minimal interval of F and (F, X∩(b, c))
an EM condition. The elements d and f are not part of the minimal interval (b, c).
The infinite set X ensures extensibility of the finite set F into an infinite R-transitive subtournament. Indeed, by applying the Erdős-Moser theorem to R over the domain X, there
exists an infinite R-transitive subtournament H ⊆ X. One easily checks that F ∪ H is Rtransitive. The pair (F, X) is called an Erdős-Moser condition in [23]. A set G satisfies an
EM condition (F, X) if it is R-transitive and satisfies the Mathias condition (F, X). In order
to simplify notation, given a tournament R and two sets E and F , we denote by E →R F the
formula (∀x ∈ E)(∀y ∈ F )R(x, y).
Suppose now that we want to add a finite number of elements of X into F to obtain a finite
T -transitive set F̃ ⊇ F , and find an infinite subset X̃ ⊆ X such that (F̃ , X̃) has the above
mentioned properties. We can do this in a few steps:
1. Choose a finite (not necessarily R-transitive) set E ⊂ X.
2. Any element x ∈ X r E induces a 2-partition hE0 , E1 i of E by setting E0 = {y ∈ E :
R(y, x)} and E1 = {y ∈ E : R(x, y)}. Consider the coloring f which associates to any
element of X r E the corresponding 2-partition hE0 , E1 i of E.
3. As E is finite, there exists finitely many 2-partitions of E, so f colors each element of
X r E into finitely many colors. By Ramsey’s theorem for singletons applied to f , there
exists a 2-partition hE0 , E1 i of E together with an infinite subset X̃ ⊆ X r E such that
for every x ∈ X̃, f (x) = hE0 , E1 i. By definition of f and Ei , E0 →R X̃ →R E1 .
4. Take any R-transitive subset F1 ⊆ Ei for some i < 2 and set F̃ = F ∪ F1 . The pair
(F̃ , Ỹ ) satisfies the required properties (see [23, Lemma 5.9] for a proof).
From a computational point of view, if we start with a computable condition (F, X), that
is, where X is a computable set, we end up with a computable extension (F̃ , Ỹ ). Remember
that our goal is to define a ∆02 function f which will dominate every G-computable function for
G
some solution G to R. For this, we need to be able to ∅′ -decide whether ΦG
e (n) ↓ or Φe (n) ↑ for
every solution G to R satisfying some condition (F, X). More generally, given some Σ01 formula
ϕ, we focus on the computational power required to decide a question of the form
Q1: Is there an R-transitive extension F̃ of F in X such that ϕ(F̃ ) holds?

8

LUDOVIC PATEY

Trying to apply naively the algorithm above requires a lot of computational power. In
particular, step 3 requires to choose a true formula among finitely many Π0,X
formulas. Such a
2
step needs the power of PA degree relative to the jump of X. We shall apply the same trick as
for cohesiveness, consisting in not trying to choose a true Π0,X
formula, but instead parallelizing
2
the construction. Given a finite set E ⊂ X, instead of finding an infinite subset Ỹ ⊂ X r E
whose members induce a 2-partition of E, we will construct as many extensions of (F, X) as
there are 2-partitions of E. The question now becomes
Q2: Is there a finite set E ⊆ X such that for every 2-partition hE0 , E1 i of E, there exists an
R-transitive subset F1 ⊆ Ei for some i < 2 such that ϕ(F ∪ F1 ) holds?
This question is Σ0,X
1 , which is good enough for our purposes. If the answer is positive, we
will try the witness F1 associated to each 2-partition of E in parallel. Note that there may be
some 2-partition hE0 , E1 i of E such that the set Y = {x ∈ X r E : E0 →R {x} →R E1 } is finite,
but this is not a problem since there is at least one good 2-partition such that the corresponding
set is infinite. The whole construction yields again a tree of pairs (F, X).
If the answer is negative, we want to ensure that ϕ(F̃ ) will not hold at any further stage
of the construction. For each n ∈ ω, let Hn be the set of the n first elements of X. Because
the answer is negative, for each n ∈ ω, there exists a 2-partition hE0 , E1 i of Hn such that
for every R-transitive subset F1 ⊆ Ei for any i < 2, ϕ(F ∪ F1 ) does not hold. Call such a
2-partition an avoiding partition of Hn . Note that if hE0 , E1 i is an avoiding partition of Hn+1 ,
then hE0 ↾n, E1 ↾ni is an avoiding partition of Hn . So the set of avoiding 2-partitions of some Hn
forms an infinite tree T . Moreover, the predicate “hE0 , E1 i is an avoiding partition of Hn ” is
∆10,Hn so the tree T is ∆0,X
1 . The collection of the infinite paths through T forms a non-empty
0,X
Π1 class C defined as the collection of 2-partitions Z0 ∪ Z1 = X such that for every i < 2 and
every R-transitive subset F1 ⊆ Zi , ϕ(F ∪ F1 ) does not hold.
The natural next step would be to apply weak König’s lemma to obtain a 2-partition of X
such that for every finite R-transitive subset F1 of any of its parts, ϕ(F ∪ F1 ) does not hold. By
the low basis theorem, we could take the 2-partition to be low over X and the whole construction
would remain ∆02 . However, when iterating the construction, we will be given only finite pieces
of tournaments since the tournament may depend on an oracle being constructed at a previous
iteration. In this setting, it will be impossible to compute a member of the Π0,X
class C of
1
2-partitions, since we will have access to only a finite piece of the corresponding tree T . In
order to get progressively prepared to the iterated forcing, we will not apply WKL and will
work with Π01 classes of 2-partitions. Therefore, if the answer is negative, we duplicate the
finite R-transitive F into two sets F0 = F1 = F , and commit Fi to take from now on its next
elements from Xi for some 2-partition X0 ∪ X1 = X belonging to the Π01 class C of 2-partitions
witnessing the negative answer. Iterating the process by asking several questions leads to tuples
(F0 , . . . , Fk−1 , C) where Fi is a finite R-transitive set taking its elements from the ith part of
the class C of k-partitions. This notion of forcing will be defined formally in a later section.
3.2. Enumerating the computable infinite tournaments
Proving that some principle P does not computably reduce to Q requires to create a Pinstance X such that every X-computable Q-instance has a solution Y such that Y ⊕X does not
compute a solution to X. In the case of AMT 6≤c COH, we have been able to restrict ourselves to
only one instance of COH, since Jockusch and Stephan [16] showed it admits a universal instance.
It is currently unknown whether the Erdős-Moser theorem admits a universal instance, that is, a
computable infinite tournament such that for every infinite transitive subtournament H and for
every computable infinite tournament T , H computes an infinite transitive T -subtournament.
See [23] for an extensive study of the existence of universal instances for principles in reverse
mathematics.
Since we do not know whether EM admits a universal instance, we will need to diagonalize
against the solutions to every computable EM-instance. In fact, we will prove a stronger result.
We will construct a ∆02 function f and an infinite set G which is eventually transitive simultaneously for every computable infinite tournament, and such that f dominates every G-computable

DOMINATING THE ERDŐS-MOSER THEOREM

9

function. There exists no computable sequence of sets containing all computable sets. Therefore
it is not possible to computably enumerate every infinite computable tournament. However,
one can define an infinite, computable, binary tree such that every infinite path computes such
a sequence. See the notion of sub-uniformity defined by Mileti in [20] for details. By the low
basis theorem, there exists a low set bounding a sequence containing, among others, every infinite computable tournament. As we shall prove below, for every set C and every uniformly
~ there exists a set G together with a ∆0,C
C-computable sequence of infinite tournaments R,
2
function f such that
~
(i) G is eventually R-transitive for every R ∈ R
G⊕C
is total, then it is dominated by f for every e ∈ ω.
(ii) If Φe
~ to be a uniformly C-computable sequence
Thus it suffices to choose C to be our low set and R
of infinite tournaments containing every computable tournament to deduce the existence of a
set G together with a ∆02 function f such that
(i) G is eventually R-transitive for every infinite, computable tournament R
is total, then it is dominated by f for every e ∈ ω
(ii) If ΦG⊕C
e
By the computable equivalence between AMT and the escape property, there exists a computable atomic theory T such that every atomic model computes a function g not dominated
by f . If AMT ≤c EM, then there exists an infinite, computable tournament R such that every
infinite R-transitive subtournament computes a model of T , hence computes a function g not
dominated by f . As the set G is, up to finite changes, an infinite R-transitive subtournament,
G computes such a function g, contradicting our hypothesis. Therefore AMT 6≤c EM.
3.3. Cover classes
In this part, we introduce some terminology about classes of k-covers. Recall that a k-cover
of some set X is a k-uple A0 , . . . , Ak−1 such that A0 ∪ · · · ∪ Ak−1 = X. In particular, the sets
are not required to be pairwise disjoint.
Cover class.
L We identify a k-cover Z0 ∪ · · · ∪ Zk−1 of some set X with the k-fold join of its
parts Z = i<k Zi , and refer this as a code for the cover. A k-cover class of some set X is a
tuple hk, X, Ci where C is a collection of codes of k-covers of X. We will be interested in Π01
k-cover classes. A part of a k-cover class hk, X, Ci is a number ν < k. Informally, a part ν
represents the collection of all Zν , where Z0 ⊕ · · · ⊕ Zk−1 ∈ C. For the simplicity of notation,
we may use the same letter C to denote both a k-cover class (k, X, C) and the actual collection
of k-covers C. We then write dom(C) for X and parts(C) for k.
Restriction of a cover. Given some k-cover Z = Z0 ⊕ · · · ⊕ Zk−1 of some set X and given some
set Y ⊆ X, we write Z ↾ Y for the k-cover (Z0 ∩ Y ) ⊕ · · · ⊕ (Zk−1 ∩ Y ) of Y . Similarly, given
some cover class (k, X, C) and some set Y ⊆ X, we denote by C ↾ Y the cover class (k, Y, D)
where D = {Z ↾ Y : Z ∈ C}. Given some part ν of C and some set E, we write C [ν,E] for the
cover class (k, X, D) where D = {Z0 ⊕ · · · ⊕ Zk−1 ∈ C : E ⊆ Zν }.
Refinement. The collection of cover classes can be given a natural partial order as follows.
Let m ≥ k and f : m → k. An m-cover V0 ⊕ · · · ⊕ Vm−1 of Y f -refines a k-cover Z0 ⊕ · · · ⊕ Zk−1
of X if Y ⊆ X and Vν ⊆ Zf (ν) for each ν < m. Given two cover classes (k, X, C) and (m, Y, D)
and some function f : m → k, we say that D f -refines C if for every V ∈ D, there is some Z ∈ C
such that V f -refines Z. In this case, we say that part ν of D refines part f (ν) of C.
Acceptable part. We say that part ν of C is acceptable if there exists some Z0 ⊕ · · · ⊕ Zk−1 ∈ C
such that Zν is infinite. Part ν of C is empty if for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C, Zν = ∅. Note that
if C is non-empty and dom(C) is infinite, then C has at least one acceptable part. Moreover,
if D ≤f C and part ν of D is acceptable, then so is part f (ν) of C. The converse does not hold
in general.
3.4. The forcing notion
We now get into the core of our forcing argument by defining the forcing notion which will
be used to build an infinite set eventually transitive for every infinite computable tournament.

10

LUDOVIC PATEY

Fix a set C and a uniformly C-computable sequence of infinite tournaments R0 , R1 , . . . We
construct our set G by a forcing whose conditions are tuples (α, F~ , C) where
(a) C is a non-empty Π0,C
k-cover class of [t, +∞) for some k, t ∈ ω ; α ∈ t<ω
1
(b) (Fν r [0, α(i))) ∪ {x} is Ri -transitive for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C, every x ∈ Zν , every
i < |α| and each ν < k
(c) Zν is included in a minimal Ri -interval of Fν r [0, α(i)) for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C,
every i < |α| and each ν < k.
~ D) extends (α, F~ , C) (written (β, E,
~ D) ≤ (α, F~ , C)) if β  α and there exists
A condition (β, E,
a function f : parts(D) → parts(C) such that the following holds:
(i) (Eν , dom(D)) Mathias extends (Ff (ν) , dom(C)) for each ν < parts(D)
(ii) D f -refines C [f (ν),Eν rFf (ν) ] for each ν < parts(D)
One may think of a condition (α, F~ , C) with, say, parts(C) = k, as k parallel Mathias conditions which are, up to finite changes, Erdős-Moser conditions simultaneously for the tournaments
R0 , . . . , R|α|−1 . Given some i < |α|, the value α(i) indicates at which point the sets F~ start
being Ri -transitive. More precisely, for every part ν < k and every k-cover Z0 ⊕ · · · ⊕ Zk−1 ∈ C,
(Fν r [0, α(i)), Zν ) is an Erdős-Moser condition for Ri for each i < |α|. Indeed, because of
clause (i), the elements Eν r Ff (ν) added to Eν come from dom(C) and because of clause (ii),
these elements must come from the part f (ν) of the class C, otherwise C [f (ν),Eν rFf (ν) ] would be
empty and so would be D.
Of course, there may be some parts ν of C which are non-acceptable, that is, such that Zν
is finite for every k-cover Z0 ⊕ · · · ⊕ Zk−1 ∈ C. However, by the infinite pigeonhole principle,
Zν must be infinite for at least one ν < k. Choosing α to be in t<ω instead of ω <ω ensures
that all elements added to F~ will have to be Ri -transitive simultaneously for each i < |α|,
as the elements are taken from dom(C) and therefore are greater than the threshold α(i) for
each i < |α|. A part of a condition c = (α, F~ , C) is a pair hc, νi, where ν < parts(C). For
the simplicity of notation, we may identify a part hc, νi of a condition with the part ν of the
corresponding cover class C. It must however be clear that a part depends on the condition c.
We start with a few basic lemmas reflecting the combinatorics described in the subsection 3.1.
They are directly adapted from the basic properties of an Erdős-Moser condition proven in [23].
The first lemma states that each element of the finite transitive tournaments F~ behaves uniformly with respect to the elements of the reservoir, that is, is beaten by every element of the
reservoir or beats all of them.
Lemma 3.3 For every condition c = (α, F~ , C), every Z0 ⊕ · · · ⊕ Zk−1 ∈ C, every part ν of C,
every i < |α| and every x ∈ Fν r [0, α(i)), either {x} →Ri Zν or Zν →Ri {x}.
Proof. By property (c) of the condition c, there exists a minimal Ri -interval (u, v) of Fν r[0, α(i))
containing Zν . Here, u and v may be respectively −∞ and +∞. By definition of an interval,
{u} →Ri Zν →Ri {v}. By definition of a minimal interval, Ri (x, u) or Ri (v, x) holds. Suppose
the former holds. By transitivity of Fν r [0, α(i)), for every y ∈ Zν , Ri (x, y) holds, since
both Ri (x, u) and Ri (u, y) hold. Therefore {x} →Ri Zν . In the latter case, by symmetry,
Zν →Ri {x}.

The second lemma is the core of the combinatorics of the Erdős-Moser theorem. It provides
sufficient properties to obtain a valid extension of a condition. Properties (i) and (ii) are simply
the definition of an extension. Properties (iii) and (iv) help to propagate properties (b) and
(c) from a condition to its extension. We shall see empirically that properties (iii) and (iv)
are simpler to check than (b) and (c), as the former properties match exactly the way we add
elements to our finite tournaments F~ . Therefore, ensuring that these properties are satisfied
usually consists of checking that we followed the standard process of adding elements to F~ .

DOMINATING THE ERDŐS-MOSER THEOREM

11

Lemma 3.4 Fix a condition c = (α, F~ , C) where C is a k-cover class of [t, +∞). Let E0 , . . . , Em−1
be finite sets, D be a non-empty Π0,C
m-cover class of [t′ , +∞) for some t′ ≥ t and f : m → k
1
be a function such that for each i < |α| and ν < m,
(iii) Eν is Ri -transitive
(iv) Vν →Ri Eν or Eν →Ri Vν for each V0 ⊕ · · · ⊕ Vm−1 ∈ D
Set Hν = Ff (ν) ∪ Eν for each ν < m. If properties (i) and (ii) of an extension are satisfied
~ D) with witness f , then d is a valid condition extending c.
for d = (α, H,
Proof. All we need is to check properties (b) and (c) for d in the definition of a condition. We
prove property (b). Fix an i < |α|, some part ν of D, and an x ∈ Vν for some V0 ⊕· · ·⊕Vm−1 ∈ D.
In order to prove that (Ff (ν) ∪ Eν ) r [0, α(i)) ∪ {x} is Ri -transitive, it is sufficient to check that
the set contains no 3-cycle. Fix three elements u < v < w ∈ (Ff (ν) ∪ Eν ) r [0, α(i)) ∪ {x}.
− Case 1: {u, v, w} ∩ Ff (ν) r [0, α(i)) 6= ∅. Then u ∈ Ff (ν) r [0, α(i)) as Ff (ν) < Eν < {x}
and u < v < w. By property (ii), there is some Z0 ⊕ · · · ⊕ Zk−1 ∈ C such that
Eν ∪{x} ⊆ Zf (ν) . If v ∈ Ff (ν) , then by property (b) of the condition c on Zf (ν) , {u, v, w}
is Ri -transitive. If v 6∈ F , then by Lemma 3.3, {u} →Ri Zf (ν) or Zf (ν) →Ri {u}, so
{u, v, w} is Ri -transitive since v, w ∈ Zf (ν) .
− Case 2: {u, v, w} ∩ Ff (ν) r [0, α(i)) = ∅. Then at least u, v ∈ Eν because Eν < {x}.
If w ∈ Eν then {u, v, w} is Ri -transitive by Ri -transitivity of Eν . In the other case,
w = x ∈ Vν . As Eν →Ri Vν or Vν →Ri Eν , {u, v} →Ri {w} or {w} →Ri {u, v} and
{u, v, w} is Ri -transitive.
We now prove property (c) for d. Fix some V0 ⊕ · · · ⊕ Vm−1 ∈ D, some part ν of D and some
i < |α|. By property (ii), there is some Z0 ⊕ · · · ⊕ Zk−1 ∈ C such that Eν ∪ Vν ⊆ Zf (ν) . By
property (c) of the condition c, Zf (ν) (and so Vν ) is included in a minimal Ri -interval (u, v) of
Ff (ν) r [0, α(i)). Here again, u and v may be respectively −∞ and +∞. By assumption, either
Eν →Ri Vν or Vν →Ri Eν . As Eν is a finite Ri -transitive set, it has a minimal and a maximal
element, say x and y. If Eν →Ri Vν then Vν is included in the Ri -interval (y, v). Symmetrically,
if Vν →Ri Eν then Vν is included in the Ri -interval (u, x). To prove minimality for the first
case, assume that some w is in the interval (y, v). Then w 6∈ Ff (ν) r [0, α(i)) by minimality of
the interval (u, v) with respect to Ff (ν) r [0, α(i)), and w 6∈ Eν by maximality of y. Minimality
for the second case holds by symmetry.

Now we have settled the necessary technical lemmas, we start proving lemmas which will
be directly involved in the construction of the transitive subtournament. The following simple
progress lemma states that we can always find an extension of a condition in which we increase
both the finite approximations corresponding to the acceptable parts and the number of tournaments for which we are transitive simultaneously. Moreover, this extension can be found
uniformly.
Lemma 3.5 (Progress) For every condition c = (α, F~ , C) and every s ∈ ω, there exists an
~ D) such that |β| ≥ s and |Eν | ≥ s for every acceptable part ν of D.
extension d = (β, E,
Furthermore, such an extension can be found C ′ -effectively, uniformly in c and s.
Proof. Fix a condition c = (α, F~ , C). First note that for every β  α such that β(i) > max(Fν :
ν < parts(C)) whenever |α| ≤ i < |β|, (β, F~ , C) is a condition extending c. Therefore it suffices
to prove that for every such condition c and every part ν of C, we can C ′ -effectively find a
~ , D) refining c with witness f : parts(D) → parts(C) such that f forks only
condition d = (α, H
parts refining part ν of C, and either every such part µ of D is empty or |Hµ | > |Fν |. Iterating
the process finitely many times enables us to conclude.
Fix some part ν of C and let D be the collection of Z0 ⊕ · · · ⊕ Zk−1 ∈ C such that Zν = ∅. We
can C ′ -decide whether or not D is empty. If D is non-empty, then (α, F~ , D) is a valid extension
of c with the identity function as witness and such that part ν of D is empty. If D is empty,
we can C ′ -computably find some Z0 ⊕ · · · ⊕ Zk−1 ∈ C and pick some x ∈ Zν . Consider the

12

LUDOVIC PATEY

C-computable 2|α| -partition (Xρ : ρ ∈ 2|α| ) of ω defined by
Xρ = {y ∈ ω : (∀i < |α|)[Ri (y, x) ↔ ρ(i) = 1]}
Let D̃ be the cover class refining C [ν,x] such that part ν of D̃ has 2|α| forks induced by the
~ Define H
~ by Hµ = Fµ if µ refines a part different from ν, and Hµ = Fν ∪ {x}
2|α| -partition X.
~ ensures that property (iv) of Lemma 3.4
if µ refines part ν of C. The forking according to X
~ D̃) is a valid extension of c.
holds. By Lemma 3.4, d = (α, H,

3.5. The strategy
Thanks to Lemma 3.5, we can define an infinite, C ′ -computable decreasing sequence of conditions (ε, ∅, {ω}) ≥ c0 ≥ c1 ≥ . . . such that for each s ∈ ω,
1. |αs | ≥ s.
2. |Fs,ν | ≥ s for each acceptable part ν of Cs
where cs = (αs , F~s , Cs ). As already noticed, if some acceptable part µ of Cs+1 refines some
part ν of Cs , part ν of Cs is also acceptable. Therefore, the set of acceptable parts forms an
′
infinite, finitely
S branching C -computable tree T . Let P be any infinite path through T . The
set H(P ) = ( s Fs,P (s) ) is infinite, and H(P ) r [0, αi+1 (i)) is Ri -transitive for each i ∈ ω.
Our goal is to build a C ′ -computable function dominating every function computed by H(P )
for at least one path P trough T . However, it requires too much computational power to
distinguish acceptable parts from non-acceptable ones, and even some acceptable part may have
only finitely many extensions. Therefore, we will dominate the functions computed by H(P )
for every path P trough T .
At a finite stage, a condition contains finitely many parts, each one representing the construction of a transitive subtournament. As in the construction of a cohesive set, it suffices to check
one by one whether there exists an extension of our subtournaments which will make terminate
a given functional at a given input. In the next subsection, we develop the framework necessary
to decide such a termination at a finite stage.
3.6. Forcing relation
As a condition c = (α, F~ , C) corresponds to the construction of multiple subtournaments
F0 , F1 , . . . at the same time, the forcing relation will depend on which subtournament we are
considering. In other words, the forcing relation depends on the part ν of C we focus on.
Definition 3.6 Fix a condition c = (α, F~ , C), a part ν of C and two integers e, x.
(F ∪F )⊕C

(x) ↑ for all Z0 ⊕ · · · ⊕ Zk−1 ∈ C and all subsets F1 ⊆ Zν
1. c ν ΦeG⊕C (x) ↑ if Φe ν 1
such that F1 is Ri -transitive simultaneously for each i < |α|.
2. c ν ΦG⊕C
(x) ↓ if ΦeFν ⊕C (x) ↓.
e
The forcing relations defined above satisfy the usual forcing properties. In particular, let
c0 ≥ c1 ≥ . . . be an infinite decreasing sequence of conditions. This sequence induces an
infinite, finitely branching tree of acceptable parts T . Let P be an infinite path trough T . If
H(P )⊕C
(x) ↓) at some stage s, then Φe
(x) ↑
cs P (s) ΦeG⊕C (x) ↑ (respectively cs P (s) ΦG⊕C
e
H(P )⊕C

(respectively Φe
(x) ↓).
Another important feature of this forcing relation is that we can decide C ′ -uniformly in its
(x) to halt or to diverge. Deciding
parameters whether there is an extension forcing ΦG⊕C
e
this relation with little computational power is useful because our C ′ -computable dominating
function will need to decide termination ΓG⊕C (x) to check whether it has to dominate the value
outputted by ΓG⊕C (x).
Lemma 3.7 For every condition c = (α, F~ , C) and every pair of integers e, x ∈ ω, there exists
~ D) such that for each part ν of D
an extension d = (α, H,
d ν ΦG⊕C
(x) ↑
e

∨ d ν ΦG⊕C
(x) ↓
e

DOMINATING THE ERDŐS-MOSER THEOREM

13

Furthermore, such an extension can be found C ′ -effectively, uniformly in c, e and x.
Proof. Given a condition c and two integers e, x ∈ ω, let Ie,x (c) be the set of parts ν of c such
(x) ↑. Note that Ie,x (c) is C ′ -computable uniformly in c,
(x) ↓ and c 6ν ΦG⊕C
that c 6ν ΦG⊕C
e
e
e and x. It suffices to prove that given such a condition c and a part ν ∈ Ie,x (c), one can
C ′ -effectively find an extension d with witness f such that f (Ie,x (d)) ⊆ Ie,x (c) r {ν}. Applying
iteratively the operation enables us to conclude.
Fix a condition c = (α, F~ , C) where C is a k-cover class, and fix some part ν ∈ Ie,x (c).
The strategy is the following: either we can fork part ν of C into enough parts so that we
force ΦeG⊕C (x) to diverge on each forked part, or we can find an extension forcing ΦG⊕C
(x) to
e
converge on part ν without forking. Hence, we ask the following question.
S
Q2: Is it true that for every k-cover Z0 ⊕ · · · ⊕ Zk−1 ∈ C, for every 2|α| -partition ρ∈2α Xρ =
Zν , there is some ρ ∈ 2|α| and some finite set F1 which is Ri -transitive for each i < |α|
(F ∪F )⊕C
simultaneously, and such that Φe ν 1
(x) ↓?
If the answer is no, then by forking the part ν of C into 2|α| parts, we will be able to
force ΦeG⊕C (x) to diverge. Let m = k + 2|α| − 1 and define the function f : m → k by f (µ) = µ
if µ < k and f (µ) = ν otherwise. Let D be the collection of all m-covers V0 ⊕ · · · ⊕ Vm−1 which
f -refine some Z0 ⊕ · · · ⊕ Zk−1 ∈ C and such that for every part µ of D f -refining part ν of C and
every subset F1 ⊆ Vµ which is Ri -transitive simultaneously for each i < |α|, ΦFe ν ∪F1 (x) ↑. Note
that D is a Π0,C
m-cover class f -refining C. Moreover D is non-empty since the answer to Q2 is
1
~ be defined by Eµ = Fµ if µ < k and Eµ = Fν otherwise. The condition d = (α, E,
~ D)
no. Let E
G⊕C
extends c with witness f . For every part µ of D f -refining part ν of C, d µ Φe (x) ↑,
therefore f (Ie,x (d)) ⊆ Ie,x (c) r {ν}.
Suppose now that the answer is yes. By compactness, we can C ′ -effectively find a finite
set E ⊆ Zν for some Z0 ⊕ · · · ⊕ Zk−1 ∈ C such that for every 2|α| -partition (Eρ : ρ ∈ 2|α| ) of
E, there is some ρ ∈ 2|α| and some set F1 ⊆ Eρ which is Ri -transitive simultaneously for each
(F ∪F )⊕C
i < |α| and such that Φe ν 1
(x) ↓. There are finitely many 2|α| -partitions of E. Let n
be the number of such partitions. These partitions induce a finite C-computable n-partition
of dom(C) defined for each (Eρ : ρ ∈ 2|α| ) by



if ρ(i) = 0 then Eρ →Ri {y}
XhEρ :ρ∈2|α| i = y ∈ dom(C) : (∀i < |α|)
if ρ(i) = 1 then {y} →Ri Eρ
Let D̃ be the Π0,C
(k + n − 1)-cover class refining C [ν,E] and such that part ν of C [ν,E] is refined
1
accordingly to the above partition of dom(C). Let f : k + n − 1 → k be the refining function
~ as follows. For every part µ of D, refining part ν of C [ν,E] , by definition
witnessing it. Define H



|α|
of D̃, there is some 2 -partition Eρ : ρ ∈ 2|α| of E such that for every V0 ⊕ . . . Vk+n−2 ∈ D̃,
Vµ ⊆ XhEρ :ρ∈2|α| i . By choice of E, there exists some set F1 ⊆ Eρ for some ρ ∈ 2|α| which is
(F ∪F )⊕C

Ri -transitive simultaneously for each i < |α| and such that Φe ν 1
(x) ↓. This set F1 can
be found C ′ -effectively. Set Hµ = Fν ∪ F1 . For every part µ of D̃ which refines some part ξ
~ D̃) is a valid condition
of C [ν,E] different from ν, set Hµ = Fξ . By Lemma 3.4, d = (α, H,
(x) ↓. Therefore
extending c. Moreover, for every part µ of D̃ refining part ν of C, d µ ΦG⊕C
e
f (Ie,x (d)) ⊆ Ie,x (c) r {ν}.

3.7. Construction
We are now ready to construct our infinite transitive subtournament H(P ) together with
a C ′ -computable function f dominating every H(P ) ⊕ C-computable function. Thanks to
Lemma 3.5 and Lemma 3.7, we can C ′ -compute an infinite descending sequence of conditions
(ǫ, ∅, 1<ω ) ≥ c0 ≥ c1 ≥ . . . such that at each stage s ∈ ω,
1. |αs | ≥ s
2. |Fs,ν | ≥ s for each acceptable part ν of Cs
3. cs ν ΦG⊕C
(x) ↓ or cs ν ΦG⊕C
(x) ↑ for each part ν of Cs if he, xi = s
e
e

14

LUDOVIC PATEY

where cs = (αs , F~s , Cs ). Property 1 ensures that the resulting set with be eventually transitive
~ Property 2 makes the subtournaments infinite. Last, property 3
for every tournament in R.
′
enables us to C -decide at a finite stage whether a functional terminates on a given input, with
the transitive subtournament as an oracle.
Define the C ′ -computable function f : ω → ω as follows: On input x, the function f looks at
all stages s such that s = he, xi for some e ≤ x. For each such stage s, and each part ν in Cs , the
function C ′ -decides whether cs ν ΦG⊕C
(x) ↓ or cs ν ΦG⊕C
(x) ↑. In the first case, f computes
e
e
Fs,ν ⊕C
the value Φe
(x). Having done all that, f returns a value greater than the maximum of the
computed values.
Fix any infinite path P trough the infinite tree T of the acceptable parts induced by the
infinite descending sequence of conditions. We claim that f dominates every function computed
H(P )⊕C
by H(P )⊕ C. Fix any Turing index e ∈ ω such that Φe
is total. Consider any input x ≥ e
H(P )⊕C
is total, cs 6P (s) ΦG⊕C
(x) ↑, hence by
and the corresponding stage s = he, xi. As Φe
e
F

property 3, cs P (s) ΦeG⊕C (x) ↓. By construction, f (x) computes the value of Φe s,P (s)
returns a greater value. As Fs,P (s) is an initial segment of H(P ),

F
⊕C
Φe s,P (s) (x)

=

⊕C

(x) and

H(P )⊕C
(x)
Φe

H(P )⊕C
Φe
(x).

and therefore f (x) >
This completes the proof of AMT 6≤c EM.
We identify a k-cover Z0 ∪ · · · ∪ Zk−1 of some set X with the k-fold join of its parts
4. The domination framework
The actual proof of Theorem 3.1 is slightly stronger than its statement as it creates a degree d
bounding EM together with a computable instance X of AMT such that d bounds no solution
to X. Therefore, having solutions to multiple tournaments in parallel is not enough to compute
a solution to X. One may however ask whether sequential applications of EM (that is, defining a
tournament such that every transitive subtournament will be used to define another tournament
and so on) is enough to compute a solution to X.
Answering negatively this question requires to diagonalize against solutions Y0 to computable
instances of EM, but also against solutions Y1 to Y0 -computable instances of EM and so on. The
difficulty comes from the fact that diagonalizations happen at finite stages, at which we have only
access to a finite approximation of Y0 , and so to a finite part of the Y0 -computable instances
of EM. Thankfully, we only need a finite piece of an EM-instance to diagonalize against its
solutions.
In this section, we develop a framework for building an ω-structure M satisfing some principle
P such that every function in M is dominated by a single ∅′ -computable function. Since by
definition, the first-order part of an ω-structure is the set of standard natural numbers, ωstructures are characterized by their second-order part. An ω-structure satisfies RCA0 if and
only if its second-order part is a Turing ideal, i.e., a set of reals I closed under the effective join
and the Turing reduction.
The whole construction will be done by iterating uniformly and ∅′ -effectively the forcing
constructions presented in the previous sections. We will not directly deal with the concrete
forcing notion used for constructing solutions to EM-instances. Instead, we will manipulate an
abstract partial order of forcing conditions. Abstracting the construction has several advantages:
1. It enables the reader to focus on the operations which are the essence of the construction.
The reader will not be distracted by the implementation subtleties of EM which are not
insightful to understand the overall structure.
2. The construction is more modular. We will be able to implement modules for EM
and WKL independently, and combine them in section 6 to obtain a proof that EM ∧
WKL does not imply AMT, and this without changing the main construction. This also
enable reverse mathematicians to prove that other principles do not imply AMT without
having to reprove the administrative aspects of the construction.
We shall illustrate our definitions with the case of COH in order to give a better intuition
about the abstract operators we will define. As explained in section 3, the separation of COH

DOMINATING THE ERDŐS-MOSER THEOREM

15

from AMT is already a consequence of the separation of EM from AMT. Therefore implementing
the framework with COH is only for illustration purposes.
4.1. Support
The first step consists of defining the abstract partial order which will represent the partial
order of forcing conditions. We start with an analysis of the common aspects of the different
forcing notions encountered until yet, in order to extract their essence and define the abstract
operators. In the following, we shall employ stage to denote a temporal step in the construction.
An iteration is a spatial step representing progress in the construction of the Turing ideal.
Multiple iterations are handled at a single stage.
Parts of a condition. When constructing cohesive sets for COH or transitive subtournaments
for EM, we have been working in both cases with conditions representing parallel Mathias
conditions. We shall therefore associate to our abstract notion of condition a notion of part
representing one of the solutions we are building. A single abstract condition will have multiple
parts representing the various candidate solutions constructed in parallel for the same instance.
For example, in the forcing notion for COH, a condition c = (Fν : ν ∈ 2n ) can be seen as 2n
parallel Mathias conditions (Fν , Rν ) where R0 , R1 , . . . is the universal instance of COH. In this
setting, the parts of c are the pairs hc, νi for each ν ∈ 2n . One may be tempted to get rid of the
notion of condition and directly deal with its parts since in COH, a condition is only the tuple of
~ , C) for EM, the parts are interdependent since
its parts. However, in the forcing notion c = (F
adding element to some Fν will remove inconsistent covers from C and therefore may restrict
the reservoirs of the other parts.
Satisfaction. As explained, a part represents the construction of one solution, whereas a
condition denotes multiple solutions in parallel. We can formalize this intuition by defining
a satisfaction function which, given a part of a condition, returns the collection of the sets
satisfying it. For example, a set G satisfies part ν of the COH condition c = (Fν : ν ∈ 2n )
if it satisfies the Mathias condition (Fν , Rν r [0, max(F )]), in other words, if Fν ⊆ G and
G r Fν ⊆ Rν r [0, max(Fν )].
ge
Sta

0

c0

ge
Sta

1

c1

2

c2
d0,1

d0,0

ge
Sta

ge
Sta

c3
d1,1

First iteration

d2,2

d1,0

3

d2,1

Second iteration

d2,0
e0,2
e0,1

Third iteration

e0,0

Figure 2. Example of construction of a Turing ideal by an iterative forcing in
which conditions may have multiple parts. The nodes are the conditions, the
dotted edges are condition extensions and the plain edges are the parts of the
conditions.
Initial condition. In a standard (i.e. non-iterative) forcing, we build an infinite decreasing
sequence of conditions, starting from one initial condition c0 . In COH, this initial condition
is (∅, ε), where ε is the empty string. Since Rε = ω, this coincides with the standard initial
Mathias condition (∅, ω). In an iterative forcing, we add progressively new iterations by starting
a new decreasing sequence of conditions below each part of the parent condition. Since COH
admits a universal instance, there is no need to choose which instance we want to solve at
each iteration. However, in the case of EM, we will take a new EM-instance each time, so that

16

LUDOVIC PATEY

the resulting Turing ideal is the second-order part of an ω-model satisfying EM. Therefore, an
~ , C, R) where R is an instance of EM. The chosen instance
EM-condition is in fact a condition (F
of EM will be decided at the initialization of a new iteration and will be preserved by condition
extension. The choice of the instance depends only on the iteration level. Therefore we can
define an initialization function which, given some integer, returns the initial condition together
with the chosen instance.
Parameters. The difficulty of the iterative forcing comes from the fact that an instance of
the principle P may depend on the previous iterations. During the construction, the partial
approximations of the previous iterations become more and more precise, enabling the instance
at the next iteration to be defined on a larger domain. In the definition of our abstract partial
order, we will use a formal parameter D which will represent the join of the constructed solutions
in the previous iterations. For example, in the formal definition of the partial order for COH,
we will say that some condition d = (Eµ : µ ∈ 2m ) extends another condition c = (Fν : ν ∈ 2n )
if m ≥ n, and (Eµ , RµD r [0, max(Eµ )]) Mathias extends (Fν , RνD r [0, max(Fν )]) for each ν  µ.
This syntactic constraints has to be understood as (Eµ , RµX r [0, max(Eµ )]) Mathias extends
(Fν , RνX r [0, max(Fν )]) for every set X = X0 ⊕ · · · ⊕ Xn−1 such that Xi satisfies the ancestor
of d in the iteration axis at the ith level. In the case of COH, only a finite initial segment of X
is needed to witness the extension.
We are now ready to define the notion of module support.
Definition 4.1 (Module support) A Module support is a tuple hP, U, parts, init, sati where
(1) (P, ≤P ) is a partial order. The set P has to be thought of as the set of forcing conditions.
Therefore, the elements of P will be called conditions.
(2) U is a set of parts. The notion of part is due to the fact that most of our forcing
conditions represent multiple objects built in parallel.
(3) parts : P → Pf in (U) is a computable function which, given some condition c ∈ P, gives
the finite set of parts associated to c.
(4) init : N → P is a computable function which, given some integer n representing the
iteration level, provides the initial condition of the forcing at the nth iteration.
(5) sat : U → P(2ω ) is a function which, given some part ν of some condition c, returns
the collections of sets satisfying it.
Furthermore, a module support is required to satisfy the following property:
(a) If d ≤P c for some c, d ∈ P, then there is a function f : parts(d) → parts(c) such that
sat(ν) ⊆ sat(f (ν)) for each ν ∈ parts(d). We may write it d ≤f c and say that f is
the refinement function witnessing d ≤P c.
Given two conditions c, d ∈ P such that d ≤f c, we say that f forks part ν of c if |f −1 (ν)| ≥ 2.
This forking notion will be useful in the definition of a module. Let us illustrate the notion of
module support by defining one for COH.
Module support for COH. Define the tuple hP, U, parts, init, sati as follows: P is the collection of all conditions (Fν : ν ∈ 2n ) where Fν is a finite set of integers. Given some d =
(Eµ : µ ∈ 2m ) and c = (Fν : ν ∈ 2n ), d ≤P c if m ≥ n, and (Eµ , RµD r [0, max(Eµ )]) Mathias
extends (Fν , RνD r [0, max(Fν )]) for each ν  µ. Let U be the set of all pairs h(Fν : ν ∈ 2n ), νi
where ν ∈ 2n . Given some condition c = (Fν : ν ∈ 2n ) ∈ P, parts(c) = {hc, νi : ν ∈ 2n }. For
every level n ≥ 0, init(n) = (∅, ε). Define sat(h(Fν : ν ∈ 2n ), νi) to be the collection of all sets
satisfying the Mathias condition (Fν , Rν r [0, max(Fν )]).
We now check that property (a) holds. Let d = (Eµ : µ ∈ 2m ) and c = (Fν : ν ∈ 2n )
be such that d ≤P c. In particular, m ≥ n. Define f : U → U by f (hd, µi) = hc, µ↾ni. We
claim that f is a refinement function witnessing d ≤P c. sat(hd, µi) is the collection of sets
satisfying the Mathias condition d˜ = (Eµ , Rµ r [0, max(Eµ ))) and sat(hc, µ↾ni) is the collection
of sets satisfying c̃ = (Fµ↾n , Rµ↾n r [0, max(Fµ↾n ))). Since µ↾n  µ, d˜ Mathias extends c̃ by

DOMINATING THE ERDŐS-MOSER THEOREM

17

definition of sat. Considering the Mathias conditions, every set satisfying d˜ satisfies c̃, so
sat(hd, µi) ⊆ sat(f (hd, µi)). Therefore the property (a) of a module support is satisfied.
4.2. Modules
We previously defined the abstract structure we shall use as a support of the construction.
The next step consists of enriching this structure with a few more operators which will enable
us to decide Σ01 properties over the constructed sets. The success or failure in forcing some
property will depend on the parts of a condition. Note that at a finite stage, we handle a finite
tree of conditions. We can therefore cover all cases by asking finitely many questions. Let us
go back to the COH example, and more precisely how we decided Σ01 properties over it.
Iteration 1. At the first iteration, we would like to decide whether the Σ0,G
formula
1
ψ(G) = (∃s, m)(ΦG
e,s (n) ↓= m)
will hold, where G is a formal parameter denoting the constructed set. Furthermore, we want to
collect the value of ΦG
e (n) if it halts. The formula ψ(G) can be seen as a query, whose answers
are either hNoi if ψ(G) does not hold, or a tuple hYes, s, mi such that ΦG
e,s (n) ↓= m if ψ(G)
holds. Given some condition c = (Fν : ν ∈ 2n ), we can ask on each part hc, νi whether the
formula ϕ(G) will hold or not, by boxing the query ψ(G) into a Σ01 query φ without the formal
parameter G, such that φ holds if and only if we can find an extension d of c forcing ψ(G) on
the parts of d refining part ν of c. Concretely, we can define φ as follows:
φ = (∃F1 ⊆ Rν r [0, max(Fν )])ψ(Fν ∪ F1 )
∅′ -decided.

This query can be
If the formula φ holds, we can effectively find some answer to φ,
Fν ∪F1 (n) ↓= m. The
that is, a tuple hYes, F1 , s, mi such that F1 ⊆ Rν r [0, max(Fν )] and Φe,s
extension d obtained by adding F1 to Fν forces ψ(G) to hold for every set G satisfying the
part hd, νi of the condition d. The answer to ψ(G) is obtained by forgetting the set F1 from
the answer to φ. On the other hand, if the formula φ does not hold, the answer is hNoi and c
already forces ψ(G) not to hold.
Iteration 2. At the second iteration, we work with conditions c1 = (Eµ : µ ∈ 2m ) which are
below some part ν of some condition c0 = (Fν : ν ∈ 2n ) living at the first iteration level. We
want to decide Σ10,G0 ,G1 formulas, where G0 and G1 are formal parameters denoting the sets
contructed at the first iteration and at the second iteration, respectively. We basically want to
answer queries of the form
0 ⊕G1
ϕ(G0 , G1 ) = (∃s, m)(ΦG
(n) ↓= m)
e,s

We will ask this question on each part of c1 . By the same boxing process as before applied
relative to c1 , we obtain a formula ψ(G0 ) getting rid of the formal parameter G1 , and defined
by
ψ(G0 ) = (∃E1 ⊆ RµG0 r [0, max(Eµ )])ϕ(G0 , Eµ ∪ E1 )
The formula ψ(G0 ) is a now a query at the first iteration level. We can apply another boxing
to ψ(G0 ) relative to c0 to obtain a Σ01 formula φ without any formal parameter.
φ = (∃F1 ⊆ Rν r [0, max(Fν )])ψ(Fν ∪ F1 )
This formula can again be ∅′ -decided. If it holds, an answer a = hYes, F1 , E1 , s, mi can be given.
At the first iteration level, we unbox the answer a to obtain a tuple b = hYes, E1 , s, mi and
an extension d0 of c0 . The extension d0 forces the tuple b to answer the query ψ(G0 ) and is
obtained by adding F1 to Fν . At the second iteration level, we unbox again the answer b to
obtain a tuple hYes, s, mi and an extension d1 to c1 , forcing hYes, s, mi to answer the query
ϕ(G0 , G1 ). The whole decision process is summarized in Figure 3.
Progress. We may also want to force some specific properties required by the principle P. In
the case of Ramsey-type principles, we need to force the set G to be infinite. This can be done
with the following query for each k:
(∃n)[n ∈ G ∧ n > k]

18

LUDOVIC PATEY

Construction

Part µ of (Eµ : µ ∈ 2m )

Part ν of (Fν : ν ∈ 2n )

∅′ oracle

Box ϕ(G0 , G1 )
Result: ψ(G0 )
Box ψ(G0 )
Result: φ
Decide φ
Result: (Yes, s, E1 , F1 )
Unbox (Yes, s, E1 , F1 )
Result: (Yes, s, E1 ), d0
Unbox (Yes, s, E1 )
Result: (Yes, s), d1

Figure 3. This sequence diagram shows the boxing process of the Σ10,G0 ,G1
G0 ⊕G1 (x) ↓ into a Σ0 formula without formal paformula ϕ(G0 , G1 ) = (∃s)Φe,s
1
rameters in order to decide it. The formula ϕ(G0 , G1 ) is boxed into a formula
ψ(G0 ) = (∃E1 ⊆ RµG0 r [0, max(Eµ )])ϕ(G0 , Eµ ∪ E1 ) which is itself boxed into
φ = (∃F1 ⊆ Rν r [0, max(Fν )])ψ(Fν ∪ F1 ).
The progress query can take various forms, depending on the considered principle. For
example, in WKL, we need to force the path to be infinite by asking the following question for
each k:
(∃σ ∈ 2k )[σ ≺ G]
We will therefore define some progress operator which outputs some query that the construction
will force to hold or not. We will choose the actual forcing notions so that the formula can be
forced to hold for at least one part of each condition. The parameter k will not be given to the
operator, since it can be boxed into the current condition, in a monadic style.
We are now ready to define the notion of module as a module support enriched with some
~ is the set of all
boxing, unboxing and progress abstract operators. In what follows, Query[X]
0
~
~
Σ1 formulas with X as formal parameters, and Ans[X] is the set of their answers.
Definition 4.2 (Module) A module is a tuple hS, box, unbox, progi where
(1) S = hP, U, parts, init, sati is a module support.
(2) box : U × Query[D, G] → Query[D] is a computable boxing function which, given
some part ν of some condition c ∈ P and some Σ01 formula ϕ(D, G), outputs a Σ01
formula ψ(D).
(3) unbox : U × Ans[D] → P × (U → U) × (U → Ans[D, G]) is a computable function which,
given some part ν of some condition c ∈ P and some answer a to a Σ01 formula ψ(D)
encoding a Σ01 formula ϕ(D, G), outputs a tuple hd, f, gi such that d ≤f c where f forks
only part ν of c, and for every part µ of d such that f (µ) = ν, and every set G ∈ sat(µ),
g(µ) is an answer to ϕ(D, G).
(3) prog : U → Query[D, G] is a computable function which provides a question forcing
some progress in the solution. It usually asks whether we can force the partial approximation to be defined on a larger domain.
Let us go back to the COH case. Define the COH module hS, box, unbox, progi as follows:
S is the COH module support previously defined. Given some condition c = (Fν : ν ∈ 2n ),

DOMINATING THE ERDŐS-MOSER THEOREM

19

some ν ∈ 2n and some query ϕ(D, G), box(hc, νi , ϕ) is the query ψ(D) defined by
ψ(D) = (∃F1 ⊆ RνD r [0, max(Fν )])ϕ(D, Fν ∪ F1 )
Set unbox(hc, νi , hNoi) = hc, id, gi where id is the identity function and g(ν) = hNoi. Given an
answer a = hYes, F1 , a1 i to the question ψ(D), unbox(hc, νi , a) = hd, f, gi where d = (Eµ : µ ∈
2n ) is an extension of c such that Eν = Fν ∪ F1 , and Eµ = Fµ whenever µ 6= ν. The function f :
U → U is defined by f (hd, µi) = hc, µi for each µ ∈ 2n . The function g : U → Ans[D, G] is the
constant function defined by g(hd, µi) = hYes, ai.
We claim that f is a refinement function witnessing d ≤ c. For every µ 6= ν, Eµ = Fµ
so (Eµ , RµD r[0, max(Eµ )]) Mathias extends (Fµ , RµD r[0, max(Fµ )]). By definition of an answer,
F1 ⊆ RνD r max(Fν )) so (Eν , RνD r [0, max(Eν )]) Mathias extends (Fν , RνD r [0, max(Fν )]).
Therefore d ≤P c. Last, prog(hc, νi) is the query
ψ(D, G) = (∃x ∈ G)[x > max(Fν )]
When considering cohesiveness, we must ensure an additional kind of progress. Indeed, we
must partition the reservoir according to (Rσ : σ ∈ 2n ) for larger and larger n. We can slightly
modify the forcing notion for COH and “hack” this kind of progress in the unbox operator by
making it return a condition whose parts are split accordingly. Since the separation of EM
from AMT entails the separation of COH from AMT, we will not go into the details for fixing
this progress issue.
4.3. Construction
We will construct an infinite sequence of trees of conditions by stages, such that each level
corresponds to one iteration. We will add progressively more and more iterations, so that the
limit tree is of infinite depth. In order to simplify the presentation of the construction, we need
to introduce some additional terminology.
Definition 4.3 (Stage tree) A stage tree is a finite tree T whose nodes are conditions and whose
edges are parts of conditions. It is defined inductively as follows: A stage tree of depth 0 is a
condition. A stage tree of depth n + 1 is a tuple hc, hi where c is a condition and h is a function
such that h(ν) is a stage tree of depth n for each ν ∈ parts(c).
We consider that the stage subtree h(ν) is linked to c by an edge labelled by ν. The root of T
is itself if T is a stage tree of depth 0. If T = hc, hi then the root of T is c. According to our
notation on trees, if T = hc, hi, we write T [ν] to denote h(ν). We also write T ↾k to denote the
restriction of T to its stage subtree of depth k. At each stage s of the construction, we will end
up with a stage tree of depth s. The initial stage tree will be T0 = init(0). There is a natural
notion of stage tree extension induced by the extension of its conditions.
Definition 4.4 (Stage tree extension) A stage tree T1 of depth n extends a stage tree T0 of
depth 0 if there is a function f such that c1 ≤f T0 where c1 is the root of T1 . We say that f
is a refinement tree of depth 0 and write T1 ≤f T0 . A stage tree T1 = hc1 , h1 i of depth n + 1
extends a stage tree T0 = hc0 , h0 i of depth m + 1 if there is a function f such that c1 ≤f c0
and a function r such that r(ν) is a refinement tree of depth m such that h1 (ν) ≤r(ν) h0 (f (ν))
for each part ν of c1 . The tuple R = hf, ri is a refinement tree of depth m + 1 and we write
T1 ≤R T0 .
Note that if T1 ≤R T0 , where T1 is a stage tree of depth n and T0 is a stage tree of depth m,
then n ≥ m. We may also write T1 ≤ T0 if there is a refinement tree R of depth m such that
T1 ≤R T0 .
At each stage, we will extend the current stage tree to a stage tree of larger depth and whose
conditions force more and more properties. The resulting sequence of stage trees T0 ≥ T1 ≥ . . .
can be seen as a 2-dimensional tree with the following axes:
− The stage axis is a temporal dimension. Let c0 ≥ c1 ≥ . . . be such that cs is the
root of Ts for each stage s. As we saw in the computable non-reducibility case, the

20

LUDOVIC PATEY

T0
f0

c0
d0,1
d0,0
f1

T1

c1

f3
f2

d1,2
d1,1

d1,0
e1,2
e1,1
e1,0

Figure 4. In this example, the refinement tree R whose nodes are {f0 , f1 , f2 , f3 }
witnesses the extension of the stage tree T0 whose nodes are {c0 , d0,0 , d0,1 } by
the stage tree T1 whose nodes are {c1 , d1,0 , d1,1 , d1,2 , e1,0 , e1,1 , e1,2 }. The condition c1 has three parts, and f0 -refines the condition c0 which has two parts. The
conditions d1,0 , d1,1 and d1,2 have only one part. The path c1 − d1,1 − e1,1 trough
the tree T1 R-refines the path c0 − d0,0 through the tree T0 .
parts of this sequence forms an infinite, finitely branching tree. Let P be any infinite
path through this tree. More formally, P is a sequence ν0 , ν1 , . . . such that νs+1 is a
part of cs+1 refining the part νs in cs for each s. Consider now the sequence of stage
[ν ]
[ν ]
trees T0 0 ≥ T1 1 ≥ . . . The sequence lives at the second iteration level, below the
path P . Its roots induce another infinite, finitely branching tree, and so on. Therefore,
at each level, we can define an infinite, finitely branching tree of parts, once we have
fixed the path P through the tree of parts at the previous level.
− The iteration axis is a spatial (or vertical) dimension corresponding to the depth. The
notion of stage tree makes explicit the finite tree obtained when fixing a stage. A path
through a stage tree corresponds to the choices made at each level, between the different
parts of a condition. We did not define the notion of acceptable part in this framework.
Therefore, the choice of the part is delegated to the module, which will have to justify
that at least one of the parts is extensible.
Definition 4.5 (Partial path) A partial path ρ through a stage tree T of depth n is defined
inductively as follows: A partial path through a stage tree T of depth 0 is a part of T . A partial
path through a stage tree T = hc, hi of depth n + 1 is either a part of c, or a sequence ν, ρ where
ν is a part of c and ρ is a partial path through h(ν). A path through T is a partial path of
length n + 1.
We denote by P (T ) and by P P (T ) the collection of paths and partial paths through T ,
respectively. Note that a partial path has length at least 1. The notion of refinement between
partial paths is defined in the natural way. We can also extend the notation T [ρ] to partial
paths ρ through T with the obvious meaning. There is also a notion of satisfaction of a stage
tree induced by the sat operator.
Definition 4.6 (Stage tree satisfaction) A set G0 satisfies a partial path ν0 through a stage tree
T of depth 0 if G0 ∈ sat(ν0 ). A tuple of sets G0 , G1 , . . . , Gk satisfies a partial path ν0 , . . . , νk
through a stage tree T = hc, hi of depth n + 1 if G0 ∈ sat(ν0 ) and k = 0, or G1 , . . . , Gk satisfies
the partial path ν1 , . . . , νk through the stage tree h(ν0 ). A tuple of sets G0 , G1 , . . . , Gk satisfies
a stage tree T of depth n if it satisfies a partial path through T .
Again, if G0 , . . . , Gk satisfies a stage tree of depth n, then k ≤ n. The notion of satisfaction
induces a forcing relation. We say that T forces some formula ϕ(D, G) below a partial path
ρ=
Lν0 , . . . , νk (written T ρ ϕ(U, G) if for every tuple of sets G0 , . . . , Gk satisfying ν0 , . . . , νk ,
ϕ( i<k Gi , Gk ) holds.

DOMINATING THE ERDŐS-MOSER THEOREM

21

We now prove a few lemmas stating that we can compose locally the abstract operators to
obtain some global behavior. The first trivial lemma shows how to increase the size of a stage
tree. This is where we use the operator init.
Lemma 4.7 (Growth lemma) For every stage tree T0 of depth n and every m, there is a stage
tree T1 of depth n + 1 such that T1 ↾n = T0 , and whose leaves are init(m). Moreover, T1 can
be computably found uniformly in T0 .
Proof. The proof is done inductively on the depth of T0 . In the base case, T0 is a stage tree of
depth 0 and is therefore a condition c0 . Let h be the function such that h(ν) = init(m) for
each ν ∈ parts(c0 ). The tuple T1 = hc0 , hi is a stage tree of depth 1 such that T1 ↾0 = c0 = T0 .
It can be computably found uniformly in T0 since init and parts are computable. Suppose now
that T0 = hc0 , h0 i is a stage tree of depth n+1. By induction hypothesis, we can define a function
h1 such that for each ν ∈ parts(c0 ), h1 (ν) is a stage tree of depth n + 1 and h1 (ν)↾n = h0 (ν).
The tuple T1 = hc0 , h1 i is a stage tree of depth n + 2 such that T1 ↾n + 1 = hc0 , h0 i = T0 .

We will always apply the growth lemma in the case m = n + 1. However, the full statement
was necessary to apply the induction hypothesis. Note that, since T1 ↾n = T0 , we have T1 ≤ T0
as witnessed by taking the refinement tree of identity functions. The next lemma states that
we can, given some stage tree T0 and some query ϕ(D, G), obtain another stage tree T1 ≤ T0 in
which we have decided ϕ(D, G) at every part of every condition in T0 . Its proof is non-trivial
since when forcing some property, we may increase the number of branches of the stage tree.
We need therefore to define some elaborate decreasing property to prove termination of the
procedure. The query lemma is assumed yet and will be proven in subsection 4.4.
Lemma 4.8 (Query lemma) Let T0 be a stage tree of depth n and q : P P (T ) → Query[D, G]
be a computable function. There is a stage tree T1 ≤ T0 of depth n such that every partial path
ξ through T1 refines a partial path ρ through T0 for which T1 ξ q(ρ) or T1 ξ ¬q(ρ), Moreover,
T1 and the function of answers a : P P (T1 ) → Ans[D, G] can be ∆02 -found uniformly from T0 .
The following domination lemma is a specialization of the query lemma by considering queries
about termination of programs.
Lemma 4.9 (Domination lemma) For every stage tree T0 of depth n, there is a stage of tree
T1 ≤ T0 of depth n and a finite set U ⊂ ω such that for every tuple G0 , . . . , Gn satisfying T1
0 ⊕···⊕Gi (x) ∈ U whenever ΦG0 ⊕···⊕Gi (x) halts. Moreover, T and U can
and every e, x, i ≤ n, ΦG
1
e
e
0
be ∆2 -found uniformly from T0 .
D⊕G (x) ↓= m for each e, x ≤
Proof. Apply successively the query lemma with q(ξ) = (∃s, m)Φe,s
n, in order to obtain the tree T1 together with an upper bound k to the answers to q(ρ).
We claim that the set U = [0, k] satisfies the desired property. Let G0 , . . . , Gn be a tuple
0 ⊕···⊕Gi (x) ↓. By definition of satisfaction,
satisfying T1 , and let e, x, i < n be such that ΦG
e
there is some partial path ρ through T1 such that G0 , . . . , Gi satisfies ρ. By the query lemma,
G0 ⊕···⊕Gi (x) ↓, the
D⊕G
T1 ρ (∃s, m)ΦD⊕G
e,s (x) ↓= m or T1 ρ ¬(∃s, m)Φe,s (x) ↓= m. Since Φe
former holds, and k is greater than the answer to the query, so is greater than m. Uniformity
is inherited from the query lemma.


We construct an infinite ∆02 sequence of finite trees of conditions T0 ≥ T1 ≥ . . . as follows:
At stage 0, we start with a stage tree T0 of depth 0 defined by init(0). At each stage s > 0,
assuming we have defined a stage tree Ts−1 of depth s − 1, act as follows:
(S1) Growth: Apply the growth lemma to obtain a stage tree Ts1 ≤ Ts−1 of depth s. Intuitively, this step adds a new iteration and therefore ensures that the construction will
have eventually infinitely many levels of iteration.
(S2) Progress: Apply to Ts1 the query lemma with q = prog to obtain a stage tree Ts2 ≤ Ts1
such that the progress function is forced at each partial path. This step ensures that for

22

LUDOVIC PATEY

every tuple G0 , G1 , . . . such that G0 , . . . , Gk satisfies each Ts , s ≥ k, the progress query
will have been decided on Gi infinitely many times.
(S3) Domination: Apply to Ts2 the domination lemma to obtain a stage tree Ts ≤ Ts2 and
a finite set U such that for every tuple G0 , . . . , Gs satisfying Ts and every e, x, i ≤ s, if
ΦeG0 ⊕···⊕Gi (x) halts, then its value will be in U . Since the whole construction is ∆02 and
we uniformly find such a set U , this step enables us to define a ∆02 function which will
dominate every function in the Turing ideal.

4.4. Queries
In this section, we develop the tools necessary to prove the query lemma (Lemma 4.8). Given
some stage tree T0 and some query function q : P P (T ) → Query[D, G], the query lemma states
that we can find a stage tree T1 extending T0 and which forces either q(ρ) or its negation on each
partial path through T1 refining the partial ρ through T0 . The stage tree T0 is finite and has
therefore finitely many partial paths. The naive algorithm would consist of taking an arbitrary
partial path ρ through T0 , then decide q(ρ) thanks to the process illustrated in Figure 3 and
extend T0 into a stage tree T1 which forces q(ρ) or its negation on every path refining ρ. One
may expect to obtain the query lemma by iterating this process finitely many times.
The termination of the algorithm depends on the shape of the extension T1 obtained after
deciding q(ρ). We need to ensure that we made some progress so that we will have covered all
paths at some point. Let us look more closely at the construction of the extension T1 . Given
some query ϕ(D, G) and some part ν, we call the unbox(ν, ϕ) operator to obtain another query
ψ(D) getting rid of the forcing variable G. Using ∅′ , we obtain an answer a to the formula ϕ(∅)
and then call unbox(ν, a) to obtain some extension forking only ν, and forcing either ϕ(D, G)
or its negation on every part refining ν. This extension may therefore increase the number of
parts, but ensures some progress on each of the forked parts.
If T0 is a stage tree of depth 0, the termination of the process is clear. Indeed, T0 is a
condition c0 and the partial paths through T0 are simply the parts of c0 . We end up with a
stage tree T1 of depth 0 corresponding to some condition c1 , on which we have decided ϕ(D, G)
for every part of c1 refining some part ν of c0 . Since we have not forked any other part than ν,
the number of undecided parts strictly decreases. A condition has finitely many parts, so the
process terminates after at most |parts(c0 )| steps.
The progress becomes much less clear if T0 is a stage tree of depth 1. When trying to
decide some query on some path ν0 , ν1 through T0 , we need to extend both the root, and the
conditions below each part µ refining ν0 . The overall number of undecided paths may increase,
and therefore a simple cardinality argument is not enough to deduce termination. Note that
this algorithm has some common flavor with the hydra game introduced by Kirby and Paris [17]
and whose termination is not provable in Peano arithmetic. Thankfully, our problem is much
simpler and its termination can be proven by elementary means.
In Figure 5, we give an example of one step in the decision process, starting with a stage
tree T0 of depth 1 with three undecided paths, and ending up with some stage tree T1 having
four undecided paths (c1 − d1,0 − µ1,1 , c1 − d1,0 − µ1,2 , c1 − d1,0 − µ1,1 and c1 − d1,0 − µ1,2 ).
Thankfully, the unbox operator forks only the part on which it answers the query. Therefore,
at the next step, we will be able to consider only one of the parts of c1 at a time. The induced
subtree has two undecided paths, so there is also some progress.
We now define some relation ⊏ between two stage trees T0 and T1 of depth n. It describes
the relation between the stage tree T0 and the extension T1 obtained after applying one step
of the query algorithm. More precisely, T2 ⊏ T0 if T2 is the subtree of T1 on which we have
removed every decided paths.
Definition 4.10 Given two stages trees T1 ≤ T0 of depth n, we define the relations T1 ⊑ T0 and
T1 ⊏ T0 by mutual induction as follows. If T0 and T1 are conditions and T1 ≤f T0 , then T1 ⊑ T0
if f does not fork any part of T0 . If moreover f is not surjective, then T1 ⊏ T0 . If T1 = hc1 , h1 i,
T0 = hc0 , h0 i and c1 ≤f c0 , then T1 ⊑ T0 if for every part ν of c1 , if f forks part f (ν) of c0 then

DOMINATING THE ERDŐS-MOSER THEOREM

23

T0
T1

f0

c0

c1
f2

d0
ν0,2

f1

ν0,1

d1,1
µ1,5

d1,0

ν0,0

µ1,4
µ1,2

µ1,3

µ1,1
µ1,0

Figure 5. In this example, we start with a stage tree T0 of depth 1 and want
to decide some query ϕ(D, U ) for each of its three paths. We choose one path
ρ = c0 − d0 − ν0,0 , call box(ν0,0 , ϕ) to obtain a query ψ(D), then call box(λ, ψ),
where λ is the unique part of c0 . We obtain a query φ(D), ∅′ -compute some
answer a to φ(∅) and call unbox(λ, a) to obtain some extension c1 of c0 and some
answering function b : parts(c1 ) → Ans[D, G]. This extension forks the part λ
into two parts. Below each part λi in c1 , we call unbox(λi , b(λi )) to obtain an
extension of d1,i forcing ϕ(D, G) below the parts refining ν0,0 .
h1 (ν) ⊏ h0 (f (ν)), otherwise h1 (ν) ⊑ h0 (f (ν)). If moreover there is some part µ of c0 such that
h1 (ν) ⊏ h0 (µ) for every part ν of c1 refining µ, then T1 ⊏ T0 .
One easily proves by mutual induction over the depth of the trees the following facts:
(i) Both ⊏ and ⊑ are transitive
(ii) If T1 ⊏ T0 then T1 ⊑ T0
(iii) If T2 ⊑ T1 and T1 ⊏ T0 then T2 ⊏ T0
(iv) If T2 ⊏ T1 and T1 ⊑ T0 then T2 ⊏ T0
Assuming that ⊏ truly represents the relation between a stage tree and its extension after one
step of query, the following lemma can be understood as stating that the naive algorithm used
in the proof of the query lemma terminates.
Lemma 4.11 The relation T1 ⊏ T0 is well-founded.
Proof. By induction over the depth of the stage trees. Suppose that T0 ⊐ T1 ⊐ . . . is an
infinite decreasing sequence of stage trees of depth 0. In particular, the T ’s are conditions and
T0 ≥f0 T1 ≥f1 . . . for some functions fi which are injective, but not surjective. Therefore the
number of parts strictly decreases in ω, contradiction.
Suppose now that T0 ⊐ T1 ⊐ . . . is an infinite decreasing sequence of stage trees of depth
n + 1, where Ti = hci , hi i and ci ≥fi ci+1 . Let S be the set of parts ν in some ci which will fork
at a later cj . This S induces a finitely branching tree. If S is finite, then there is some j such
that no part of ck will ever fork for every k ≥ j. By the infinite pigeonhole principle, there we
can construct an infinite, decreasing sequence of trees of depth n, contradicting our induction
hypothesis. So suppose that S is infinite. By König’s lemma, there is an infinite sequence of
parts, the later refining the former, such that they fork. Each time a conditions fork, the subtree
is strictly decreasing, so we can define an infinite decreasing sequence of stage trees of depth n,
again contradicting our induction hypothesis.

Given some stage tree T1 of depth i < n, a completion of T1 to n is a stage tree T2 of depth
n such that T1 ↾i = T0 . If T1 ≤ T0 ↾i for some stage tree T0 of depth n, T0 induces a completion
[ξ]
[ρ]
T2 of T1 to n by setting T2 = T0 for every path ξ through T1 refining some path ρ through
T0 ↾i. One easily checks that T2 ≤ T0 . Such a stage tree is called the trivial completion of T1

24

LUDOVIC PATEY

by T0 . The following technical lemma will be useful for applying the induction hypothesis in
Lemma 4.14.
Lemma 4.12 Let T0 , T1 be two stage trees of depth n + 1 and T2 be a stage tree of depth n
and S0 be a set of paths through T0 ↾n such that
(i)
(ii)
(iii)
(iv)

T2 ⊑ T0 ↾n, P (T2 ) ⊆ P (T1 ↾n) and T1 ≤ T0
S0 is the set of paths through T0 ↾n refined by some path through T2 .
[ξ]
[ρ]
For every path ξ ∈ P (T2 ), T1 ⊑ T0 where ξ refines the path ρ ∈ S0
[ρ]
[ξ]
For every path ξ ∈ P (T1 ↾n)rP (T2 ), ξ refines some path ρ ∈ P (T0 ↾n)rS0 and T1 ⊏ T0

Then T1 ⊑ T0 . Moreover, if T2 ⊏ T0 ↾n then T1 ⊏ T0 .
Proof. By induction over n. In the base case, T0 ↾n, T1 ↾n and T2 are conditions c0 , c1 and c2
such that c2 ≤f c0 and c1 ≤g c0 for some refinement functions f and g. We easily have T1 ⊑ T0
[µ]
[g(ν)]
[µ]
[g(ν)]
whenever
since T1 ⊑ T0
for every part µ of c2 (and therefore of c1 ), and since T1 ⊏ T0
µ is a part of c1 which is not a part of c2 . By c2 ⊑ c0 , the only places where a fork can happen
is when µ is not in c2 .
We now want to prove that T1 ⊏ T0 whenever c2 ⊏ c0 . Since c2 ⊏ c0 , f is injective, but not
[ν]
[g(ν)]
surjective. We need to prove that there is some part ν of T1 such that T1 ⊏ T0
. We have
two cases. In the first case, f and g have the same domain. In this case f = g and since f is
not surjective, there is some part of c0 witnessing the strictness of T1 ⊏ T0 . In the second case,
there is some part ν in c1 but not c2 . By (iv), g(ν) 6∈ S1 . The part g(ν) of c0 witnesses the
stricteness of T1 ⊏ T0 .
In the induction case, T0 ↾n = hc0 , h0 i, T1 ↾n = hc1 , h1 i and T2 = hc2 , h2 i such that c2 ≤f c0
and c1 ≤g c0 for some refinement functions f and g. For every part ν in c1 , we have two cases:
In the first case, ν is not in c2 . By (iv), any path ξ through h1 (ν) refines some path ρ in
h0 (g(ν)) such that h1 (ν)[ξ] ⊏ h0 (g(ν))[ρ] . By the induction hypothesis applied to h0 (ν), h1 (ν)
and the empty tree, h1 (ν) ⊏ h0 (g(ν)). In the second case, ν is also in c2 . By the induction
hypothesis applied to h0 (ν), h1 (ν) and h2 (ν), h1 (ν) ⊑ h0 (g(ν)). We again easily have T1 ⊑ T0
since h1 (ν) ⊑ h0 (g(ν)) for every part ν in c1 and since whenever g forks some part µ of c0 ,
either the parts ν of c1 refining µ are all in c2 in which case h2 (ν) ⊏ h0 (µ)↾n by the definition
of the partial order and then we have h1 (ν) ⊏ h0 (µ), or none of the parts ν of c1 refining µ are
in c2 , in which case we have h1 (ν) ⊏ h0 (µ). By the same case analysis as in the base case, we
deduce that T1 ⊏ T0 if moreover T2 ⊏ T0 ↾n.

Definition 4.13 (Stage tree substration) Given a stage tree T of depth n and a set S of paths
through T , we define T − S inductively as follows: If T is a stage tree of depth 0, then S is a
set of parts of T and T − S is the condition whose parts are parts(T ) r S. If T = hc, hi is a
stage tree of depth n + 1, then S is a set of paths of the form νρ where ν is a part of c and ρ is
a path through h(ν). For each part ν, let Sν = {ρ : νρ ∈ S}. The stage tree T − S is defined
by hc, h1 i where h1 (ν) = h(ν) − Sν for each part ν of c.
Intuitively, T − S is the maximal subtree of T such that P (T − S) = P (T ) r S. Beware,
even if we may remove every part of a condition, we do not remove the condition from the tree.
The following lemma uses the well-founded partial order defined previously to show that we
can make some progress in deciding the queries. In what follows, the set T0 can be thought of
as the stage tree we obtain after having applied finitely many steps of query and S0 are the
paths through the tree T0 for which we have already decided the query ϕ(D, G). The lemma
describes the relation between the state (T1 , S1 ) obtained from (T0 , S0 ) after having applied one
more step.
Lemma 4.14 Let T0 be a stage tree of depth n, S0 be a set of paths through T0 and let ϕ(D, G)
be a query. For every path ρ 6∈ S0 through T0 , there exists a stage tree T1 ≤ T0 of depth n and
a set S1 of paths through T1 such that

DOMINATING THE ERDŐS-MOSER THEOREM

25

(i) T1 ξ ϕ(D, G) or T1 ξ ¬ϕ(D, G) for every path ξ through T1 refining ρ.
(ii) T1 − S1 ⊏ T0 − S0
(iii) Every path in S1 refines either a path in S0 or ρ.
Moreover, T1 and the function of answers a : P (T1 ) → Ans[D, G] can be ∅′ -effectively computed
uniformly in T1 and ϕ(D, G).
Proof. By induction over n. If T0 is a stage tree of depth 0, then it is a condition c0 and the
paths through T0 are the parts of c0 . Let ν be such a part. Let ψ(D) be the query box(ν, ϕ).
We can ∅′ -compute an answer a0 to ψ(∅). Let hc1 , f, ai = unbox(ν, a0 ) be such that c1 ≤f c0 ,
f forks only part ν of c0 and for every part µ of c1 such that f (µ) = ν, c1 µ ϕ(D, G) or
c1 µ ¬ϕ(D, G) and a(µ) answers ϕ(D, G) accordingly. Take S1 = {µ : f (µ) = ν ∨ f (µ) ∈ S0 }.
The property (i) holds by definition of c1 and (iii) holds by definition of S1 . Since the only
forked part is ν and no part of c1 − S1 refines ν, c1 − S1 ⊏ c0 − S0 , so the property (ii) also
holds. This completes the base case.
Suppose now that T0 is a stage tree of depth n + 1. The paths through T0 are of the form ρν
[ρ]
where ρ is a path through T0 ↾n and ν is a part of the root of T0 . Fix any such path. Let ψ(D)
be the query box(ν, ϕ) and let φ(D, G) be the formula ψ(D ⊕ G). By induction hypothesis on
T0 ↾n, there is a stage tree T2 ≤ T0 ↾n and a set S2 such that
(i) T2 ξ φ or T2 ξ ¬φ for every path ξ through T2 refining ρ
(ii) T2 − S2 ⊏ T0 ↾n − S0 ↾n
(iii) Every path in S2 refines either a path in S0 ↾n or ρ.
Moreover, still by induction hypothesis, we have a function a : P (T2 ) → Ans[D, G] answering
the queries. We define a completion of T2 into a stage tree T1 of depth n + 1 as follows: For each
[ξ]
path ξ through T2 refining ρ, let T1 be the condition cξ such that hcξ , fξ , aξ i = unbox(ν, a(ξ)).
[ξ]
[τ ]
For each path ξ through T2 which refines some path τ through T0 different from ρ, let T1 = T0 .
[ρ]
By construction, T1 ≤ T0 since cξ fξ -refines T0 whenever ξ refines ρ and since any condition
refines itself. Let S1 be the collection of paths ξµ through T1 such that ξ ∈ S2 and either ξ
refines ρ and fξ (µ) = ν, or ξµ refines a path in S0 . Since (T0 ↾n − S0 ↾n) ⊑ (T0 − S0 )↾n, we have
T2 − S2 ⊏ (T0 − S0 )↾n. We can therefore apply Lemma 4.12 to T0 − S0 , T1 − S1 , and T2 − S2 , to
obtain T1 − S1 ⊏ T0 − S0 . Define the answer function b : P (T1 ) → Ans[D, G] by b(ξµ) = aξ (µ)
for each path ξ through T2 refining ρ. This function b is found ∅′ -effectively since the unbox
operator is computable.

The following lemma simply iterates Lemma 4.14 and uses the well-foundedness of the relation
⊏ to deduce that we can find some extension on which the queries are decided for every path.
Lemma 4.15 Let T0 be a stage tree of depth n and let q : P (T0 ) → Query[D, G] be a function.
There is a stage tree T1 ≤ T0 of depth n such that T1 ξ q(ρ) or T1 ξ ¬q(ρ) for every path
ξ through T1 refining some path ρ through T0 . Moreover, T1 and the function of answers
a : P (T1 ) → Ans[D, G] can be ∅′ -effectively computed uniformly in T1 and q.
Proof. Using Lemma 4.14, define a sequence of tuples hT0 , S0 , ρ0 , τ0 i , hT1 , S1 , ρ1 , τ1 i , . . . starting
with T0 , S0 = ∅, ρ0 = τ0 ∈ P (T0 ) and such that for each i
(i)
(ii)
(iii)
(iv)
(v)

Ti+1 ≤ Ti is a stage tree of depth n, Si is a set of paths through Ti
ρi is a path through Ti − Si refining the path τi through T0 .
Ti+1 ξ q(τi ) or Ti+1 ξ ¬q(τi ) for every path ξ through Ti+1 refining ρi
Ti+1 − Si+1 ⊏ Ti − Si
Every path in Si+1 refines either a path in Si or ρi .

By Lemma 4.11, the relation ⊏ is well-founded, so the sequence has to be finite by (iv). Let k
be the maximal index of the sequence. By maximality of k and by Lemma 4.14, P (Tk ) − Sk = ∅.
Therefore, P (Tk ) = Sk . Since S0 = ∅ and by (v), we can prove by induction over k that for
every path ξ through Tk , there is some stage i < k such that ξ refines ρi . Thus, by (iii) and
by stability of the forcing relation under refinement, Tk ξ q(τi ) or Tk ξ ¬q(τi ). Therefore

26

LUDOVIC PATEY

Tk satisfies the statement of the lemma. The uniformity is inherited from the uniformity of
Lemma 4.14.

Last, we prove the query lemma by iterating the previous lemma at every depth of the stage
tree, to decide the queries on the partial paths.
Proof of the query lemma. Let T0 be a stage tree of depth n and q : P P (T0 ) → Query[U, G] be
a function. Using Lemma 4.15, define a decreasing sequence of stage trees T0 ≥ · · · ≥ Tn of
depth n such that for each i < n,
(i) Ti+1 is the trivial completion of Ti+1 ↾i + 1 by Ti .
(ii) Ti+1 ξ q(τ ) or Ti+1 ξ ¬q(τ ) for every path ξ through Ti+1 ↾i + 1 refining some path τ
through T0 ↾i + 1.
To do this, at stage i < n, apply Lemma 4.15 to Ti with the query function r : P P (Ti ) →
Query[U, G] defined by r(ρ) = q(τ ) for each path ρ through Ti ↾i + 1 refining some path τ
through T0 ↾i + 1. Since the forcing relation is stable by refinement, the stage tree Tn satisfies
the statement of the query lemma. The uniformity is again inherited from the uniformity of
Lemma 4.15.

This completes the presentation of the framework. We will now define a module for the
Erdős-Moser theorem. In section 6, we will see how to compose modules to obtain stronger
separations.
5. The weakness of EM over ω-models
Now we have settled the domination framework, it suffices to implement the abstract module
to obtain ω-structures which do not satisfy AMT. We have illustrated the notion of module
by implementing one for COH. An immediate consequence is the existence of an ω-model of
COH which is not a model of AMT. In this section, we shall extend this separation to the
Erdős-Moser theorem. As noted before, every ω-model of EM which is not a model of AMT is
also a model of COH. This section is devoted to the proof of the following theorem.
Theorem 5.1 There exists an ω-model of EM which is not a model of AMT.
At first sight, the forcing notion introduced in section 3 seems to have a direct mapping to
the abstract notion of forcing defined in the domination framework. However, unlike cohesiveness where the module implementation was immediate, the Erdős-Moser theorem raises new
difficulties:
− The Erdős-Moser theorem is not known to admit a universal instance. We will therefore need to integrate the information about the instance in the notion of condition.
Moreover, the init operator will have to choose accordingly some new instance of EM
at every iteration level. We need to make init computable, but the collection of every
infinite computable tournament functionals is not even computably enumerable.
− The notion of EM condition introduced in section 3 contains a Π0,R
property ensuring
1
extensibility. Since the tournament R depends on the previous iteration which is being
constructed, we have only access to a finite part of R. We need therefore to ensure that
whatever the extension of the finite tournament is, the condition will be extendible.
We shall address the above-mentioned problems one at a time in subsections 5.1 and 5.2.
5.1. Enumerating the infinite tournaments
In section 3, we were also confronted to the problem of enumerating all infinite tournaments
and solved it by relativizing the construction to a low subuniform degree in order to obtain a
low sequence of infinite tournaments containing at least every infinite computable tournament.
We cannot apply the same trick to handle the construction of an ω-model of EM as solutions to
some computable tournaments may bound new tournaments and so on. However, as we shall
see, we can restrict ourselves to primitive recursive tournaments to generate an ω-model of EM.

DOMINATING THE ERDŐS-MOSER THEOREM

27

Given a sequence of sets X0 , X1 , . . . , define MX~ to be the ω-structure whose second-order
~ that is,
part is the Turing ideal generated by X,
{Y ∈ 2ω : (∃i)[Y ≤T X0 ⊕ · · · ⊕ Xi ]}
Lemma 5.2 There exists a uniformly computable sequence of infinite, primitive recursive tournament functionals T0 , T1 , . . . such that for every sequence of sets X0 , X1 , . . . such that Xi is
X ⊕···⊕Xi−1
for each i ∈ ω,
an infinite transitive subtournament of Ti 0
MX~ 6|= AMT → MX~ |= EM ∧ COH
Proof. As RCA0 ⊢ SEM ∧ COH → EM, it suffices to prove that for every set X,
(i) for every stable, infinite, X-computable tournament R, there exists an infinite X-p.r.
tournament T such that every infinite T -transitive subtournament X-computes an infinite R-transitive subtournament.
(ii) for every X-computable complete atomic theory T and every uniformly X-computable
~ there exists an infinite X-p.r. tournament such that every infinite
sequence of sets R,
~
transitive subtournament X-computes either an R-cohesive
set or an atomic model of T .
(i) Fix a set X and a stable, infinite, X-computable tournament R. Let f˜ : ω → 2 be the
′
X -computable function defined by f˜(x) = 0 if (∀∞ s)R(s, x) and f˜(x) = 1 if (∀∞ s)R(x, s). By
Schoenfield’s limit lemma [28], there exists an X-p.r. function g : ω 2 → 2 such that lims g(x, s) =
f˜(x) for every x ∈ ω. Considering the X-p.r. tournament T such that T (x, y) holds iff x < y
and g(x, y) = 1 or x > y and g(x, y) = 0, every infinite T -transitive subtournament X-computes
an infinite R-transitive subtournament.
(ii) Jockusch and Stephan proved in [16] that for every set X, and every uniformly X~ every p-cohesive set relative to X computes an R-cohesive
~
computable sequence of sets R,
set. The author proved in [25] that for every X-computable complete atomic theory T , there
exists an X ′ -computable coloring f : ω → ω such that every infinite set Y thin for f (i.e.
such that f (Y ) 6= ω) X-computes an atomic model of T . He also proved that for every such
X ′ -computable coloring f : ω → ω, there exists an infinite, X-p.r. tournament R such that
every infinite transitive subtournament is either p-cohesive, or X-computes an infinite set thin
for f .

We can therefore fix this computable enumeration T0 , T1 , . . . of tournament functionals, and
make init(n) return an empty condition paired with Tn . Thus, taking at each iteration an
infinite set satisfying one of the parts, we obtain an ω-model of EM.
5.2. The new Erdős-Moser conditions
Fix some primitive recursive tournament functional R. According to the analysis of the ErdősMoser presented in section 3, we would like to define the forcing conditions to be tuples (F~ , C)
where
(a) C is a non-empty Π0,D
k-cover class of [t, +∞) for some k, t ∈ ω
1
(b) Fν ∪ {x} is RD -transitive for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C, every x ∈ Zν and each ν < k
(c) Zν is included in a minimal RD -interval of Fν for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C and
each ν < k.
However, at a finite stage, we have only access to a finite part of D, and therefore we cannot
express the properties (a-c). Indeed, we may have made some choices about the F ’s such that
Fν ∪ {x} is not RD -transitive for every part ν, every D satisfying the previous iterations and
cofinitely many x ∈ ω. We need therefore to choose the F ’s carefully enough so that whatever
the extension of the finite tournament to which we have access, we will be able to extend at
least one of the F ’s.
The initial condition ({∅}, {ω}) satisfies the properties (a-c) no matter what D is, since {ω}
does not depend on D. Let us have a closer look at the question Q2 asked in section 3. For the
sake of simplification, we will consider that the question is asked below the unique part of the
initial condition. It therefore becomes:

28

LUDOVIC PATEY

Q3: Is there a finite set E ⊆ ω such that for every 2-partition hE0 , E1 i of E, there exists an
RD -transitive subset F1 ⊆ Ei for some i < 2 such that ϕ(D, F1 ) holds?
Notice that this is a syntactic question since it depends on the purely formal variable D
representing the effective join of the sets constructed in the previous iterations. Thanks to the
usual query process, we are able to transform it into a concrete Σ01 formula getting rid of the
formal parameter D, and obtain some answer that the previous layers guarantee to hold for
every set D satisfying the previous iterations.
If the answer is negative, then by compactness, for every set D satisfying the previous iterations, there is a 2-partition Z0 ∪ Z1 = ω such that for every i < 2 and every RD -transitive
subset G ⊆ Zi , ϕ(D, G) does not hold. For every set D, the Π0,D
class C of such 2-partitions
1
Z0 ⊕ Z1 is therefore guaranted to be non-empty. Note again that since D is a syntactic variable,
the class C is also syntactic, and purely described by finite means.
If the answer is positive, then we are given some finite set E ⊆ ω witnessing it. Moreover,
we are guaranted that for every set D satisfying the previous iterations, for every 2-partition
hE0 , E1 i of E, there exists an RD -transitive subset F1 ⊆ Ei for some i < 2 such that ϕ(D, F1 )
holds. In we knew the set D, we would choose one “good” 2-partition hE0 , E1 i as we do in
section 3. However, this choice depends on infinitely many bits of information of D. We will
need therefore to try every 2-partition in parallel.
There is one more difficulty. With this formulation, we are not able to find the desired
extension, since D is syntactic, and therefore we do not know how to identify the color i and
the actual set F1 given some 2-partition hE0 , E1 i. Thankfully, we can slightly modify the
question to ask to provide the witness F1 for each such a partition in the answer.
Q4: Is there a finite set E ⊆ ω and a finite function g such that for every 2-partition hE0 , E1 i
of E, g(hE0 , E1 i) = F1 for some i < 2 and some RD -transitive subset F1 ⊆ Ei such that ϕ(D, F1 )
holds?
The question Q4 is equivalent to the question Q3, but provides a constructive witness g in
the case of a positive answer as well. We can even formulate the question so that we know the
relation RD over the set F1 . Thus we are able to talk about minimal RD -intervals of F1 .
Now, we can extend the initial condition ({∅}, {ω}) into some condition (F~ , C) as follows: For
each 2-partition hE0 , E1 i of E, letting F1 = g(hE0 , E1 i), for every minimal RD -interval I, we
create a part νL
= hE0 , E1 , Ii and set Fν = F1 . Take some t′ > max(F~ ) and let C be the Π0,D
1
class of covers ν Zν of [t′ , +∞) such that for every part ν = hE0 , E1 , Ii

(b’) Fν ∪ {x} is RD -transitive for every x ∈ Zν
(c’) Zν is included in the minimal RD -interval I
Fix some set D satisfying the previous iterations. We claim that C is non-empty. Any element
x ∈ [t′ , +∞) induces a 2-partition g(x) = hE0 , E1 i of E by setting E0 = {y ∈ E : RD (y, x)} and
E1 = {y ∈ E : RD (x, y)}. On the other hand, for every 2-partition hE0 , E1 i of E, we can define
a partition of [t′ , +∞) by setting ZhE0 ,E1 i = {x L
∈ [t′ , +∞) : g(x) = hE0 , E1 i}. By definition,
E0 →RD ZhE0 ,E1 i →RD E1 . Therefore, the cover ν Zν of [t′ , +∞) defined by

 ZhE0 ,E1 i if ν = hE0 , E1 , Ii , I = (max(Fν ), +∞) and Fν ⊆ E0
Z
if ν = hE0 , E1 , Ii , I = (−∞, min(Fν )) and Fν ⊆ E1
Zν =
 hE0 ,E1 i
∅
otherwise

is in C and witnesses the non-emptiness of C.
The problem of having access to only a finite part of the class C appears more critically when
considering the question below some part ν of an arbitrary condition c = (F~ , C). The immediate
generalization of the question Q4 is the following.
Q5: For every cover X0 ⊕ · · · ⊕ Xk−1 ∈ C, is there a finite set E ⊆ Xν and a finite function g
such that for every 2-partition hE0 , E1 i of E, g(hE0 , E1 i) is a finite RD -transitive subset of some
Ej such that ϕ(D, Fν ∪ g(hE0 , E1 i)) holds?
As usual, although this question is formulated in a Π02 manner, it can be turned into a Σ0,D
1
query using a compactness argument.

DOMINATING THE ERDŐS-MOSER THEOREM

29

Q5’: Is there some r ∈ ω, a finite sequence of finite sets E 0 , . . . , E r−1 and a finite sequence
of functions g 0 , . . . , gr−1 such that
(1) for every X0 ⊕ · · · ⊕ Xk−1 ∈ C, there is some i < r such that E i ⊆ Xν
(2) for every i < r and every 2-partition hE0 , E1 i of E i , gi (hE0 , E1 i) is a finite RD -transitive
subset of some Ej such that ϕ(D, Fν ∪ gi (hE0 , E1 i)) holds?
In the case of a negative answer, we can apply the standard procedure consisting in refining
the Π0,D
class C into some Π0,D
class D forcing ϕ(D, G) not to hold on every part refining the
1
1
part ν in c. The class D is non-empty since we can construct a member of it from a witness
of failure of Q5. The problem appears when the answer is positive. We are given some finite
sequence E 0 , . . . , E r−1 and a finite sequence of functions g0 , . . . , gr−1 satisfying (i) and (ii). For
every D, there is some X0 ⊕ · · · ⊕ Xk−1 ∈ C and some i < r such that E i ⊆ Xν , but this i may
depend on D. We cannot choose some E i as we used to do in section 3.
Following our moto, if we are not able to make a choice, we will try every possible case in
~ D) and a refinement function f forking the
parallel. The idea is to define a condition d = (E,
part ν into various parts, each one representing a possible scenario. For every part µ of c which
is different from ν, create a part µ in d and set Eµ = Fµ . For every i < r and every 2-partition
hE0 , E1 i of E i , create a part µ = hi, E0 , E1 i in d refining ν and set Eµ = Fν ∪ gi (hE0 , E1 i).
L
Accordingly, let D be the Π10,D class of covers µ Yµ of [t, +∞) such that there is some i < r
and some cover X0 ⊕ · · · ⊕ Xk−1 ∈ C satisfying first E i ⊆ Xν , second Yµ ⊆ Xf (µ) for each part µ
of d and third Yµ = ∅ if µ = hj, E0 , E1 i for some j 6= i.
i
The class D f -refines C, but does not f -refine C [ν,E ] for some fixed i < r. Because of this,
the condition d does not extends the condition c in the sense of section 3. We shall therefore
generalize the operator · 7→ C [ν,·] to define it over tuples of sets.
Restriction of a cover class. Given some cover class (k, Y, C), some part ν of C and some
~
r-tuple E 0 , . . . , E r−1 of finite sets, we denote by C [ν,E] the cover class (k + r − 1, Y, D) such that
D is the collection of
X0 ⊕ · · · ⊕ Xν−1 ⊕ Z0 ⊕ · · · ⊕ Zr−1 ⊕ Xν+1 ⊕ · · · ⊕ Xk−1
such that X0 ⊕ · · · ⊕ Xk−1 ∈ D and there is some i < r such that E i ⊆ Xν , Zi = Xν and Zj = ∅
~
for every j 6= i. In particular, C [ν,E] refines C with some refinement function f which forks the
part ν into r different parts. Such a function f is called the refinement function witnessing the
restriction.
We need to define the notion of extension between conditions accordingly. A condition
~ D) extends a condition c = (F~ , C) (written d ≤ c) if there is a function f : parts(D) →
d = (E,
parts(C) such that the following holds:
(i) (Eν , dom(D))
Mathias extends (Ff (ν)
L
L, dom(C)) for each ν ∈ parts(D)
(ii) Every
µ Yµ ∈ D f -refines some
ν Xν ∈ C such that for each part µ of d, either
Eµ r Hf (µ) ⊆ Xf (µ) , or Yµ = ∅.
Note that this notion of extension is coarser than the one defined in section 3. Unlike with
the previous notion of extension, there may be from now on some part µL
of d refining the part ν
of c, such that (Eµ , Yµ ) does not Mathias extend (Fν , Xν ) for some
µ Yµ ∈ D and every
L
X
∈
C,
but
in
this
case,
we
make
(E
,
Y
)
non-extendible
by
ensuring
that Yµ = ∅.
µ µ
ν ν
5.3. Implementing the Erdős-Moser module

We are now ready to provide a concrete implementation of a module support and a module
for EM. Define the tuple SEM = hP, U, parts, init, sati as follows: P is the collection of all
conditions (F~ , C, R) where R is a primitive recursive tournament functional and
(a) C is a non-empty Π0,D
k-cover class of [t, +∞) for some k, t ∈ ω
1
(b) Fν ∪ {x} is RD -transitive for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C, every x ∈ Zν and each ν < k
(c) Zν is included in a minimal RD -interval of Fν for every Z0 ⊕ · · · ⊕ Zk−1 ∈ C and
each ν < k.

30

LUDOVIC PATEY

Once again, C is actually a Π0,D
formula denoting a non-empty Π0,D
class. A condition d =
1
1
~
~
(E, D, T ) extends c = (F , C, R) (written d ≤ c) if R = T and there exists a function f :
parts(D) → parts(C) such that the properties (i) and (ii) mentioned above hold.
~ , C, R), parts(c) = {hc, νi : ν ∈ parts(C)}. Define U as
Given some condition c = (F
S
~
c∈P parts(c), that is, the set of all pairs h(F , C, R), νi where ν ∈ parts(C). The operator
init(n) returns the condition ({∅}, {ω}, Rn ) where Rn is the nth primitive recursive tournament functional. Last, define sat(hc, νi) to be the collection of all RD -transitiveL
subtournaments
satisfying the Mathias precondition (Fν , Xν ) where Xν is non-empty for some ν Xν ∈ C. The
additional non-emptiness requirement of Xν in the definition of the sat operator enables us to
“disable” some part by setting Xν = ∅. Without this requirement, the property (i) of a module
support would not be satisfied. Moreover, since every cover class has an acceptable part, there
is always one part ν in C such that sat(hc, νi) 6= ∅.
Lemma 5.3 The tuple SEM is a module support.
Proof. We must check that if d ≤P c for some c, d ∈ P, then there is a function g : parts(d) →
~ D, R) and c =
parts(c) such that sat(ν) ⊆ sat(g(ν)) for each ν ∈ parts(d). Let d = (E,
(F~ , C, R) be such that d ≤P c. By definition, there is a function f : parts(D) → parts(C)
satisfying the properties (i-ii). Let g : parts(d) → parts(c) be defined by g(hd, νi) = hc, f (ν)i.
We claim that g is a refinement function witnessing d ≤P c. Let G be any set in sat(hd, νi). We
will prove that G ∈ sat(hc, f (ν)i). The set G is an L
RD -transitive subtournament satisfying the
Mathias condition
L (Eν , Xν ) where Xν 6= ∅ for some ν Xν ∈ D. By (ii), since Xν is non-empty,
there is some
µ Yµ ∈ C such that Eν r Ff (ν) ⊆ Yf (ν) and Xν ⊆ Yf (ν) . It suffices to show
that (Fν , Xν ) Mathias extends (Ff (ν) , Yf (ν) ) to deduce that G satisfies the Mathias condition
(Ff (ν) , Yf (ν) ) and finish the proof. By (i), Ff (ν) ⊆ Eν . Since Eν r Ff (ν) ⊆ Yf (ν) and Xν ⊆ Yf (ν) ,
we are done.

We next define an implementation of the module MEM = hSEM , box, unbox, progi as follows. Given some condition c = (F~ , C, R), some ν ∈ parts(C) and some Σ01 formula ϕ(D, G),
unbox(hc, νi , ϕ) returns the Σ01 formula ψ(D) which holds if there is a finite sequence of finite
sets E 0 , . . . , E r−1 and a finite sequence of functions g 0 , . . . , g r−1 such that
(1) for every X0 ⊕ · · · ⊕ Xk−1 ∈ C, there is some i < r such that E i ⊆ Xν
(2) for every i < r and every 2-partition hE0 , E1 i of E i , gi (hE0 , E1 i) is a finite RD -transitive
subset of some Ej such that ϕ(D, Fν ∪ gi (hE0 , E1 i)) holds.
If the answer to ψ(D) is hNoi, unbox(hc, νi , hNoi) returns the tuple hd, f, bi where d =
~
(E, D, R) is a condition such that d ≤f c and defined as follows. For every part µ 6= ν of
c, create a part µ in d and set Eµ = Fµ . Furthermore, fork the part ν into two parts ν0 and
L
ν1 in d and set Eνi = Fν for each i < 2. Define D to be the Π0,D
class of all covers
1
µ Yµ
L
D
f -refining some cover ν Xν ∈ C and such that for every i < 2 and every finite R -transitive
set E ⊆ Yνi , ϕ(D, Fν ∪ E) does not hold. Moreover, b : parts(c) → Ans[D, G] is the constant
function hNoi.



Suppose now that the answer to ψ(D) is a = Yes, r, E 0 , . . . , E r−1 , f 0 , . . . , f r−1 , a′ where a′
is a function which on every i < r and every 2-partition hE0 , E1 i = i, returns an answer to
ϕ(D, Fν ∪g i (hE0 , E1 i)). The function unbox(hc, νi , a) returns the tuple hd, f, bi where d is a condition such that d ≤f c and whose definition has been described in subsection 5.2. The function
b : parts(d) → Ans[D, G] returns on every part µ = hi, E0 , E1 i the tuple hYes, a′ (i, E0 , E1 )i.
~ , C, R) and some ν ∈ parts(C), prog(hc, νi) is the query
Last, given some condition c = (F
ϕ(D, G) = (∃n)[n ∈ G∧n > max(Fν )]. Note that we cannot force ¬ϕ(D, G) on every part hc, νi,
since every cover class has an acceptable part. Applying the query lemma infinitely many times
on the progress operator ensures that if we take any path through the infinite tree of the
acceptable parts, the resulting RD -transitive subtournament will be infinite.
Lemma 5.4 The tuple MEM is a module.

DOMINATING THE ERDŐS-MOSER THEOREM

31

Proof. We need to ensure that given some part ν of some condition c = (F~ , C, R) and some
answer a to a Σ01 formula ψ(D) = box(hc, νi , ϕ) where ϕ(D, G) is a Σ01 formula, unbox(hc, νi , a)
~ D, R) is a condition such that d ≤f c where f forks only
outputs a tuple hd, f, bi where d = (E,
part ν of c, and for every part µ of d such that f (hd, µi) = hc, νi, and every set G ∈ sat(hd, µi),
b(hd, µi) is an answer to ϕ(D, G).
Suppose that a = hNoi. By definition of sat(hd, µi) and by construction of d, GLis RD transitive and satisfies the Mathias condition (Eνi , Yνi ) for some i < 2 and some cover µ Yµ ∈
D. In particular, Eνi = Fν and Yνi is such that for every finite RD -transitive set E ⊆ Yνi ,
ϕ(D, Fν ∪ E) does not hold.

 In particular, taking E = G r Fν, ϕ(D, G) does not hold.
Suppose now that a = Yes, r, E 0 , . . . , E r−1 , f 0 , . . . , f r−1 , a′ where a′ is a function which on
every i < r and every 2-partition hE0 , E1 i = i, returns an answer to ϕ(D, Fν ∪ gi (hE0 , E1 i)). By
definition of sat(hd, µi) and by construction
of d, G is RD -transitive and satisfies the Mathias
L
condition (Eµ , Yµ ) for some cover
µ Yµ ∈ D, where µ = hi, E0 , E1 i. By construction of d,
i
Eµ = Fν ∪ g (hE0 , E1 i), and by definition of g i , ϕ(D, Fν ∪ gi (hE0 , E1 i)). Since G satisfies
(Eµ , Yµ ), Fν ∪ g i (hE0 , E1 i) ⊆ G and G r Eµ ⊆ Yµ . Therefore ϕ(D, G) holds.


5.4. The separation
We have defined a module MEM for the Erdős-Moser theorem. In this subsection, we explain
how we create an ω-model of EM which is not a model of AMT from the infinite sequence of stage
trees constructed in subsection 4.3. Given the uniform enumeration R0 , R1 , . . . of all primitive
recursive tournament functionals, we shall define an infinite sequence of sets X0 , X1 , . . . together
with a ∆02 function f such that for every s,
1. Xs+1 is an infinite, transitive subtournament of RX0 ⊕···⊕Xs
2. f dominates every X0 ⊕ · · · ⊕ Xs -computable function.
By 2, any ∆02 approximation f˜ of the function f is a computable instance of the escape property
with no solution in MX~ , that is, such that no function in MX~ escapes f . By the computable
equivalence between the escape property and the atomic model theorem (see subsection 1.3),
MX~ 6|= AMT. By Lemma 5.2, MX~ |= EM ∧ COH.
Start with X0 = ∅ and the ∆02 enumeration T0 ≥ T1 ≥ . . . of stage trees constructed in
subsection 4.3, and let c0 ≥ c1 ≥ . . . be the sequence of their roots. The set U of their parts
form an infinite, finitely branching tree, whose structure is given by the refinement functions.
Moreover, by the construction of the sequence T0 , T1 , . . . , for every s, there is some part ν in
cs+1 refining some part µ in cs and which forces prog(µ). Call such a part ν a progressing part.
We may also consider that every part of c0 is a progressing part, for the sake of uniformity. By
the implementation of prog, if ν is a progressing part which refines some part µ, µ is also a
progressing part. Therefore, the set the progressing parts forms an infinite subtree U1 of U .
Let ν0 , ν1 , . . . be an infinite path through U1 . Notice that sat(νs ) 6= ∅. Indeed, if sat(νs ) = ∅,
~ s , Cs ), and therefore we cannot find some prothen the part νs is empty in Cs , where cs = (E
T
T
gressing part νs+1 refining νs . Therefore, the set s sat(νs ) is non-empty. Let X1 ∈ s sat(νs ).
By definition of sat(νs ), X1 is a transitive subtournament of RX0 . By definition of prog, for
every s and every set G ∈ sat(νs ), there is some n ∈ G such that n > s. Therefore, the set X1
is infinite, so the property 1 is satisfied.
[ν ]
[ν ]
Repeat the procedure with the sequence of stage trees T1 1 ≥ T2 2 ≥ . . . and so on. We
obtain an infinite sequence of sets X0 , X1 , . . . satisfying the property 1. Let f be the ∆02 function
which on input x, returns max(Ux )+1 where Ux is the finite set stated in the domination lemma
0 ⊕···⊕Xi is total.
(Lemma 4.9) for stage trees of depth x. Fix some Turing index e such that ΦX
e
0 ⊕···⊕Xi (x) ∈ U
By the domination lemma, for every x ≥ max(e, i), ΦX
x < f (x). Therefore
e
the function f dominates every X0 ⊕ · · · ⊕ Xi -computable function. This finishes the proof of
Theorem 5.1.

32

LUDOVIC PATEY

6. Separating combined principles from AMT
The domination framework has two purposes. First, it emphasizes on the key elements of the
construction and gets rid of the implementation technicalities by abstracting the main operations
into operators. Second, it enables us to separate conjunctions of principles from AMT, using the
ability to compose modules into a compound one. In this section, we will take advantage of the
latter to prove that EM is not strong enough to prove AMT, even when allowing compactness
arguments.
Theorem 6.1 There is an ω-model of EM ∧ COH ∧ WKL which is not a model of AMT.
In subsection 6.1, we will show how to compose multiple modules to obtain separations of
conjunctions of principles from AMT. Then, in subsection 6.2, we will provide a module for
WKL and will show how to choose properly the sequence of sets X0 , X1 , . . . to obtain an ω-model
of WKL.
6.1. Composing modules
When building the second-order part I of an ω-model of a countable collection of principles
P0 , P1 , . . . , we usually interleave the instances of the various P’s so that each instance receives
attention after a finite number of iterations. This is exactly what we will do when composing
module supports Si = hPi , Ui , partsi , initi , sati i for Pi for each
V i ∈ ω, in order to obtain
a compound module support S = hP, U, parts, init, sati for i∈N Pi . The domain of the
partial order P is obtained by taking the disjoint union of the partial orders Pi . Therefore
P = {hc, ii : i ∈ N ∧ c ∈ Pi }. The order is defined accordingly: hd, ji ≤P hc, ii if i = j and
d ≤Pi c. Similarly, U = {hν, ii : i < N ∧ ν ∈ Ui }, parts(hc, ii) = {hν, ii : ν ∈ partsi (c)} and
sat(hν, ii) = sati (ν).
The key element of the composition is the definition of init(n), which will return initi (m)
if n codes the pair (m, i). This way, infinitely many iterations are responsible for making I
satisfy Pi for each i ∈ N. The construction within the domination framework therefore follows
the usual construction of a model satisfying two principles.
The property (i) in the definition of a module support for S inherits from the property (i)
of Si for each i ∈ N. Indeed, if hd, ji ≤P hc, ii, then j = i and d ≤Pi c. By the property (i)
of Mi , there is a function f : partsi (d) → partsi (c) such that sati (ν) ⊆ sati (f (ν)) for
each ν ∈ partsi (d). Let g : parts(hd, ii) → parts(hc, ii) be defined by g(hν, ii) = hf (ν), ii.
sat(hν, ii) = sati (ν) ⊆ sati (f (ν)) = sat(g(hν, ii).
Given a module Mi = hSi , boxi , unboxi , progVi i for Pi for each i ∈ N, the definition of the compound module M = hS, box, unbox, progi for i∈N Pi does not contain any particular subtlety.
Simply redirect box(hν, ii , ϕ) to boxi (ν, ϕ), unbox(hν, ii , a) to unboxi (ν, a), and prog(hν, ii) to
progi (ν). Again, the properties of a module support for M inherit the properties for Mi .
6.2. A module for WKL
Weak König’s lemma states for every infinite binary tree the existence of an infinite path
through it. The usual effective construction of such a path follows the classical proof of König’s
lemma: we build the path by finite approximations and consider the infinite subtree below the
finite path we constructed so far. The difficulty consists of finding which ones, among the finite
extensions candidates, induce an infinite subtree.
First note that we do not share the same concerns as for the Erdős-Moser theorem about
the choice of an instance, since WKL admits a universal instance which is the tree whose paths
are completions of Peano arithmetics. Moreover, this universal instance is a primitive recursive
tree functional.
It is natural to choose the infinite, computable binary tree functionals as our forcing conditions. A condition (tree) U extends T if U D ⊆ T D . A set G satisfies the condition T if G is an
infinite path through T D . Let us now see how we decide some Σ01 query ϕ(D, G). Consider the
following question:
Q6: Is the set T D ∩ {σ ∈ 2<ω : ¬ϕ(D, σ)} finite?

DOMINATING THE ERDŐS-MOSER THEOREM

33

<ω : ¬ϕ(D, σ)}. Whenever ϕ(D, τ ) holds and ρ  τ , ϕ(D, ρ) holds, thus
Let ΓD
ϕ = {σ ∈ 2
0,D
D
D
ΓD
ϕ is a tree. At first sight, the question Q6 seems Σ2 . However, T ∩ Γϕ is a tree, so the
question can be formulated in a Σ0,D
way as follows:
1

Q6’: Is there some length n such that T D ∩ ΓD
ϕ has no string of length n?
If the answer is negative, the extension T ∩ Γϕ is valid and forces ϕ(D, G) not to hold. If the
answer is positive, the condition T already forces ϕ(D, G) to hold. Note that there is a hidden
application of our moto “if you cannot choose, try every possibilities in parallel”. Indeed, in
many forcing arguments involving weak König’s lemma, we ∅′ -choose an extensible string σ ∈ T
such that ϕ(D, σ) holds and T D,[σ] is infinite. However, we meet the same problem as in the
Erdős-Moser case, that is, we are unable to decide which of the σ’s will be extensible into an
infinite subtree. To be more precise, for every σ ∈ 2n , there may be some D such that the
D,[σ] is finite. By taking T as our extension forcing ϕ(D, G) to hold, we take in reality
set
S T
[σ]
[σ]
σ∈2n ∩T T , that is, we take the union of the candidate extensions T . We are now ready to
WKL
define a module support S
= hP, U, parts, init, sati for WKL.
The set P is the set of conditions as defined above. Each condition has only one part which
can be identified as the condition itself, therefore U = P. Accordingly, parts(T ) = {T }. The
function init(n) always returns the universal instance of WKL. Last, sat(T ) is the collection
of the infinite paths through T D .
Lemma 6.2 SWKL is a module support.
Proof. We need to check the property (i) of a module support. Let U ≤P T for some conditions T
and U ∈ P. Define f : parts(U ) → parts(T ) as the function f (U ) = T . We claim that
sat(U ) ⊆ sat(f (U )) for each U ∈ parts(U ). Since parts(U ) = {U }, we need to check that
sat(U ) ⊆ sat(T ), which is immediate since U ⊆ T .




We now define the module MWKL = SWKL, box, unbox, prog as follows. Given some tree
n
T and some query ϕ(D, G), box(T, G) is the formula ψ(D) = (∃n)[T D ∩ ΓD
ϕ ∩ 2 = ∅]. Recall
<ω : ¬ϕ(D, σ)}. If the answer to the question ψ(D) is hNoi, unbox(T, hNoi)
that ΓD
ϕ = {σ ∈ 2
returns the tuple hT ∩ Γϕ , f, bi where f : parts(T ∩ Γϕ ) → parts(T ) is trivially defined by
f (T ∩ Γϕ ) = T and b is the constant function returning hNoi everywhere. In the answer to
n
the question ψ(D) is a = hYes, n, a′ i, where n is the integer witnessing T D ∩ ΓD
ϕ ∩ 2 = ∅ and
′
a witnesses the other existentials variables in ϕ(D, G), unbox(T, a) returns the tuple hT, id, bi
where id is the identify refinement function and b is the constant function returning hYes, a′ i
everywhere. No progress is needed for WKL. Therefore, prog(T ) can be chosen to be any
formula.
Lemma 6.3 MWKL is a module.
Proof. We need to ensure that, given the unique part T of the condition T and some answer a
to a Σ01 formula ψ(D) = box(T, ϕ) where ϕ(D, G) is a Σ01 formula, unbox(T, a) outputs a tuple
hU, f, bi where U is an extension of T , f : parts(U ) → parts(T ) is defined by f (U ) = T and
for every set G ∈ sat(U ), b(U ) is an answer to ϕ(D, G).
Suppose that a = hNoi. By definition of unbox(T, hNoi), U = T ∩ Γϕ and b is the constant
function hNoi. By definition of sat(U ), G is an infinite path through T D ∩ ΓD
ϕ . Let σ be any
D n ϕ(D, σ) does not
initial segment of G. In particular, σ ∈ ΓD
.
Unfolding
the
definition
of
Γ
ϕ
ϕ
hold. Therefore ϕ(D, G) does not hold.
Suppose now that a = hYes, n, a′ i, where a′ witnesses the existential variables of ϕ(D, G).
Again, by definition of unbox(T, a), U = T , f is the identify function and b is the constant
function returning hYes, a′ i everywhere. By definition of sat(U ), G is an infinite path through
n
T D . Let σ be an initial segment of G of length n. Since T D ∩ ΓD
ϕ ∩ 2 = ∅, ϕ(D, σ) holds, so
ϕ(D, G) holds.


34

LUDOVIC PATEY

Finally, we explain how to extract a solution to the universal instance of WKL below some
set D, given the infinite decreasing sequence of stage trees constructed in subsection 4.3. Given
the sequence T0 ≥ T1 ≥ . . . whose roots are T0 ≥ T1 ≥ . . . , there is no much T
choice since each
D
condition Ts has only one part, that
T is,D the tree Ts itself. By compactness, s Ts is infinite.
Take any infinite path G through s Ts . This completes the proof of Theorem 6.1.
6.3. Beyond the atomic model theorem

We conclude this section by a discussion on the generality of the domination framework and
its key properties.
Ramsey-type theorems satisfy one common core combinatorial property: given an instance I
of a principle P, for every infinite set X ⊆ N, there is a solution of Y ⊆ X of I. This property
makes Ramsey-type principles combinatorially weak. Indeed, Solovay [30] proved that the sets
computable by every solution to a given instance I of P are precisely the hyperarithmetical
ones. Moreover, Groszek and Slaman [10] proved that the hyperarithmetical sets are precisely
the sets S admitting a modulus, namely, a function f such that every function dominating f
computes S. These results put together can be interpreted as stating that the coding power of
Ramsey-type principles comes from the sparsity of their solutions. If an instance can force its
solutions H = {x0 < x1 < . . . } to have arbitrarily large gaps, then the principal function pH
defined by pH (n) = xn will be fast-growing, and contain some computational power.
The strength of many principles in reverse mathematics can be explained in terms of the
ability to ensure gaps in the solutions. ACA has instances whose solutions are everywheresparse, in that the principal function of the solutions dominated the modulus function of ∅′ .
Some principles such as COH, AMT or FIP imply the existence of hyperimmune sets, which
are sets sparse enough so that their principal function is not dominated by any computable
function. These sets have infinitely many gaps, but their repartition cannot be controlled.
Another important aspect of the hole-based analysis is their definitional complexity. For
example, AMT has the ability to ensures ∆02 gaps, which gives it more computational power
than COH or EM which can only have ∆01 gaps. This is the main feature used by the domination
framework to prove that COH ∧ EM does not imply AMT. This framework was designed to
exploit this weakness of the principles, and is therefore relatively specific to the atomic model
theorem. However, some weakenings of AMT, such as the finite intersection property, share
some similar properties, in that they can also be purely characterized in terms of hyperimmunity
properties. The author leaves open the following question:
Question 6.4 Does COH imply FIP in RCA0 ?
Acknowledgements. The author is thankful to his PhD advisor Laurent Bienvenu for useful
comments and discussions. The author is funded by the John Templeton Foundation (‘Structure
and Randomness in the Theory of Computation’ project). The opinions expressed in this
publication are those of the author(s) and do not necessarily reflect the views of the John
Templeton Foundation.

References
[1] Andrey Bovykin and Andreas Weiermann. The strength of infinitary Ramseyan principles can be accessed
by their densities. Annals of Pure and Applied Logic, page 4, 2005. To appear.
[2] Peter Cholak, Rod Downey, and Greg Igusa. Any FIP real computes a 1-generic. arXiv preprint
arXiv:1502.03785, 2015.
[3] Peter A. Cholak, Carl G. Jockusch, and Theodore A. Slaman. On the strength of Ramsey’s theorem for
pairs. Journal of Symbolic Logic, 66(01):1–55, 2001.
[4] Chitat Chong, Theodore Slaman, and Yue Yang. The metamathematics of stable Ramsey’s theorem for
pairs. Journal of the American Mathematical Society, 27(3):863–892, 2014.
[5] Chris J. Conidis. Classifying model-theoretic properties. Journal of Symbolic Logic, 73(03):885–905, 2008.
[6] S. Barry Cooper. Minimal degrees and the jump operator. Journal of Symbolic Logic, 38(02):249–271, 1973.

DOMINATING THE ERDŐS-MOSER THEOREM

35

[7] Rod Downey, David Diamondstone, Noam Greenberg, and Daniel Turetsky. The finite intersection principle
and genericity. to appear in the Mathematical Proceedings of the Cambridge Philosophical Society. Available
at http://homepages.ecs.vuw.ac.nz/~ downey/publications/FIP_paper.pdf, 2012.
[8] Damir D. Dzhafarov. Strong reductions between combinatorial principles. In preparation.
[9] Damir D. Dzhafarov and Carl Mummert. On the strength of the finite intersection principle. Israel J. Math.,
196(1):345–361, 2013.
[10] Marcia J Groszek and Theodore A Slaman. Moduli of computation (talk). Buenos Aires, Argentina, 2007.
[11] Denis R. Hirschfeldt. Slicing the truth, volume 28 of Lecture Notes Series. Institute for Mathematical Sciences.
National University of Singapore. World Scientific Publishing Co. Pte. Ltd., Hackensack, NJ, 2015. On the
computable and reverse mathematics of combinatorial principles, Edited and with a foreword by Chitat
Chong, Qi Feng, Theodore A. Slaman, W. Hugh Woodin and Yue Yang.
[12] Denis R. Hirschfeldt and Carl G. Jockusch. On notions of computability-theoretic reduction between Π12
principles. J. Math. Log., 16(1):1650002, 59, 2016.
[13] Denis R. Hirschfeldt, Carl G. Jockusch, Bjørn Kjos-Hanssen, Steffen Lempp, and Theodore A. Slaman. The
strength of some combinatorial principles related to Ramsey’s theorem for pairs. Computational Prospects
of Infinity, Part II: Presented Talks, World Scientific Press, Singapore, pages 143–161, 2008.
[14] Denis R. Hirschfeldt and Richard A. Shore. Combinatorial principles weaker than Ramsey’s theorem for
pairs. Journal of Symbolic Logic, 72(1):171–206, 2007.
[15] Denis R. Hirschfeldt, Richard A. Shore, and Theodore A. Slaman. The atomic model theorem and type
omitting. Transactions of the American Mathematical Society, 361(11):5805–5837, 2009.
[16] Carl G. Jockusch and Frank Stephan. A cohesive set which is not high. Mathematical Logic Quarterly,
39(1):515–530, 1993.
[17] Laurie Kirby and Jeff Paris. Accessible independence results for peano arithmetic. In Bulletin of the London
Mathematical Society, volume 14, pages 285–293. Oxford University Press, 1982.
[18] Alexander P. Kreuzer. Primitive recursion and the chain antichain principle. Notre Dame Journal of Formal
Logic, 53(2):245–265, 2012.
[19] Manuel Lerman, Reed Solomon, and Henry Towsner. Separating principles below Ramsey’s theorem for
pairs. Journal of Mathematical Logic, 13(02):1350007, 2013.
[20] Joseph Roy Mileti. Partition theorems and computability theory. ProQuest LLC, Ann Arbor, MI, 2004. Thesis
(Ph.D.)–University of Illinois at Urbana-Champaign.
[21] Antonio Montalbán. Open questions in reverse mathematics. Bulletin of Symbolic Logic, 17(03):431–454,
2011.
[22] Ludovic Patey. A note on ”Separating principles below Ramsey’s theorem for pairs”. Unpublished. Available
at http://ludovicpatey.com/media/research/note-em-sts.pdf, 2013.
[23] Ludovic Patey. Degrees bounding principles and universal instances in reverse mathematics. Annals of Pure
and Applied Logic, 166(11):1165–1185, 2015.
[24] Ludovic Patey. Iterative forcing and hyperimmunity in reverse mathematics. In Arnold Beckmann, Victor Mitrana, and Mariya Soskova, editors, CiE. Evolving Computability, volume 9136 of Lecture Notes in
Computer Science, pages 291–301. Springer International Publishing, 2015.
[25] Ludovic Patey. Somewhere over the rainbow Ramsey theorem for pairs. Submitted. Available at
http://arxiv.org/abs/1501.07424, 2015.
[26] Ludovic Patey. The weakness of being cohesive, thin or free in reverse mathematics. Israel J. Math.,
216(2):905–955, 2016.
[27] David Seetapun and Theodore A. Slaman. On the strength of Ramsey’s theorem. Notre Dame Journal of
Formal Logic, 36(4):570–582, 1995.
[28] Joseph R. Shoenfield. On degrees of unsolvability. Annals of Mathematics, 69(03):644–653, May 1959.
[29] Robert I. Soare. Turing computability. Theory and Applications of Computability. Springer-Verlag, Berlin,
2016. Theory and applications.
[30] Robert M. Solovay. Hyperarithmetically encodable sets. Trans. Amer. Math. Soc., 239:99–122, 1978.
[31] Wei Wang. The definability strength of combinatorial principles, 2014. To appear. Available at
http://arxiv.org/abs/1408.1465.
[32] Liang Yu. Lowness for genericity. Archive for Mathematical Logic, 45(2):233–238, 2006.

36

LUDOVIC PATEY

Appendix A. Evolution of the local zoo
In this last section, we give a short history of the zoo related to the Erdős-Moser theorem. In
Figure 6, we present the various implications proven between the principles EM, STS2 , SADS
and AMT. An arrow denotes an implication over RCA0 . A dotted arrow from a principle P to
a principle Q denotes the existence of an ω-model of P which is not a model of Q.
COH + EM + WKL

(5)

EM

(4)
(6)

(5)
(3)

STS(2)

SADS
(2)

(1)

AMT
Figure 6. Evolution of the zoo
Justification of the arrows:
(1) Hirschfeldt, Shore and Slaman [15] proved that AMT is a consequence of SADS over RCA0 .
(2) The author proved in [25] that STS(2) implies AMT over RCA0 using a similar argument.
(3) Lerman, Solomon and Towsner [19] separated EM from SADS using an iterated forcing
construction.
(4) The author noticed in [22] that the forcing of Lerman, Solomon and Towsner could be
adapted to separate EM from STS(2) over RCA0 .
(5) Wang [31] used the notion of preservation of ∆02 definitions to separate COH + EM + WKL
from SADS and STS(2) over RCA0 .
(6) This is the main result of the current paper.

