Contents

I Systems

1

2

.

.

. .

.
. .

Taking/Adding Objects/Relations
Separating and Combining Subsystems

Generating New Systems .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1
.
. . . . . . . . . . . . . . . . . . . . . . .
1.2
.
. . . . . . . . . . . . . . . . . . . .
. .
Relations and Objects . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Equivalence .
.
.
2.1
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Order
. .
2.2
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Comparability .
.
.
2.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
Function .
.
.
.
2.4
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
.
Deﬁnition .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image .
.
.
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
Classiﬁcations
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
Composition .
Inverse and Unit
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
Two Part Function and the Meaning of Equality for Functions
. . . . . . . .
.
Selection Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Order Preserving Function and Galois Connections [VIII]
. . . . . . . . . .
Natural Pair of Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Operation .

2.5

.
.
.

.

.

.

.

.

.

II Category

3

4

5

.

.

.

.

.

.

.

.

.

. .

. .

. .

Arrows
3.1
3.2

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Deﬁning Equality of Arrows . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Classifying Arrows [I]
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Invertible .
.
.
Left and Right Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
Partial Order
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Algebraic Category .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
.
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

Natural Pair of Functions in the Deﬁnition of Functor . . . . . . . . . . . . .
Isomorphism . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Classiﬁcation of Other Functor Types . . . . . . . . . . . . . . . . . . . . .
Embedding .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Functor for Partial Orders

Some Categories
4.1
4.2
Functor
5.1
5.2
5.3

. .
.
.

. .
.

. .

. .

. .

. .

.

.

.

.

.

.

.

15
15
15
16
16
17
17
18
18
18
18
18
19
19
19
20
20
21
21

23
23
23
24
24
24
25
25
25
27
29
29
30
30
31

1

CONTENTS

2

6
7

. .

5.4

Opposite Category and Contravariant Functor . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Algebraic Functor
. . . . . . . . . . . . . . . . . . . . . . . .
Product Category and Bifunctor
Product Functor for Common Domain . . . . . . . . . . . . . . . . . . . .
.
Bifunctor[IX] .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Decomposing Bifunctors . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Natural Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
5.5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Integer Systems .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Rational Systems . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Product
7.1
. .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2
Dual Orders .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Involution . .
7.3
Product for Rational Systems
7.4
. . . . . . . . . . . . . . . . . . . . . . . . .
Sum for Rational Systems . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.5
.
Embedding .
7.6

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. .
. .
. .
. .
. .

.

.

.

.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

31
35
35
37
38
41
41
45
49
49
50
53
53
54
56

57
58
58
58
58
58
58
59
59
59
59
59
60
61
61
61
62
62
64
67
68
68
68
69
70
70
71
71
71

III Set Theory

Set Operations .
8.1

8.2

8.3

8

9

10

.

.

.

.

.

.

.

.
.

.
.
. .

. .
.
.

.
.
.
.
.
.
. .
.
.

.
.
.
.
. .
.
.

.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
First Generation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Union .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Diﬀerence .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Second Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Intersection .
Complement
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Properties .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Unit .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Inverse .
.
Other Representations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Distributions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Collection Category . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Partial Order, Under Inclusion . . . . . . . . . . . . . . . . . . . . . . . . .
Concrete Category . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Hom Set
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Yoneda’s Lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Representable Functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image and Inclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image and Set Operations
. . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Fiber
Quotient Sets and Decomposition of Functions . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sequence .
.
Representation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Monotonic Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. .
.
.

.
.

.
.

.

.

.

.

.
.

.

.

.

.
.

.

.

.

.

.

.

.

.

.

.

.

Categories .
9.1
9.2
9.3

Set Function .
10.1

10.2
10.3

CONTENTS

. .

. .

10.4

. .
.

11.2
11.3

10.5 Matrix .
.
Special Families .
11.1

.
Sequence of Objects for an Operation . . . . . . . . . . . . . . . . . . . . .
.
Sequence of Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Sequence for Composition . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Sequence and Cartesian Product
. . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
Net
. .
. .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bounds .
.
. .
. .
.
Directed Set .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Deﬁnition .
.
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
. .
. .
.
.
.
.
Power Set .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. .
Power Functor
.
.
.
Direct Image .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Another Functor
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Family of Families .
.
.
Nest . .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Increasing Nest . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Decreasing Nest
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
σ-Algebra .
. .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Generated σ−algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Set Filter
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Filter Generated by a Base . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . .
Principal Filter and Filter Generated by a Point
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Coﬁnite Filter .
.
.
Fréchet Filter Base and Filter . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Filter as a Directed Set
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Image .
.
.
Elementary Filter of a Net
. . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ultraﬁlter .
Zorn’s Lemma and the Axiom of Choice . . . . . . . . . . . . . . . . . . . . . . . .
.

11.4

11.5

. .

. .

. .

. .

. .

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

11

12

IV Universal Concepts

V Lattice

13
14
15

16 Completeness .

.

.

.

.

.

.

.

.

.

.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
Supremum and Inﬁmum .
Lattice .
.
.
Semilattice and Algebraic Aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Order of a Semilattice
15.1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Lattice as an Algebraic Structure . . . . . . . . . . . . . . . . . . . . . . . . .
15.2
.
.
.
.
.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Complete Partial Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Directed Complete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Naturally Complete .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Bounded Complete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Complete Lattice .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16.2

16.1

.

.

.

.

.

.

.

.

3

72
72
73
73
73
73
74
74
74
75
75
75
76
77
77
77
77
77
78
78
78
79
79
80
80
80
80
81
81
82

83

85
85
86
87
87
88
89
89
89
90
90
91

4

VI Group

17

Subcollections .
17.1
17.2
17.3
17.4

.

.

.

.

.

.

.
.
.

. .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Power operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
Subgroup . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Congruence Class .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Invariant subspace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Homomorphism.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Isomorphism .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Automorphism .
Action Group .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
Group, Action Group and Group of Transformations . . . . . . . . . . . . .
Similarity .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Transitive Action Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.

.

.

.

.

18 Quotient group . .
. .
19 Commutator . .
20
.

Transformation .
20.1
20.2
20.3
20.4

VIILinear Space

VIIITopological System

21

Two Descriptions, One System . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21.1
.
.
21.2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.

. .
. .
.
.

. .
. .
.
.

Closure .
.
Interior
22 Neighborhoods
.
./extract

CONTENTS

93
93
.
93
.
93
.
95
.
96
.
97
.
.
98
. 101
. 101
. 102
. 103
. 105
. 105
. 105
. 106

109

111
. 111
. 111
. 113
. 113

Introduction

The attempt is to give a formal concpet of system, and with this provide a deﬁnition of category, that
will also satisfy the deﬁnition of a system. An axiomatic base is given, for constructing the group of
integers. In the process, we deﬁne a group of automorphisms; we are deﬁning an ordered group of
functors with a natural transformation between any two. We give an isomorphism from the group of
integers into the group of automorphisms, as guaranteed by Cayley’s Theorem. The ultimate aim is to
use these deﬁnitions and concepts, of system and category, to give a general description of mathematics.
When studying a system we will identify two kinds of components, as enough to deﬁne a system.
We shall call the one kind objects and the other kind relations.
In essence, it is being argued that
anything can be thought as being completely described by 1) the things it is composed of, and 2) the
characteristics about it and the things that compose it.

There are three properties that will be regarded as of absolute importance in the study of systems.
These are three characteristics that appear throughtout systems of all sorts. We speak of Structure,
Symmetry, and Inheritance. This last takes the form of order, as well. The inheritance principal
is viewed as a principal of conservation.
In considering inheritance, we wish to establish formal
observations to the following questions, regarding formation of new systems from old ones:

1) What basic properties are passed on from one system to another?

2) If a new system has been formed, what systems could it come from (who are the possible parents)?

3) If two systems are formed from one, what properties will these two new systems have in common?

It was necessary to ﬁrst describe a system, in order to later describe relations between systems.
The relations, in turn, were used for the description of inheritance principles. There is a parallelism
with categories, functors and natural transformations. The system takes the place of category, while the
functor takes the place of relations between systems. Finally, the natural transformation describes an
inheritance principle. In the development of category theory, the same line of thought was followed, as
was pointed out by [I]:

“...‘category’ has been deﬁned in order to deﬁne ‘functor’ and ‘functor’ has been deﬁned
in order to deﬁne ‘natural transformation’."

Inheritance can be studied in terms of society; a system that satisifes a property, that is also satisifed
by all the objects in the system. So we may say a human society is a society, since the interactions
of diﬀerent societies are more or less like human interactions. One can say a human (or any living
organism, for example) is a society of cells. Cells themselves are born, interacting, reproducing in one
form or another, and dying. Do cells inherit these properties from particles?

5

6

CONTENTS

In mathematics this situation is encountered. One can say certain collections of groups are also
groups. We can consider the collection of collections as a society. We would like to verify if ﬁlter,
topology, vector space, and many other concepts can be seen as a society. Can we deﬁne some system,
whose objects are vector spaces, so that this new system is itself in one way or another like a vector
space? Notice we are not asking that the system be a vector space, just that it has some property that
vector spaces have. We can also consider the collection of ﬁlters, on a set, and see how inheritance
plays out in this context.

There is a diﬀerence between the deﬁnition of category given here, and the deﬁnition given in [I]:
Deﬁnition. A metagraph consists of objects a,b,c,..., arrows f,g,h,..., and two operations as follows:

Domain, which assigns to each arrow f an object a=dom f

Codomain, which assigns to each arrow f an object b=cod f

These operations on f are best indicated by displaying f as an actual arrow starting at its domain
(or “source”) and ending at its codomain (or “target”): f : a → b...A metacategory is a metagraph
with two additional operations:

Identity, which assigns to each object a an arrow ida = 1a : a → a
Composition, which assigns to each pair (cid:104)g, f(cid:105) of arrows with dom g = cod f an arrow g ◦ f ,
called their composite, with g ◦ f : dom f → cod g... These operations in a metacategory are
subject to the two following axioms:
Associativity. For given objects and arrows in the conﬁguration a f→ b g→ c k→ d one always has
the equality k ◦ (g ◦ f ) = (k ◦ g) ◦ f . This axiom asserts that the associative law holds for the
operation of composition whenever it makes sense (i.e., whenever the composites on either side
of (1) are deﬁned).
Unit law.For all arrows f : a → b and g : b → c composition with the identity arrow 1b gives
1b ◦ f = f and g ◦ 1b = g. This axiom asserte that the identity arrow 1b of each object b acts as
identity for the operation of composition, whenever this makes sense.

Contrary to this deﬁnition, the deﬁnition of category we will provide, in terms of systems, consists
of two kinds of objects. We call the ordinary objects, c-objects. Arrows will be the other kind of object,
of the system. This process of considering arrows as object is a key concept that is present throughout.
This is how generalizations and complexity arises: by taking relations, and making relations about
those. For example, relations of the form a → c ⇒ b → d can be turned into objects of arrows a →
c ⇒ b → d =⇒ e → g ⇒ f → h. Arrows are one particular way of seeing relations, in mathematics.
The deﬁnition of category will be a system with relations regarding the arrows and objects. Arrows can
be (cid:9) (reﬂexive) or ↔ (symmetric). The following diagram is very important and we will try to see the
underlying properties, uses and consequences of it.

For example, in topology the diagram expresses concepts of separability; the diagram will be used to
give a description of supremum, and density. Curiously, in the scope of these deﬁnitions, the supremum

(cid:37)b(cid:38)−→ c

a

CONTENTS

7

is a particular case of density. Of course, this is also the diagram that expresses transitivity. We can also
think of this diagram when we are developing products of functors, on product categories. It describes
three main forms that inheritance will take (each one of these forms for inheritance can be seen reﬂected
in one of our three questions regarding inheritance):

1) Generational Inheritance

2) Common Descendency

3) Common Origin

(cid:37)◦(cid:38)
=⇒◦

◦

(cid:116)◦(cid:38)−→◦

◦

(cid:37)◦(cid:117)−→◦

◦

We ﬁrst speak of systems and immediately after, introduce relations, arrows, and equivalence.

Orders are given in three main types; preorder, partial order, natural order. After making such diﬀerentiations,
we see basic deﬁnitions and observations. We end this subsection with the construction (rather, the
assumption of existence) of a natural order that is not trivial, the order of integers. We move on
to functions, on collections, and provide the basic types and deﬁnitions of functions. We include a
deﬁnition of two-part functions, which are crucial in the deﬁnition of functor. Here we introduce the
concept of selection function to describe the Axiom of Choice, for the ﬁrst time. Also, we deﬁne order
preserving functions and duality is brought into play for the ﬁrst time, in the form of dual orders. At
the end we see an important description of how two functions can be asked to behave well, in joint.
We ﬁrst study Galois Connections, and then we study the concept natural pair of functions. This last,
will be the main idea behind the concpet of functor; we will give the defnition of functor, in terms of
this concept. A notation is deﬁned and presented in the context of arrows, functions, operations, and
generalizations of these. This will enable us to give mechanical proofs in many circumstances.

There is a special kind of function, that we deﬁne as operation. That is, next we deﬁne an operation
as a function that sends objects into functions. We deﬁne the concept of left and right operations, for
a certain type of operations. When we operate two objects, we can take the view that either of the two
objects, was acting on the other; a function is associated to one object and this applied to the other
object is the result of the operation. Consider an object in the collection, for which a closed operation is
deﬁned, call the object x. We can say, on the one hand, object x acts, on other objects of the collection
in such manner... To verify this, we would provide a list of pairs of objects; the ﬁrst of each pair is the
object operated with x. The second of each pair is the corresponding result of the operation, between x,
and the ﬁrst of the pair. One can also say, the objects of O act on x, according to... To verify this, we
would give another list of pairs. Here the ﬁrst of each pair is the object that acts on x and the second is
the result of the operation. The ﬁrst list is the right operation of x while the second is the left operation.
In chapter two, we introduce categories and the main properties of functor, along with a deﬁnition
of natural transformation. Here, we start by giving a basic classiﬁcation of arrows; isomorphism,
left/right cancellable, left/right invertible. After this, we show that a partal order is category and we
also deﬁne algebraic categories, motivated by considering a category whose arrows are functors from

8

CONTENTS

one category to itself. This is the concept of a monoid, as given in [I]. We also give the deﬁnition
of a group and prove very basic properties regarding unit and inverse. The functor is next, and we
begin by giving a deﬁniton of functor that will provide easy to relate to the concept of natural pair
of functions. After giving a brief classiﬁcation of some functor types, we deﬁne opposite category
and functor. We prove that there is an opposite functor on the category of all categories. This serves as
bases for a discussion on contravariant functor. We see a general description of a simple type of functor,
the algebraic functor. The next subsection provides a construction of product category and we try to
see what functors look like in this tyoe of category. We then deﬁne bifunctors with one component
contravariant, the other covariant. This is followed by a theorem that allows decomposition of some
bifunctors, into two simpler bifunctors. After studying the functor, we go into natural transformation
and we see how this relates to the constructions given for the product of two functors, with common
domain. Throughout, we will apply the concept of using arrows as objcets, so as to generalize the
concept of arrows between arrows. The natural transofrmation is great example of how this and for that
we show that natural transformations can compose in two manners. We show the interchange law for
the vertical and horizontal compositions of natural transformations, and after this we show that there are
two categories to be considered. These are 1) the category of functors Cat(C,D), and 2) the 2-category
of all categories which we will denote (cid:126)Cat.
The section of integers is central, it begins retaking the discrete number system. A discrete number
system is one whose objects and arrows are arranged in the form ··· → a → b → c → ··· → x →
y → z → ··· . We show that this system generates a group of automorphisms, on the partial order
which corresponds to the discrete number system. This group of automorphisms is generated using
one functor, the functor determined by the arrows of the discrete number system. Using this group
of automorphisms we build the group of integers with addition. We study the operation as functor,
and as a natural transfomation. In short, a discrete number system contains all the information needed
to construct a group on itself. Next, a second operation is deﬁned for integers. This is of course the
product, another functor. Rational systems are introduced through a construction that involves dual
orders. We see that a rational system is an involution. Then, the operations are deﬁned for the rationals
and we give an embedding of the integers into the rationals, as order and operation.

In chapter III, we start with an axiomatic base for sets that is quite similar to the one provided in [I];
in fact only minor changes have been made. After the basic properties and operations of sets, we study
sets as categories. The ﬁrst view is to see a set as collection category, then we see it as a partial order
under inclusion. Here, we will also introduce concrete category and give a proof of the Yoneda lemma.
We see how this relates to the construction provided for the integers through Cayley’s theorem.

We continue to set functions and we introduce here the concept of image and inverse image for a
family of sets. The general results that relate image, inclusion and set operations are presented. After
this, we present the concept of ﬁber and we use it to give a decomposition for set functions. The next
subsection for set functions, is sequence. In the paragraph Sequence of Objects for an Operation, we
introduce the concept of series by deﬁning a sequence of functions that can be applied to a sequence,
and that results in the sequence of partial sums. There is a paragraph on compositions of a sequence of
functions and here we introduce, among other things, the concept of invariant objects and sets. From
this we derive the concept of once-eﬀective functions. Once-eﬀective functions are important in the
study of the closure functor which is later used as a starting point in topology. We end the discussion
on sequences with a description of sequence in terms of cartesian product. The concept of sequence is
generalized in the next subsection. Here we start by deﬁning bounds and supremum. After this we start
discussion on directed sets and end with the deﬁnition of net. This is used for deﬁning matrices.

CONTENTS

9

The next section is on families of sets, starting with the power set and functor before deﬁning
direct image and direct inverse image for families. We then deﬁne the forward and backward image
of sets f →A, f ←B. After this, we establish a characterization for direct and direct inverse image in
terms of f →A and f ←B. We also note the duality between image and ﬁber, using the forward and
backward images. We see how to express the power set as another kind of functor. Some properties
and relations for special types of families are given and then we start with the study of ﬁlters. We give
a brief introduction to ultraﬁlters. Ultraﬁlters will be taken up again in the next chapter; when we study
lattices; after we have proven Zorn’s Lemma. In fact, The proof of Zorn’s Lemma is what follows next.
In Chapter IV, we study lattices. First, we revisit the supremum, then deﬁne lattice in terms of
supremum and order. The concept of semilattice is deﬁned algebraically in terms of an operation. We
show that sublattices and lattices are closely connected and then we show that a lattice can also be
viewed as an algebraic structure (with two operations) and a sublattice can also be viewed as an order.
After introducing lattices we see properties of completeness. Filters, in the general sense, and boolean
algebras are to be included here, but do not yet make appearence in this document.

After Lattices, we devote a chapter to group theory. The last chapter is a brief description of

topological systems. We describe them as functors on algebraic categories.
Let us take this oppostunnity to understand the notation that is used through to the end. Firstly, the
notation is presented for a general case of arrows. That is, if we have an arrow a → c −→ b → d we
express this by a, c; b, d. Next, we say that a; f x, f is equivalent to the statement the function f applied
to the object x, results in fx. Finally, we use the notation to express operations by saying a, c; b, d is
equivalent to the statement a∗d = b∗c. This way, if we deﬁne a, g; b, f as the statement saying f a = gb
we can express a,∗c; b,∗d or a, c; b, d as saying the same thing. For example, when deﬁning the integers
we give the operation in terms of comparability of arrows. That is, we give a system of arrows between
arrows and the operation is deﬁned so that it coincides with the notation. We deﬁne an order on top of
an existing order and this gives rise to strong arrows.

10

CONTENTS

List of symbols (Incomplete)

Sys
S , S (cid:48), S (cid:48)(cid:48), S (cid:48)(cid:48)(cid:48), ...
∅
a, b, c, ..., x, y, z, ...
O, Q,...
S X
f : a → b
{a → b}
{a →}
{→ b}
O1 →× O2 or O1 × O2
a →× b
x ≤ y or y ≥ x
x = y
x < y or y > x
a, c; b, d
f : O1 → O2
Dom f
Range f
Im f
f a, a f,
a; f a, f
a, g; b, f
fQ1 or f [Q1]
f −1Q2 or f −1[Q2]
g ◦ f
I : O → O
f −1
f|Q1
ι
Sel
Pop
x ≤op y
P,Q;Pop,Qop
P,Qop;Pop,Q
P,Pop;Pop,P

f (a), (a) f

Universal system
System
Empty system
Object
Collection of objects
Remove all objects, except X, and all relations that do not include X
Arrow
Collection of arrows from a into b
Collection of arrows with a as source
Collection of arrows with b as target
Cartesian product
Object of cartesian product
Comparability in partial order P
x ≤ y and y ≤ x
Irreﬂexive comparability in partial order
Comparability between arrows a → c and b → d
Function with O1 as domain and range is O2
Domain of the function f
Range of the function f
Image of the function
Image of object a, under f
Image of object a, under f , is f a
Image of a, under f , is the same object as image of b, under g
Image of subcollection Q1
Preimage of subcollection Q2
Composition of functions
Identity function
Inverse function
Function with domain restricted to Q1
Inmersion
Selection function
Opposite partial order
Comparability in opposite order
P, Q are order bijective
P, Q are dual
P is self dual

11

12
P,Q;Q,P
{O1 fO2}
O1 fO2
∗,⊕,·,◦, ...
∗x
x∗
a; a ∗ x, x
a, y; b, x
x; x, e
x; e, e
x; e, x−1
x, x; y, y
x∗, x∗;∗y,∗y or a, c; a ∗ b, b ∗ c
f, f ;∗ f x,∗x
a ⊕ b; (a ∗ x) ⊕ (b ∗ x), x
C, D, ...
A
O|C
A|C
b → c ∗ a → b
1x
1C
{a →iso b}
F : C → D
FO
FA
Cat
IC
ICat
{CFD}
CFD
{CFisoD}
Cop
f op : b →op a
Fop : Cop → Dop
op : Cat → Cat
F(cid:110)
f × g : C → D1 × D2
f × g : C1 × C2 → D × D
(h∗,∗g)
B : C1 × C2 → D
τ : O|C → A|D
Z
Z<
Z≤

CONTENTS

Galois connection for two partial orders P, Q
All functions O1 → O2
All functions Qa → Qb, for all subcollections Qa, Qb of Oa, Ob
Operation
Right operation
Left operation
The action of x on a results in a ∗ x
The action of x on a is the same object as the action of y on b
The object e is a unit of the operation
The object e absorbs with the operation
The objects x, x−1 are dual to the unit
The operation commutes
The operation is associative
Function and operation commute
Two operations commute
Category
Collection of arrows
Collection of objects of the category
Collection of arrows of the category
Composition of b → c with a → b
Reﬂexive arrow for x
Unit function of the category;
Collection of isomorphisms for a, b
Functor
Object function of the functor F
Arrow function of the functor F
Category of cateories as c-objects and functors as arrows
Identity functor for C
Identity functor for Cat
Collection of functors
Collection of functors for subcategories
Collection of all isomorphisms C → D
Opposite category
Opposite arrow of f
Opposite functor of F : C → D
Functor that sends a categories and functors to their opposite
Contravariant functor
Product functor of common domain
Product functor of common range
Left-right operation function
Bifunctor
Bridge or natural transformation
Discrete number system
Discrete number system with transitive arrows
Discrete number system with transitive and reﬂexive arrows

CONTENTS
{+x}≤
Z†
Z
N0
N
N†
N†
a
b
Q
Obj
Obj∈
U
V
R
Set
A, B, ..., X, Y, ...
∅
x ∈ A
(cid:60)
A = {x}x∈A
A ⊆ B
A ⊂ B
A = B
X, Y,...

(cid:83)X or (cid:83)
(cid:84)X or (cid:84)

A ∪ B

A∈X

A

A

A∈X

A ∩ B
A − B
Ac
PA
A, B, ...
PA
Set⊆
PA
f [[X]]
f −1[[Y]]
( f x) ∈ f A
( f −1B) ∈ f −1[[Y]]
f −1{z}
f −1[z],
{{A}} or {{x}}x∈A
f|Im f
ι f
E f

13

Order of automorphisms +x, for Z≤
Group of automorphisms +x : Z≤ → Z≤
Integer number system
System of natural numbers
System of natural numbers, without the object of operation 0
A partial order N × {c}, isomorphic to N
A partial order N × {c}, dual to N
Arrow a →× b, of the collection N0 →× N or −N0 →× N
Rational number system
Collection of all objects
System of all objects and of arrows x ∈ A
Universe of sets; subcollection of Obj
Add the object U to the collection U
Collection of all normal objects
Category of small sets; arrows are functions
Set
Empty set
x is an element of the set A
Not an element of
Set A is represesnted as,
Set A is a subset of set B
Set A is a subset of set B, but they are not the same object
Set A is subset of set B, and B is subset of A
Family of sets
Union of all sets in the family
Union of sets A and B
Intersection of all sets in the family
Intersection of sets A and B
Diﬀerence of set A and B
Complement of set A
Set of all subsets of set A
Collection/set category
Set category of the set PA
Category of small sets; ordered under inclusion
Power category of A; ordered under inclusion
Image of family X
Inverse image of family Y
Object in the image of A; there is x ∈ A such that ( f x) = f x
Object in the family f −1[[Y]]; there is B ∈ Y such that ( f −1B) = f −1B
Fiber of object z
Family of singletons of A
Function onto the image
Inmersion of image into range
Image equivalence of f

14

CONTENTS

f /E f
Dom f /E f
p f
n
I
s, t, ..., (xi)i, (yn)n, ...
(xi)n
ON
i=1
On
S, T, ...
Λn+1
i=1
Λn
i=1(xi)i
Λ
ΛO
Λi∈Nxi or Λ∞

i=1xi

i=1

n(cid:80)
∞(cid:80)
n(cid:81)
∞(cid:81)

i=1

i=1

xi

xi

xi

xi

i=1
Φ
φ
φ(xi)i or (φi)i
(σi)i
(πi)i
an
(⊕xi)i
(cid:13)
f n

Bijective function, f module E f
Inverse image of the family {{Im f}}
Projection into ﬁber
All numbers x ∈ N such that 1 ≤ x ≤ n
Index set
Sequence
Finite sequence
Collection of all sequence of objects in O
Collection of all ﬁnite sequence of the form n → O
Order preserving functor N → N
Finite operator; function that sends (xi)i into Λn
Finite operator applied to the sequence (xi)i
General operator; sequence of functions Λn
j=1
Union of the family that consists of the image of every ﬁnite operator
Series of (xi)i, under a general operation ⊕

Partial sum; image of (xi)i, under the ﬁnite operator(cid:80)n
Series for operation +; image of (xi)i under the function(cid:80) N
Partial product; image of (xi)i, under the ﬁnite operator(cid:81)n
Series for operation ·; image of (xi)i under the function(cid:81) N

j=1(xi)i ⊕ xn+1

j=1

j=1

Sequence of functions
Sequence function associated to the sequence of functions Φ
Sequence of partial operations for (xi)i; every φn is Λn
j=1(xi)i
Sequence of partial sums for some sequence (xi)i
Sequence of partial products for some sequence (xi)i
Partial product for the constant sequence (a)i
Sequence of right operations for (xi)i and ⊕
General operator for composition
Composition of the sequence ( f )i

Systems

A system is a collection of objects and a collection of relations. When considering a system, it will be
decided, for any concept that makes appearence, whether it be an object or a description. We can form
collections of systems, just as we can with any other type of object. Relations are those components
of the system that come in the form of assertions about the system, objects of the system, and other
systems. All relations refer to, at least, the system or objects of the system. Additionally, it is required
that every object appear in at least one relation. Therefore, if a certain relation is an object of the
system, we are saying it is the object of some relation regarding it. This is kept in mind, when category
is deﬁned as a system.

Generating New Systems

Taking/Adding Objects/Relations

We will now discuss the concept of making new system(s), from given system(s). Suppose you have
a system S, then the only actions permitted in the forming of new systems are 1) Taking objects or
relations from a given system 2) Adding objects or relations to a given system. We will give a restriction
for taking or adding objects or relations: no object can be left without a relation. A collection is called
a subcollection of another, if it has been obtained by taking objects/relations from the other.
If S(cid:48) is obtained from S by adding only relations, we will say S(cid:48) is a detailed version of S. Consider
any object x that has any relation in Sys, with some object of S(cid:48). Then the system S(cid:48)(cid:48) formed by adding
the object x and any collection of relations, that mention x or an object of S(cid:48), is a complication of S(cid:48).
We will say that S(cid:48) is a simpliﬁed version of S(cid:48)(cid:48).
Axiom 1. We will suppose the existence of one system, Sys. It is deﬁned by one relation: All system S
is obtained by taking objects or arrows from Sys.

Another way of stating this axiom is that every thing is an object of Sys; in particular, every system

is an object of it. Consequently, Sys is an object of Sys.
Axiom 2. Given any object X, in a system S, we can form the new system SX, whose (only) object is X
and whose relations are the relations of S, pertaining to X. For every system, there is a system SysX.
The twin system of Sys, is the empty set, denoted by ∅, and constructed from Sys by taking away
all objects and all relations. Any system can be obtained from ∅ by adding objects or relations. The
emptyset is a thing in Sys; the thing that consists of nothing.

15

16

CHAPTER I. SYSTEMS

Separating and Combining Subsystems

When studying a system, we can decide it convenient to see which objects are not related amongst
themselves, in any chosen manner. To be more explicit, consider S to be such that its objects can be
distinguished as two kinds a, b, c, ..; x, y, z, ... and suppose there is not a single relation in S for which
one of each kind of object is present. We consider two, evident, simpliﬁed versions of S.
Let us now consider the case in which we may want to separate S into two systems, but there is
no guarantee as too whether we can diﬀerentiate objects as before (there may be relations, in S, that
involve objects of both collections). We will form the two simpliﬁcations by deﬁning the two kinds of
objects. Relations will be two kinds also: the one kind of relations are those that do not refer to the
second kind of object, and the second kinds of relation are those that do not refer to the ﬁrst kind of
object. In this case we have a separation that loses information. We accomplish a separation that does
not lose information by deﬁning the ﬁrst kind of relations to be those referring to objects of the ﬁrst
kind, and the second kind of relations are deﬁned as those that mention the second kind of objects.

Relations and Objects

A relation is a collection of statements referring to systems and objects. If all the statements of a relation
can be obtained by changing the objects (subjects of the statement) in one statement, the statements are
components of the relation. Arrows will be used to represent relations; a collection of arrows can be
the simplﬁed form for certain relations. The main idea behind the use of an arrow is to distinguish two
objects, in a given scenario. Thus, a → b means ﬁrst is a, second is b. The object to the left of the arrow
is the source object and the one to the right is the target object. We can represent an arrow by saying
f : a → b. It is reasonable that for some relations, the collection of arrows is discernible. This means,
that there can be more than one arrow between two objects. A pair of arrows is parallel if they have the
same source and same target object. For objects a, b in C, deﬁne {a → b} as the collection of all arrows
with a as source and b as target. We also deﬁne {a →} as the collection of arrows with a as source and
{→ b} as the collection that has b in the target.

Binary relations are those such that every statement refers to only two objects a, b. An ordered
pair relation is any relation whose components are arrows between two objects of the system, and two
components are the same if they have the same objects in the same position with respect to the arrow.
This last means that the arrows are non-discernible (parallel arrows are the same arrow).
An ordered pair relation is said to be reﬂexive if for every object a of the system we have the
component a → a; these arrows will be called reﬂexive. In case there are no reﬂexive arrows, the
relation is irre f lexive. It will be called symmetrical if all arrows are double ended; for every arrow
a → b we have the arrow b → a. The relation is anti-symmetric if given any choice of distinct objects
a, b there is at most one arrow between them (only reﬂexive arrows are allowed to be double ended).
Suppose for every every pair of components a → b and b → c the component a → c exists in the
collection of statements, then the relation will be called transitive. If there is an arrow a → b or b → a,
we will say a, b are →-comparable. We say that a relation is trivial if all the arrows are reﬂexive.

Throughout mathematics we will also use the equivalence relation, amongst others, with great
frequency. It is desireable to regard certain objects as the same with respect to certain criteria. We
can determine objects by the relations it has in other systems that are not Sys. We wish to say when
two systems are the same, in a lesser sense. An ordered pair relation is called an equivalence relation if
it is reﬂexive, symmetric and transitive.

2. RELATIONS AND OBJECTS

Equivalence

17

The collection O1 →× O2 deﬁned in terms of the collections O1,O2 will be called the cartesian product
and it consists of all arrows a →× b, where a, b are in O1,O2, respectively. Given a collection O, we
immediately get an equivalence relation O →× O. Such equivalence relations are called simple.

Take an object x of an equivalence relation and let X be the collection of objects of the equivalence
that are comparable with x. We can carry out a separation of the equivalence, so as to consider a system
that, for convenience, is also denoted by X. When giving the separation, into the collection X, it does
not matter if you carry out the separation that loses information, or the separation that does not lose
information. We invariably get a separation that does not lose information and is one of the reasons
that simple equivalence relations are so important. For objects x, y in X, we shall verify that the system
Y, correspoding to y, this is the same system as X. Let a be an object of X then we can suppose the
existence of an arrow a → x because of symmetry. This together with the existence of an arrow x → y
imply the existence of an arrow a → y which means a is an object of Y. A similar argument can be
given to verify that all objects of Y also belong to X. Therefore, the systems X, Y are the same because
they both consist of the same objects and both consist of all arrows amongst these objects.

Order

A preorder is a reﬂexive and transitive ordered pair relation. A preorder that is anti-symmetric will be
called partial order. Not all the objects are ordered amongst each other and when there is an arrow
amongst two objects x, y we say they are order comparable, for example the arrow x ≤ y. If an arrow
for an order is not reﬂexive we may express x < y. Arrows ≤ may be called inequalities, while an arrow
< is a strict inequailty. Anti-symmetry holds if x ≤ y and y ≤ x, imply x = y. An object M of a partial
order is said to be maximal if for every x in the partial order such that M ≤ x, we have x = M. We say
that an object m is minimal if x ≤ m implies x = m. Maximality of M means that it appears as source
object in one arrow only, the reﬂexive arrow. Of course, minimality means m appears as target, only in
the reﬂexive arrow.

A natural order is a transitive binary relation, in which every object of the collection appears in
exactly one arrow with every other object. We can see that a natural order is a partial order, however
not all partial orders are necesarilly natural. Of course, given a collection of partial orders, the system
formed by including all the objects of all the orders with their respective arrows, is again a partial order.
Proposition 2.1. Given a partial order P, and a subcollection of it, we can specify a simpliﬁed version
of P, that is itself a partial order on the objects of the subcollection.

Informally, the axiomatic base for numbers is given by 1) an object exists, 2) there is one arrow on

each side of every object, and 3) an order relation is given.

Axiom 3. We suppose the existence of a system such that

1) The system is non-empty.

2) Every object is source of exactly one arrow and target of exactly one arrow.

3) The relations of the system are components of a non-trivial natural order.

18

CHAPTER I. SYSTEMS

We are able to ask that 2) holds because we know we can take arrows away to form a new system
and we are not breaching our only rule: no object is left without a relation (arrow).
We have objects 0 and 1, such that 0 → 1. We are unable to apply 2) to conlcude 1 → 0, so we
have −1 → 0 → 1, for some object −1 that is not 0, 1. We are now unable to say 1 → −1, because
transitivity would lead to a contradiction with the fact that the order is irreﬂexive. We now know there
are objects −2, 2 such that −2 → −1 → 0 → 1 → 2. We continue construction in this manner and call
such a system a discrete number system.

Comparability

It is desireable to have relations amongst relations themselves. Some orders arise in the form of relations
amongst relations, as will be seen in building rational systems. Consider systems S1,S2, with respective
arrows →1 and →2 in the systems. Suppose we have formed a system whose objects are the arrows of
S1,S2. For an ordered pair relation, with a component being an arrow of the form a →1 c −→ b →2 d
or a →2 c −→ b →1 d, we will express a, c; b, d. We will in such cases say a, c and b, d are comparable.
This kind of comparability will give us some operations and it will allow many constructions for ﬁnding
the integers and rationals and it will also arise in categories, where we deﬁne functors and natural
transformations in terms of comparability properties.

Function
Deﬁnition Consider a system f with two kinds of objects. The ﬁrst collection of objects called
the domain and the second kind will be called range; unless a more convenient notation is taken up in
particular cases, these will be represented by Dom f and Range f , respectively. If the system has an
ordered pair relation such that the collection of target objects is a subcollection of Range f and any
source object appears to the left of exactly one arrow, we will say the system is a function from Dom f
into Range f . This will be expressed by f : Dom f → Range f . For the most part, except in cases
where this is not convenient, the components of a function f will be denoted by a (cid:55)→ f
f a or
a; f a, f . We can, in place of f a, write a f or f (a). If we are to consider two functions f, g : O1 → O2,
such that f a and gb are the same object, we will write a, g; b, f . It will be common to name functions by
f, g : Dom f, Dom g → Range f, Range g, meaning f : Dom f → Range f and g : Dom g → Range g.

f a or a → f

Image The collection of all objects that appear to the right of an arrow is represented by Im f . Let
f : O1 → O2, and for any subcollection Q2 of O2, we will write f −1Q2 to represent the subcollection of
objects x in O1, such that f x is in Q2. This collection is the preimage of Q2. We say fQ1 is the image of
Q1, and it is deﬁned as the collection of objects f x in O2, for every x in Q1. If there exists the possibility
of confusion, the image and preimage will be written as f [Q1] and f −1[Q2].

Classiﬁcations If the function is such that all the objects of Im f appear in exactly one relation,
it will be called monic. If every object in Range f appears in at least one relation, then it will be said
the function is from Dom f onto Range f , or if all else is clear from the context, we will simply say
f is onto. If every object in Range f appears in exactly one arrow, the function is monic and onto; the
function is said to be bijective.

2. RELATIONS AND OBJECTS

19

One would think that we are able to restrict the function to a certain subcollection, in the Im f and
obtain a function that is onto. Also, we expect to restrict Dom f in such a way that we obtain a monic
function. These two instances will be studied and used.

Composition Given two functions f, g : O1,O2 → O2,O3, we form g ◦ f

: Q1 → O3, where
a (cid:55)→g◦ f c if there exists an object b in O2 such that a (cid:55)→ f b (cid:55)→g c. This is a principal of transitivity
because we are assigning an arrow from a to c, given there are arrows from a to b and from b to c. Any
function g ◦ f will be called a composition. The composition is associative:

f ; f (g ◦ h)a, (g ◦ h)a
f ; f (g(ha)), (g ◦ h)a
f ; ( f ◦ g)(ha), (g ◦ h)a
f ; (( f ◦ g) ◦ h)a, (g ◦ h)a

Inverse and Unit Let I : O → O such that x (cid:55)→I x; this function will be denoted by IO and if
no confusion is possible we simply write I. Given a bijective function f : O1 → O2, we will say the
function f −1 : O2 → O1 is inverse of f , if f −1 ◦ f and IO1 are the same function.
Proposition 2.2. Let f be a bijective function and f −1 an inverse of f . Then f ◦ f −1 is the function IO2.
The function f −1 : O2 → O1, that is obtained by reversing all arrows of f , is an inverse of f . The
deﬁnition of equality, in the next paragraph, makes f −1 unique.
Proof. We know that for every object in O1, we have x (cid:55)→ f
is the function that sends f x (cid:55)→ f −1 x because we have x (cid:55)→ f

Now, let f −1 be the function obtained by reversing all arrows of f . If x is an object in O1, then f −1

f x (cid:55)→ f −1 x, so that ( f −1 ◦ f )x is x.

f x.

The inverse of a composition g ◦ f : O1 → O3 is f −1 ◦ g−1 : O3 → O1. This is easily ﬁgured out by

observing the bijectivity of f, g and f −1, g−1.

Two Part Function and the Meaning of Equality for Functions Our ﬁrst equivalence relation is
stated so as to determine an equality criteria for functions. Two functions will be the same if they both
have the same domain, range, and components. If a function can be seperated into two systems fA and
fB, without losing information, we say f is a two part function fA, fB. We shall say A,B are the objects
of the ﬁrst and second kind given by the separation; notice that each of these collections consists of
objects in the domain and range. We are considering simpliﬁed versions of the function f . This is done
by taking away arrows and objects in the domain, in such a way that the new system is also a function.
If f : O1 → O2 and Q1 is the subcollection of O1 considered, then f|Q1 : Q1 → O2 is called the
restriction of f to Q1. Notice that we are carrying out the construction of a simpliﬁed version of f . If f
is monic, then any restricted function of f is also monic. A similar remark does not hold if f is onto. A
function ι is called an inmersion if Dom ι ⊆ Range ι and x (cid:55)→ι x. Of course, the identity function I is
the special case of ι, when equality holds. Also, if we restrict I to a subcollection of its domain, then it
becomes an inmersion into its own domain.

20

CHAPTER I. SYSTEMS

Selection Function In this section, we give an axiom that allows us to identify any object with a
reﬂexive arrow. We are looking for a simple way of characterizing the selection of an object, amongst
all others in some collection O. A function {x} → Range f , where the domain consists of one object,
is called selection function. For any x in O, we have the selection function ιx : {x} → O that is an

inmersion. Let X represent a collection of collections and write(cid:83)X for the collection of objects that
belong to some O in X. A selection function for X is a function Sel : X →(cid:83)X such that SelO ∈ O.

Axiom of Choice. Given a non-empty family of functions X, there exists a selection function.

We are stating that objects can be chosen one by one, from arbitrary families. This axiom will take
another interesting form, in a later chapter. There, we will discuss the axiom of choice in a slightly
diﬀerent context. We will be able to choose elements from partial orders.

Order Preserving Function and Galois Connections [VIII] There are certain functions from an
order into another, that can transform the objects in such a manner that the function suits the orders
well. We can say that the function recognizes the order of both. Let P and Q be two partial orders
where arows are ≤ and (cid:22), respectively.
Deﬁnition 1. A function P → Q deﬁned on the objects of these categories is said to preserve the order
if for every arrow a ≤ b we also have f a (cid:22) f b; if instead of this, we have f b (cid:22) f a, then the function is
said to be order reversing.
We say an order preserving function is an order embedding if for every f a (cid:22) f b we have a ≤ b. An

order embedding that is onto, is called order bijectivity.

It is easy to see an order bijectivity is indeed a bijective function. For this, we only need to verify
that every order embedding is monic. To prove this, take a, b in P such that f a = f b, and verify a = b.
The opposite of a partial order is denoted by Pop and it is deﬁned as the system whose objects are
those from P and whose arrows are the reversed arrows of P. It will be seen that there is not always an
order bijectivity for a partial order and its opposite. When it does exist, we say P is self dual.
When there is an order bijectivity P → Q we write P,Q;Pop,Qop. If there is an order bijectivity
into the opposite of Q, then we say P and Q are dual orders and we represent this with P,Qop;Pop,Q.
Notice that self dualtiy is expressed as P,Pop;Pop,P.
We shall address the issue of whether there exists an order bijectivity Pop → Qop given there is an
order bijectivity P → Q. Let f : P → Q be an order bijectivity, we wish to prove that f is also an order
bijectivity Pop → Qop. We know x ≤op y if and only if y ≤ x which is true if and only if f y (cid:22) f x and
this holds if and only if f x (cid:22)op f y.
If we consider an order bijectivity f : P → Q, and its inverse f −1, we have two order preserving
functions; one from P to Q and the other from Q to P. There is a similar situation with more generality
than this last example. Let f, g : P,Q → Q,P. We will ask that f, g are order preserving but we will
also ask that the compositions be order preserving, in a diﬀerent sense. This last condition is a less
restrictive condition than the situation with f, f −1 in which we have f f −1q = q and f −1 f p = p.
Deﬁnition 2. A pair of functions f, g, as mentioned above, is called a Galois connection if 1) f, g are
order preserving, and 2) for every object p in P and q in Q we have p ≤ g f p and f gq ≤ q.

Here is a characterization of Galois connections. Suppose that the functions f, g : P,Q → Q,P are
such that for every p, q in P,Q we have f p ≤ q if and only if p ≤ gq. We will sometimes say f, g are
comparable functions and we will write f ; g instead of using the notation for arrows P,Q;Q,P.

2. RELATIONS AND OBJECTS

21

Proposition 2.3. A pair of functions is a Galois connection if and only if it is comparable.
Proof. Suppose the pair f, g is comparable. For p, we know that f p ≤ f p and this implies p ≤ g f p.
We can similarly prove this for q in Q and that proves 2). Now, we shall prove f, g are order preserving.
Take p, r, both in P, such that p ≤ r ≤ g f r. This is equivalent to stating that f p ≤ f r. If f gr ≤ r ≤ q
are in Q, we have gr ≤ gq.
Now, suppose f, g is a Galois connection. If we suppose f p ≤ q, then p ≤ g f p ≤ gq. Let p ≤ gq,
then f p ≤ f gq ≤ q.

: Q1 → Q2 such that x ∗ a (cid:55)→F f

Natural Pair of Functions Let ∗a : O1 → Q1 and ∗b : O2 → Q2 be onto functions. Consider
the collection O of all functions of the form O1 → O2. Let y in Q1 and f a function in O, then we
have x in O1 such that x (cid:55)→∗a y. Deﬁne F f
f x ∗ b; this simply
means f x,F f ; x ∗ a,∗b. The situation described here is of great importance. If we have functions
F, G : O1,Q1 → O2,Q2, then we would like to know when it is possible to give functions ∗a : O1 → Q1
and ∗b : O2 → Q2 that will allow us to describe the actions of applying G, in terms of the functions ∗b
and F. That is, we are giving a function F and we also give rules for transforming the domain and range
of F (that is the role of ∗a and ∗b respectively), so as to generate a new function G that is deﬁned for
the transformed domain and range. The way this function G works is by sending objects ∗a(x) in the
transfromed image, into the object that results from transforming the orginal object, ﬁrst under F, and
then under ∗b. Explicitly we have Fx, G; x ∗ a,∗b. We will say that F, G are a natural pair of functions,
under ∗a and ∗b and this will be expressed by F, G;∗a,∗b.

Operation

Sometimes it will be convenient to use the collection {O1 → O2} of all functions from O1 into O2;
we will use the notation {O1 fO2}. However, in the deﬁnition of operation, this collection is not large
enough to be useful. Let O1 fO2 represent the collection of all functions of the form Q1 → Q2, where
Q1,Q2 are any subcollections of O1,O2, respectively.
An operation is a function ∗ : O → O1 fO2. We say the objects in O are the actions of the operation.
The image of a in O, under ∗, is a function a∗ called left operation. The image of x in O1, under a∗ is
a∗ x and we express a; a∗ x, x instead of the function notation x; a∗(x), a∗. Just as we have characterized
the operation in terms of functions associated to the objects of O, we can also determine a function in
terms of functions associated to the objects of O1. Let x be any object in O1; we wish to build a general
function ∗x. An object is in the domain of ∗x if and only if there exists an object a, in O, such that a ∗ x
is deﬁned, i.e., x is in the domain of a∗. We deﬁne the transformation as a (cid:55)→∗x a∗ (x); this is expressed
with a; a ∗ x, x instead of the function notation a;∗x(a),∗x. the objects of O1,O2 are called origin and
target objects, respectively. An operation ∗ is full if ∗ : O → {O1 fO2}. This means O1 is the domain of
every left operation. Equivalently, an operation is complete if the domain of every right operation is O.
We will frequently encounter functions of the form ∗ : O1 → O1 fO2; we call them operation from
O1 to O2. For this kind of operation, we can deﬁne the concept of commutativity. We say x in O1
commutes if ∗x, x∗ are the same function. We say ∗ commutes if every action (and thus target) object
x commutes. Other times we will consider operations ∗ : O1 → O2 fO2 and we say the objects of O1
are actions for O2. If the objects for O1 are actions for O2. Suppose we have such an operation, and
suppose there exists an action object e such that e∗ is the identity operation for O2; we say e is a left
unit of *. If ∗ : O1 → O2 fO1, and ∗e is IO1, for some e in O2, we say e is a right unit. We can speak of
a unit if ∗ : O → O fO and there is an object e that commutes; e is a unit if the left/right operations are

22

CHAPTER I. SYSTEMS

the identity function. When there is a unit, two objects can be related in a special manner and we say
x−1 is right inverse of x if x; e, x−1. We are justiﬁed in saying x is left inverse of x−1.
Form the system whose weak arrows are the arrows of the right operation functions ∗x, for every
x in O. Two weak arrows a →∗x c and b →∗y d will be related if c and d are the same object; in such
case a, y; b, x will be expressed instead of a, c; b, d. This relation is an equivalence relation so we can
equally say b, x; a, y. We choose to do this because in terms of the notation for functions we can express
a,∗y; b,∗x or b,∗x; a,∗y. Two objects x, y commute if x, x; y, y.
If ∗ : O → {O fO}, then the composition is deﬁned for the functions which are left/right operations.
We want to deﬁne an operation ◦ such that the actions, source, and target objects are the left and right
operations of ∗. The operation in question is ◦ : {O fO} → {O fO} f{O fO}, where ◦ is composition of
functions. We will say the operation is associative if x∗, x∗;∗y,∗y, for every choice of obects x, y. This
means that x ∗ ◦∗ y is the same function as ∗y ◦ x∗; the functions x∗ and ∗y commute. Associativity can
also be seen as a transitive property regarding the operation, for the following reason. We have assigned
a →y∗◦∗x c to any arrows a →y∗ b →∗x c. In terms of the objects and the original operation, associativity
is expressed by a, c; a∗ b, b∗ c, for every objects a, b, c. This last form of writing the associativity gives
intuition for why we say it is a transitive principle: on one side we have a, c, while on the other we have
a, b and b, c, in that order. In conclusion, ∗ is associative if for every pair x, y of objects, x∗ is a natural
pair of functions with itself, under ∗y, ∗y. Or, we can say ∗y is a natural pair with itself under x∗, x∗.
: O → O and ∗ : O → O fO if
f, f ;∗ f x,∗x, for every x; put diﬀerently, f ◦ ∗x is the same function as ∗ f x ◦ f . Given two operations
⊕ : O1 → {O1 fO1} and ∗ : O2 → {O1 fO1}, we say ∗ distributes over ⊕ on the left if for all b in O1
and all x in O2 we have x∗, x∗;⊕(x ∗ b),⊕b. Another way of saying this is all the left operations of ∗
commute with ⊕. If ∗ : O1 → {O2 fO1} and instead we verify the above with ∗x,∗x;⊕(b ∗ x),⊕b then
we say ∗ distributes on the right. Distribution on the left can be written as x; (x ∗ a) ⊕ (x ∗ b), a ⊕ b and
distribution on the right is a ⊕ b; (a ∗ x) ⊕ (b ∗ x), x.
Suppose we have a full operation ∗ : O → {O1 fO2}. Propose a function ∗ : (O1 →× O) −→ O2
which is called a binary operation. Let a →× x be an object in O1 →× O. We deﬁne ∗(a →× x) := a∗ x.
Let us consider the construction of the operation, provided we have a binary operation. We wish to give
a function ∗x for every object in O; this function must send objects of O1 into O2. The components
of the function are a →∗x ∗(a →× x). Given a function ((O2 →× O1) →× O) −→ O3, there is an
operation O → {(O2 →× O1) fO3}. Every function in the image can be turned into an operation of the
form O1 → {O2 fO3}. It is then possible to build an operation O → {O1 f{O2 fO3}}.

An operation and a function can commute. This happens for f

Category

Here, we will treat objects and arrows as two diﬀerent kinds of objects. The relations in a category are
not the arrows. The relations, in this deﬁnition of category, are statements about arrows and objects. It
will be clear, from the deﬁnition, that a category is indeed a system whose objects consist of relations
also. This is important to consider an environment where a functor is to be treated as a function.

A collection of arrows is said to have the reﬂexive property if for all object x there exists at least one
reﬂexive arrow. It will be said that the collection of arrows has the transitive property if the composition
for the arrows (adequately seen as functions) deﬁnes an operation ∗ : A|C → A(cid:107)C fA|C. Clearly, the
composition is not always a full operation. A collection of arrows that satisﬁes the last two properties,
for all objects of some collection O, will be called a collection of order arrows for O.
Deﬁnition 3. A category is a system with objects of two kinds; the one kind are called c-objects, while
the other kind is a collection of order arrows, for the collection of c-objects. Additionally, for any choice
of c-objects x, y, and arrows f : a → x and g : b → y, there is a reﬂexive arrow 1b, 1x such that

and

g; g, 1b

1) 1x; f, f
2) g∗, g∗;∗ f,∗ f
The two kinds of objects are represented by O|C,A|C, respectively. In 2) we are stating that for every
h : x → b, the arrows g∗ (h∗ f ) and (g∗ h)∗ f are the same. All we are saying is that both, the collection
of arrows and the operation for the arrows, satisfy their own reﬂexive and transitive properties.

Associativity

Unit

Arrows

Deﬁning Equality of Arrows

Given two arrows we need to provide a deﬁnition of equality between them. That is, we will establish
an equivalence relation for arrows of any given category. Since categories may have arrows that are
discernible, an arrow is not necessarily determined by the objects and the position with respect to the
arrow, as is the case with non-discernible arrows.
Deﬁnition 4. Two arrows f, g : x → b, of the same category, are the same arrow if for every arrow
h : a → x and i : b → y we verify f, h; g, h and i, g; i, f .

What this means is that an arrow is deﬁned to be the same as another in terms of the result of the
operation ∗. We say f, g are the same when f ∗ h is the same as g ∗ h and i ∗ f is the same as i ∗ g, for
every h, i composable with f, g.

23

24

CHAPTER II. CATEGORY

It remains to be proven that this is indeed an equivalence relation, deﬁned on the arrows of the
category. Reﬂexivity is trivially veriﬁed. Symmetry is not hard to prove; we know g, h; f, h is a notation
to replace f, h; g, h and i, f ; i, g replaces i, g; i, f . Suppose e is the same as f and f is the same as g.
Since e, h; f, h and f, h; g, h we can say that e, h; g, h. Similarly, one ﬁnds i, g; i, e.

Classifying Arrows [I]
Invertible Deﬁning types of arrows is important for classifying functions, and more generally,
: a → b is invertible if there exists f −1 : b → a such that f −1 ∗ f and
functors. We say that f
f ∗ f −1 are 1a and 1b, respectively. If there is an invertible arrow between two objects, we say they are
isomorphic. So, we say an arrow that makes two object isomorphic, is an isomorphism. The collection
of isomorphisms from for any pair of objects is represented as {a →iso b}.
Proposition 3.1. The relation of isomorphism, is an equivalence relation on the objects of the category.

Proof. First, we know that any object a, of the category, is isomorphic to itself because 1a is invertible
is invertible, then so is f −1. Now, let a, b be
and 1a; 1a, 1a. By deﬁnition, symmetry holds; if f
isomorphic with f and b, c isomorphic with g. Consider the arrow f −1 ∗ g−1, and it is easy to verify
g ∗ f ; 1c, f −1 ∗ g−1 and f −1 ∗ g−1; 1a, g ∗ f .

Say f −1 and g both make f invertible, we shall prove they are the same arrow. We know they are
both functions of the form b → a, so now it must be shown that the operations coincide. Let h be an
arrow composable with f −1, g.

g ; g ∗ h, h
g ; 1a ∗ (g ∗ h), h
(1a ∗ g) ∗ h, h
g ;
[( f −1 ∗ f ) ∗ g] ∗ h, h
g ;
[ f −1 ∗ ( f ∗ g)] ∗ h, h
g ;
[ f −1 ∗ 1b] ∗ h, h
g ;
f −1 ∗ h, h
g ;
f −1, h
g, h ;

With this we prove that f −1, g have the same left operation for composition. We can just as easily

show that they have the same right operation.
Proposition 3.2. The inverse of an invertible arrow is unique.

Left and Right Inverse If two discernible arrows have the same source and target, we say they are
parallel. An arrow f : x → b is left cancellable if for every pair of parallel arrows g, h : a → x, the
expression f, g; f, h implies 1x, g; 1x, h. Suppose for every g, h : b → y, the expression g, f ; h, f implies
g, 1b; h, 1b. Then we say f is right cancellable.
If there is an arrow l : b → a such that l ∗ f is 1a, we say f has left inverse. In a similar manner, f
has right inverse if there is r : b → a such that f ; 1b, r.
Proposition 3.3. If f has left inverse, then it is left cancellable because we can apply f −1 to f, g; f, h.
An arrow with right inverse is right cancellable.

4. SOME CATEGORIES

25

Now we give a result that characterizes monic functions as functions with left inverse. It will later

be proven that onto functions are characterized as functions with right inverse.

Lemma I. A function has left inverse if and only if it is monic.
Proof. If the function has left inverse, and a, b are diﬀerent objects, then (l ◦ f )a and (l ◦ f )b are also
diﬀerent. Therefore, f a and f b must be diﬀerent, so that l is a function. This means f is monic.
Suppose f is monic; we will give l : Range f → Dom f such that a; a, l ◦ f . Take y in the image of
f so that x; y, f for some x in the domain. We deﬁne y; x, l. If, however, y is not in the image, we can
take any a in the domain and deﬁne y; a, l. The reader can prove this is a left inverse.

Lemma II. A function has right inverse if and only if it is onto.
Proof. Let f be a function with right inverse r : Range f → Dom f . This means that for every y in the
range of f , we verify y; y, f ◦ r. It is tue that f is onto because to every y, in the range, we assign an
object, in the domain, whose image, under f , is y.
If the function is onto, every element of the range has non-empty inverse image. Let f −1[[{{Im f}}]]
represent the collection of inverse images, of objects in the range; this notation will later be justiﬁed
when we study set functions. We are giving a collection whose objects are f −1[{y}], where {y} can be
any collection of one object, in Range f . There is a selection function S : f −1[[{{Im f}}]] → Dom f , for
the family f −1[[{{Im f}}]]. Let T : Range f → f −1[[{{Im f}}]] be the function that sends y (cid:55)→T f −1[{y}].
It is now necessary to verify that S ◦ T acts as right inverse of f .
Theorem 3.4. A function has inverse if and only if it is bijective.

uodate nexr appt send miles cb

Some Categories

We see that a category is an eﬃcient way of describing partial orders, collections of functions, and
operations. These descriptions are given in the present section.

Partial Order

A partial order can be seen as a category. We shall prove that the objects and relations of a partial order
deﬁne c-objects and arrows of an order category. The relations of the partial order are a collection
of order arrows for the objects because the order is reﬂexive and transitive. Anti-symmetry means
there is at most one relation for two objects. The reﬂexive arrow is the unit and we now only need to
verify associativity for the order relations. We see that the operation for two relations b ≤ c ∗ a ≤ b,
results in a ≤ c; recall that this operation works as composition for functions. It is therefore clear that
associativity holds, since we get the same result from c ≤ d ∗ (b ≤ c∗ a ≤ b) and (c ≤ d ∗ b ≤ c)∗ a ≤ b.

Algebraic Category

An important type of category is that which consists of domains and functions. That is, we consider
categories whose c-objects are collections and whose arrows are functions. When we study sets, we
will see that functions are arrows in the category of sets. For now, we study a particular case. Consider

26
CHAPTER II. CATEGORY
a system that consists of one c-object O and the arrows are functions O → O. We want to prove that
this system is a category. The collection of functions is a collection of order arrows for O because they
are distinguishable and we have deﬁned the function IO and composition for functions. The function
I acts as the unit. Associativity has already been proven for functions. When cosidering these types
of categories, we will usually consider the category {O fisoO} of bijective functions. Notice that this
category consists of one c-object and the arrows have inverse. We now move on to a type of category
that generalizes these categories of functions.
An algebraic category is a category C with one object in O|C; it consists of one c-object, e. In this
particular instance, the arrows, all of which are reﬂexive arrows of e, are called objects of operation.
Notice that the operation is full. We are using the concept of category to simplify our view of a system
that has an operation deﬁned. We have chosen a unit object for the operation, by choosing to have
one c-object. Our unit is clearly the arrow that appears in 1) of the deﬁnition to a category. Moreover,
we also represent this arrow with e. We may say that a system is an associative category if it satisﬁes
everything except 1) in the deﬁnition of category (there is no unit).

A group is an algebraic category such that its c-objects all have inverse to the unit. This form of

reasoning will also help build the integers with sum. For all objects of operation f, g, h, of a group,

1) f ; f, e
2) f ; e, f −1
3) g∗, g∗;∗ f,∗ f

or

g, f ; g ∗ h, h ∗ f

We will prove f −1; e, f and e; f, f also hold.

Re f. (Unit)

S ymm. (duality)

Trans. (Associativity),

f −1
f −1
f −1
f −1
f −1
f −1
f −1

f −1 ∗ f, f
( f −1 ∗ f ) ∗ e, f
( f −1 ∗ f ) ∗ [ f −1 ∗ ( f −1)−1], f
[( f −1 ∗ f ) ∗ f −1] ∗ ( f −1)−1, f
[ f −1 ∗ ( f ∗ f −1)] ∗ ( f −1)−1, f
f −1 ∗ ( f −1)−1, f

;
;
;
;
;
;
; e, f
e ; e ∗ f, f
e ;
e ;
e ;

( f ∗ f −1) ∗ f, f
f ∗ ( f −1 ∗ f ), f
f ∗ e, f

What is more, f and ( f −1)−1 are the same object.
f, e
f ∗ e, e
f ∗ [ f −1 ∗ ( f −1)−1], e
( f ∗ f −1) ∗ ( f −1)−1, e
( f −1)−1, e

;
;
;
;
;

f
f
f
f
f

5. FUNCTOR

27

One of the important properties of a group is that there always is a unique solution to f ; g, x, for x.

It is straightforward to verify that we have one solution to f ; g, x:
f ∗ ( f −1 ∗ g), f −1 ∗ g
( f −1 ∗ f ) · g, f −1 ∗ g

f
f
f

;
;
; g, f −1 ∗ g.

We use associativity to prove ∗ is left cancellable; this last means f is left cancellable, for every f

in the category that is not e. If f, g; f, h, then
f −1
;
f −1
;
; g, f ∗ h
f −1
f −1 ∗ f
; g, h
f −1 ∗ f, e ; g, h
e, e ; g, h
e, g ; e, h.

f −1 ∗ ( f ∗ g), f ∗ h
( f −1 ∗ f ) ∗ g, f ∗ h

Let us now suppose we have two solutions x1, x2. That is, f ; g, x1 and f ; g, x2. We may conclude
e, x1; e, x2 which means they are the same object of operation. An important consequence of this is that
the unit and inverse are unique. A similar exposition shows the only solutions to x; g, f is g ∗ f −1:

g ∗ f −1
g ∗ f −1
g ∗ f −1

(g ∗ f −1) ∗ f, f
;
; g ∗ ( f −1 ∗ f ), f
; g, f.

Also, given g, f ; h, f we have g, e; h, e. A group is said to be abelian if the operation is commutative.
Proposition 4.1. If ∗ is left cancellable and x is not a unit, then the left operation functions x∗ are
monic. If the operation is right cancellable, the right operation functions ∗x are onto.
Proof. Take a left operation f∗, and let g, h be objects of the category such that f, g; f, h which is true
if and only if f ∗ (h) is the same object as f ∗ (g). We know that e, g; e, h holds, so f∗ is monic.

A similar proof is valid for functions ∗ f , given ∗ is right cancellable.

Proposition 4.2. The left and right operation functions, for a group G, are invertible.
Proof. In a group, the inverse objects of operation commute. It is therefore clear that x ∗ ◦(x−1)∗ is the
same function as (x−1) ∗ ◦x∗.

Functor

At various points in our studies, we will come across a concept of generalized functions; we will
consider functions from a category into another. This means that we need to deﬁne a function on the
collection of objects of a category. It will be necessary to deﬁne two part functions for categories, so
that c-objects will be sent into c-objects, and arrows will be sent into arrows. In this section we discuss

28

CHAPTER II. CATEGORY

the concept of functor; a two part function between categories. There is an important aspect about the
functor, that will arise in the deﬁnition, and we mention it brieﬂy. When deﬁning a functor, we request
three conditions, for the two part function; natural pair of functions are behind each of these.
Let 1C be the unit function of C, deﬁned by x (cid:55)→1C 1x. The ﬁrst condition that a functor satisﬁes
means that we invariably obtain the same result by i) sending an object into its reﬂexive arrow and then
transforming the arrow, or ii) transforming the object ﬁrst, and associating the reﬂexive arrow second.
In short, F1x and 1Fx are the same object. The condition is expressed in terms of the notation for
composition of functions as operation.
A functor contains an arrow function and this arrow function will preserve arrows in the following,
intuitive sense. If f : a → b, then the functor will send f into an arrow from the transformed object of
a, into the transformed object of b. In other words, the arrow function sends arrows, to arrows between
corresponding objects. In condition 2) we will use the notation in terms of comparability, where weak
arrows are the arrows of C and D and strong arrows are the components of FA.

We will ﬁnally request that functors preserve the operation of arrows. This means that we will obtain
the same result after applying the functor to a composition of arrows, as we would from composing the
corresponding transformed arrows. This means that the notation is used in terms of the composition
operation for functions.
Deﬁnition 5. A functor F : C → D is a two part function FO, FA : O|C,A|C → O|D,A|D such that
for every arrow f : a → b, we have

1) 1D, 1C; FA, FO

Preserves Unit

2) a, b; FOa, FOb
3) FA, FA;∗FO f,∗ f
So, a functor is a function that preserves: 1) the unit property for the operation, 2) arrows amongst
The composition of a functor is a functor. Let F,G : C,D → D,E. We have 1D, 1C; FA, FO and

respective pairs of objects, and 3) the transitive property for the collection of arrows.
1E, 1D; GA, GO. Let G ◦ F be the two part function that consists of GO ◦ FO and GA ◦ FA.

Preserves Objects

Preserves Composition

1E
1E
1E
1E
1E
1E, 1C

(1E ◦ GO) ◦ FO, GO ◦ FO
;
(GA ◦ 1D) ◦ FO, GO ◦ FO
;
; GA ◦ (1D ◦ FO), GO ◦ FO
; GA ◦ (FA ◦ 1C), GO ◦ FO
(GA ◦ FA) ◦ 1C, GO ◦ FO
;
; GA ◦ FA, GO ◦ FO.

Next, we verify condition 2) is satisﬁed.

; G[F(a → b)], G ◦ F
; G(Fa → Fb), G ◦ F
; G(Fa) → G(Fb), G ◦ F
;

(G ◦ F)a → (G ◦ F)b, G ◦ F.

f
f
f
f

5. FUNCTOR

Finally, we see 3) holds:

(G ◦ F)(a ∗ b), G ◦ F

a ∗ b ;
a ∗ b ; G[F(a ∗ b)], G ◦ F
a ∗ b ; G[Fa ∗ Fb], G ◦ F
a ∗ b ;

(G ◦ F)a ∗ (G ◦ F)b, G ◦ F.

29

The following result establishes that functors send ismorphisms into isomorphisms.

Proposition 5.1. If F : C → D is a functor and f : a → b is an isomorphism in C, then F f is an
isomorphism in D.
Proof. The arrow f −1 : b → a has image F f −1 : Fb → Fa; we wish to show F f −1 and F f are inverse.

F f −1
F f −1
F f −1
F f −1

; F f −1 ∗ F f, F f
; F( f −1 ∗ f ), F f
; F1a, F f
; 1Fa, F f

Natural Pair of Functions in the Deﬁnition of Functor

We now study the role of natural pair of functions in the deﬁnition of functor. The concept appears in
very clear form when we give 1). In deﬁning a functor we consider two categories C and D. But, we
have also brought into play 1C : O|C → A|C. So, let FO and FA be the transformation of the domain
and image, respectively. We conlcude that in order for F to be a functor, 1C and 1D have to be a natural
pair of functions under the two simpliﬁed versions of F.
Given an arrow f : a → b in C, we will consider it to be a one component function. Also, the arrow
F f is a one component function Fa → Fb. In 2), we are stating that f is sent into some function F f ,
with which it is a natural pair of functions, under FO. That is, the one component function FO : a → b.
Now we consider that ∗ f and ∗F f transform A|C and A|D, respectively. The third statement in the
deﬁnition of functor states that F can be applied to an arrow, after applying ∗ f , or one can ﬁrst apply
F and then ∗Fa. Thus, we can restate 3) by saying FA is a natural pair with itself, under ∗ f and ∗F f .

Isomorphism

The purpose of this subsection is to show that we already have a criteria of isomorhpism deﬁned for
functors. We will also describe weaker forms of isomorphism that make sense, for functors.
Let Cat represent the system with all categories as objects, and functors as arrows. It is not diﬃcult
to see that functors are a collection of order arrows for categories. They are discernible arrows and
composition is well deﬁned. Consider the identity functor IC which acts as unit on objects and arrows of
the category C. We know Cat is associative because functions are associative. Since identity functions
act as unit under composition, so does the identity functor. This means that Cat is a category. The
functor ICat is an arrow of Cat; proving this is a functor is not diﬃcult.
Since we are dealing with a category, and functors are the arrows, it is oportune to mention that
{CFD} represents the collection of functors from C into D. As one may expect, we use CFD to
represent the collection of all functors from any subcategory of C into any subcategory of D.

30
CHAPTER II. CATEGORY
Deﬁnition 6. A functor F is an isomorphism between C and D if FO and FA are bijections. An
isomorphism from one category to itself is called an automorphism.

Following our conventions, we agree to use {CFisoD} in representation of the collection that consists
of all isomorphisms from C to D. From theorem 3.4 we know the isomorphism has inverse functions
F−1O and F−1A , to the object and arrow functions, respectively. We may now prove the following result.
Lemma. The deﬁnition of isomorphism between categories, coincides with the deﬁnition of isomorphic
arrows in the category Cat. That is to say, all isomorphisms are invertible arrows.
Theorem 5.2. The system of one c-object, C, and automorphisms, is a group.

Proof. We know that the composition of an isomorphism is again an isomorphism; the composition of
functors is a functor, and the composition of bijective functions is bijective. Also, IC is an isomorphism,
so that isomorphisms are a collection of order arrows for categories. Furthermore, the system of
categories and isomorphisms is a category because functions are associative.
The system of one c-object, C, and automorphisms for arrows, is indeed an algebraic category
because it consists of one c-object, namely C. It is a group because of the lemma.
Corollary. The collection of bijective functions {O fisoO} is the the group of transformations of X. If H
is a group such that the group of transformations is a detailed version of H, we say H is a group of
transformations of X.

Classiﬁcation of Other Functor Types

We have no guarantee that, given a, b in C and an arrow h : Fa → Fb in D, there is an arrow f : a → b
in C such that f ; h, F. When this is true for every a, b in C and arrow h : Fa → Fb, we say the functor
is full. It is faithful if for every f, g : a → b, the expression f, F; g, F implies f, IC; g, IC.
; we restrict the domain, of FA, to {a → b}, and then we retrict the
range of FA|{a→b} to its image, {Fa → Fb}. We are making the observation F{a → b} := {Fa → Fb}.
Proposition 5.3.

Consider the function FA|{Fa→Fb}

{a→b}

1) A functor F : C → D is full if and only if for every pair of objects a, b, in the domain category C,

the function FA|{Fa→Fb}

{a→b}

is onto.

2) A functor F : C → D is faithful if and only if for every pair of objects a, b, in the domain category

C, the function FA|{Fa→Fb}

{a→b}

is monic.

Of course, a functor that is full and faithful is not necessarily an isomorphism because we have no

knowledge regarding the object function FO.

Embedding An embedding is a faithful functor with monic object function. We have already
studied an instance of this, when we introduced order preserving functions. We have left clear that an
order embedding is a monic function. We make this the monic function of a functor P → Q. We need
to deﬁne the arrow function and this could not be easier. We already know that the arrows of a patial
order are non-discernible. Since a ≤ b if and only if f a ≤ f b, the arrow function is deﬁned.

5. FUNCTOR

31

Embedding will be a concept used throughout in order to show that one category can be seen as an
extension of another. Let us consider this in terms of systems. Take a system S , and give a separation
of it that loses information. We keep a certain subcollection S , and we take away the arrows that do not
pertain to the objects we are left with. This is a one way of giving an idea of embedding in a system.
We are attributing an object in one system to an object in another system. Diﬀerent objects are assigned
diﬀerent objects. The relations in one system are relations in another.

Functor for Partial Orders We are now able to speak of functors for partial orders; these functors

are order preserving functions.
Lemma. Given an order preserving function f : O|P → O|Q, we have a functor F : P → Q whose
object function is f .

Proof. We have already seen that partial orders are categories, so it is left to show that the properties
of functor are satisﬁed. The arrow function is determined by property 2) of functors; recall that there
is at most one arrow in a partial order. This means that a relation a ≤ b, in P, is sent into the relation
f a ≤ f b for objects of Q; we know this relation exists in Q because the function is order preserving.
Take an object a in P and apply the functor to it and then we send that object to the unit arrow; the
result is Fa ≤ Fa. If, on the contrary we apply 1P to a and then send a ≤ a to its corresponding arrow,
the result is Fa ≤ Fa.

We are left to prove 3)

b ≤ c ∗ a ≤ b ; F(b ≤ c ∗ a ≤ b), F
b ≤ c ∗ a ≤ b ; F(a ≤ c), F
b ≤ c ∗ a ≤ b ; Fa ≤ Fc, F
b ≤ c ∗ a ≤ b ; Fb ≤ Fc ∗ Fa ≤ Fb, F
b ≤ c ∗ a ≤ b ; F(b ≤ c) ∗ F(a ≤ b), F.

Theorem 5.4. If f is an order bijectivity, then F, with f as object function, is an isomorphism.

Proof. We only need to prove that the arrow function is bijective, because f is bijective. The arrows in
the partial orders are non-discernible and f sends every a ≤ b into a unique arrow f a ≤ f b.
If we have an arrow x ≤ y, in Q. Then, there are a, b in P such that a; x, F and b; y, F, and an arrow
a ≤ b. The arrow Fa ≤ Fb is the arrow assigned to a ≤ b.

Of course, 1Cop is deﬁned as the function that acts as x; 1op

Opposite Category and Contravariant Functor The topic of this paragraph is inspired on previous
developments for partial orders. Given a category C, we construct a system consisting of the same
objects, and for every arrow f : a → b we give an arrow f op : b →op a. The system that results is called
the opposite of C and we write it with Cop.
x , 1Cop. Now it is on us to deﬁne the operation
in Cop. Let us consider a composable pair of arrows, say f : a → b and g : b → c. Then we deﬁne the
arrow f op ∗ gop as the arrow c →op a that is opposite of b → c ∗ a → b. In other words, f op ∗ gop is
deﬁned as (g ∗ f )op.
Lemma I. The opposite, of a category C, is also a category.

32

Proof. We would like to show that 1op
a
is an arrow in Cop, then we have

If gop : y →op b, then

CHAPTER II. CATEGORY
is indeed the unit of a in the opposite category. If f op : x →op a

a ∗ f op, f op
( f ∗ 1a)op, f op
f op, f op

; 1op
;
;

1op
a
1op
a
1op
a

To show that associativty holds, consider hop : b →op x:

gop
gop
gop

y , 1op
y
(1y ∗ g)op, 1op
y

; gop ∗ 1op
;
; gop, 1op
y

f op
f op
f op
f op
f op
f op

;
;
;
;
;
;

f op ∗ (hop ∗ gop), hop ∗ gop
f op ∗ (g ∗ h)op, hop ∗ gop
[(g ∗ h) ∗ f ]op, hop ∗ gop
[g ∗ (h ∗ f )]op, hop ∗ gop
(h ∗ f )op ∗ gop, hop ∗ gop
( f op ∗ hop) ∗ gop, hop ∗ gop

Lemma II. Given a functor F : C → D, there is a functor Fop : Cop → Dop.
Proof. We deﬁne Fop as the functor with FO as object function. Suppose f op : b →op a is an arrow in
Cop; it is the opposite of the arrow f : a → b and we deﬁne f op; (F f )op, Fop.

To prove 1) of functors, let x be a c-object in Cop

We know that (F f )op is of the form Fb →op Fa. This means that 2) is satisiﬁed. To verify 3), let
gop : c →op b, so that

x ;
x ;
x ; 1op
x ; Fop(1op
x ;

(1Dop ◦ FO)x, 1Dop ◦ FopO
1Dop(Fx), 1Dop ◦ FopO
Fx, 1Dop ◦ FopO
x ), 1Dop ◦ FopO
(Fop ◦ 1Cop)x, 1Dop ◦ FopO .

f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop
f op ∗ gop

; Fop( f op ∗ gop), Fop
; Fop(g ∗ f )op, Fop
[F(g ∗ f )]op, Fop
;
(Fg ∗ F f )op, Fop
;
(F f )op ∗ (Fg)op, Fop
;
; Fop f op ∗ Fopgop, Fop

5. FUNCTOR
33
Theorem 5.5. There is a functor op : Cat → Cat that sends a category to its opposite category, and a
functor to its opposite functor.
Proof. The functor op, acts as F; Fop, op and C;Cop, op. It is not diﬃcult to see (1Cat ◦ opO)C is the
same as (opA ◦ 1Cat)C, which veriﬁes 1) for functors. 2) is true because C,D; opC, opD is the same as
saying F : C → D is sent into Fop : Cop → Dop. Given G : D → E, the relation G ◦ F; opG ◦ opF, op
holds; (G ◦ F)op : Cop → Eop and Gop ◦ Fop : Cop → Dop → Eop are equal. Let f op be an arrow in Cop,

(G ◦ F)op f op, (G ◦ F)op
;
[(G ◦ F) f ]op, (G ◦ F)op
;
[G(F f )]op, (G ◦ F)op
;
; Gop(F f )op, (G ◦ F)op
; Gop(Fop f op), (G ◦ F)op
;

(Gop ◦ Fop) f op, (G ◦ F)op.

f
f
f
f
f
f

We say F(cid:110) is contravariant if instead of satisfying condition 2), it satisﬁes 2)(cid:48) a, b; F(cid:110)Ob, F(cid:110)Oa. This
: a → b
means that arrows are reversed. In terms of natural pair of functions, we are saying that f
is sent into some function F(cid:110) f : F(cid:110)b → F(cid:110)a such that f is a natural pair of functions with (F(cid:110) f )op,
under F(cid:110)O. This has implications for condition 3); let g : b → c:

b → c ∗ a → b ; F(cid:110)(b → c ∗ a → b), F(cid:110)
b → c ∗ a → b ; F(cid:110)(a → c), F(cid:110)
b → c ∗ a → b ; F(cid:110)c → F(cid:110)a, F(cid:110)
b → c ∗ a → b ; F(cid:110)b → F(cid:110)a ∗ F(cid:110)c → F(cid:110)b, F(cid:110)
b → c ∗ a → b ; F(cid:110)(a → b) ∗ F(cid:110)(b → c), F(cid:110)

Thus, a contravariant functor satisﬁes 3)(cid:48) F(cid:110), F(cid:110);∗F(cid:110)g, g∗ instead of 3). Equivalently, F(cid:110)(g ∗ f ) is
the same object as F(cid:110) f ∗ F(cid:110)g; in notation for function, we have g ∗ f ; F(cid:110) f ∗ F(cid:110)g, F(cid:110). This can be
resolved in a simple way, using the opposite category of the range category. Let us be clear, a functor is
covariant when it satisﬁes 1), 2), 3), and contravariant when it satisﬁes 1), 2)(cid:48), 3)(cid:48).

Theorem 5.6.

1) Given a contravariant functor F(cid:110) : C → D, there is a covariant functor F : C → Dop.
2) Given a covariant functor F : C → D, there is a contravariant functor F(cid:110) : C → Dop.

Proof.

1) The covariant functor F is deﬁned to have the same object function but the arrow function is FA

which sends f : a → b into FA f := (F(cid:110)A f )op : Fa → Fb.

34

To show that 1) holds,

CHAPTER II. CATEGORY

(1Dop ◦ F(cid:110)O)x, 1Dop ◦ FO
x ;
1Dop(F(cid:110)Ox), 1Dop ◦ FO
x ;
(1F(cid:110)Ox)op, 1Dop ◦ FO
x ;
(F(cid:110)A1x)op, 1Dop ◦ FO
x ;
x ; FA1x, 1Dop ◦ FO
(FA ◦ 1C)x, 1Dop ◦ FO.
x ;

This means 1Dop, 1C; FA, FO. The deﬁnition of FA assures us that 2) is satisﬁed. Moving on to 3),
we make f : a → b and g : b → c.

g ∗ f
g ∗ f
g ∗ f
g ∗ f
g ∗ f

; F(g ∗ f ), F
;
;
;
; Fg ∗ F f, F

[F(cid:110)(g ∗ f )]op, F
[F(cid:110) f ∗ F(cid:110)g]op, F
(F(cid:110)g)op ∗ (F(cid:110) f )op, F

2) We will carry out the proof of the second part of this theorem, although it is similar to the ﬁrst.

Here, we deﬁne F(cid:110)A f := (FA f )op

x ;
x ;
x ;
x ;
x ; F(cid:110)A1x, 1Dop ◦ F(cid:110)O
x ;

(1Dop ◦ FO)x, 1Dop ◦ F(cid:110)O
1Dop(FOx), 1Dop ◦ F(cid:110)O
(1FOx)op, 1Dop ◦ F(cid:110)O
(FA1x)op, 1Dop ◦ F(cid:110)O
(F(cid:110)A ◦ 1C)x, 1Dop ◦ F(cid:110)O.

Since (FA f )op is Fb →op Fa, we know F(cid:110) is contravariant. Now, we prove 3)(cid:48) holds:

g ∗ f
g ∗ f
g ∗ f
g ∗ f
g ∗ f

; F(cid:110)(g ∗ f ), F(cid:110)
;
;
;
; F(cid:110) f ∗ F(cid:110)g, F(cid:110).

[F(g ∗ f )]op, F(cid:110)
[Fg ∗ F f ]op, F(cid:110)
(F f )op ∗ (Fg)op, F(cid:110)

Corollary. If f (cid:110) : O|P → O|Q is an order reversing function, then it is the object function of a covariant
functor F : P → Qop.

5. FUNCTOR
35
Proof. All that we need to prove is that there is a contravariant functor P → Q. The proof of 1) is the
same as in theorem , and 2) is given by the fact that f is order reversing. We are left to prove 3).

b ≤ c ∗ a ≤ b ; F(b ≤ c ∗ a ≤ b), F
b ≤ c ∗ a ≤ b ; F(a ≤ c), F
b ≤ c ∗ a ≤ b ; Fc ≤ Fa, F
b ≤ c ∗ a ≤ b ; Fb ≤ Fa ∗ Fc ≤ Fb, F
b ≤ c ∗ a ≤ b ; F(a ≤ b) ∗ F(b ≤ c), F.

Corollary.

1) Let f be an order bijectivity P,Q;Pop,Qop. Then, there is a covariant isomorphism F : P → Q.
2) Suppose P and Q are dual orders. Then, there is a covariant isomorphism F : P → Qop.
There is another side to this. We can prove that given a covariant functor F : C → D, there is a
contravariant functor F(cid:110) : Cop → D. As one may expect, we can also say that given a contravariant
functor C → D, there is a covariant Cop → D.
Proposition 5.7. If F : C → D is a covariant functor, then so is Fop. Likewise, (F(cid:110))op is contravariant,
given F(cid:110) is contravariant.

Algebraic Functor An algebraic functor is one such that the source and target are algebraic
categories. Given two algebraic categories, it is trivial to deﬁne a functor from one category to the
other. Suppose e1, e2 are the c-objects of C, D, respectively. This means that every arrow in C is a
reﬂexive arrow for e1, and similarly for D and e2. With this in mind, we see that any functor C → D
has the object function deﬁned by FOe1 := e2. One can easily see that the composition of algebraic
functors is again an agebraic functor. We already know that the composition of functors is a functor and
it is easy to give the object function of a compostition of algebraic functors.
Let ∗ be the operation of composition for the objects of operation, in any category C, and give a
function (cid:12) : O → CFC, with a collection O in the domain. We are assigning every object in the domain,
a functor, from some subcategory into the category itslef. This deﬁnes an operation · : O → A|C fA|C.
Since every object in the image of (cid:12) is a functor, we can say that (cid:12)x( f ∗ g) is the same as (cid:12)x f ∗(cid:12)xg. In
other words, f ∗ g; f · x ∗ g · x, x in terms of the notation for ·.
Proposition 5.8. If there is a function from some collection O into CFC, then there is an operation ·
that distributes over the operation ∗, of the category.

Recall theorem 5.2; we sometimes consider an algebraic functor Z → CFC, given Z is algebraic.

Product Category and Bifunctor

Given two C1, C2 categories, form a system C, with O|C := O|C1 →× O|C2 and A|C := A|C1 →× A|C2;
the arrows of C are objects that consist of two arrows. We are using comparability for arrows. Weak
arrows are those in C1 and C2. The arrows in C are strong (ordered pairs of arrows). In short, C is a
category, with O|C := O|C1 →× O|C2 and A|C := A|C1 →× A|C2.

36

CHAPTER II. CATEGORY
We deﬁne the arrows in a natural manner. Let a →× b a c-object, in C. Take arrows f : a →C1 c
and g : b →C2 d; to avoid confusion, we will use the notation a →C1 c to express that the arrow is in
category C1. The reader can see that a →× b and c →× d are a natural pair of functions, under f, g.
Moreover, a →× b and c →× d are c-objects in C. We deﬁne an arrow f →× g : a →× b −→ c →× d.
Theorem 5.9. The system C, deﬁned in terms of C1, C2, is a category and we say it is the product
category of C1 and C2 (in that order). This category may be expressed as C1 × C2.
Proof. We ﬁrst need to prove that A|C1 →× A|C2 is a collection of order arrows for O|C1 →× O|C2.
Given a c-object a →× b, in C, we know the c-objects a, b are in C1, C2, respectively. These satisfy
a; 1a, 1C1 and b; 1b, 1C2, for their unit arrows because C1 and C2 are categories. We deﬁne the unit arrow
1a→×b as the arrow 1a →× 1b : a →× b −→ a →× b.
Suppose we have two arrows in the product category; say f →× g : a →× b −→ c →× d and
h →× i : c →× d −→ x →× y. It is clear that there is an arrow h ∗ f , in C1, and an arrow i ∗ g, in C2.
The composition h →× i ∗ f →× g : a →× b −→ x →× y, is deﬁned as the arrow h ∗ f →× i ∗ g, so that
a →× b and x →× y are a natural pair under h ∗ f : a → x and i ∗ g : b → y. In other words, if we use
the notation for the operation ∗ of C, we have

(II.1)
We move on to show that the unit and associativity are true, for the operation ∗ that acts on the

category C. First, we will show that 1c→×d is the unit of the c-object c →× d, in C.

h →× i; h ∗ f →× i ∗ g, f →× g.

1c→×d
1c→×d
1c→×d

; 1c →× 1d ∗ f →× g, f →× g
; 1c ∗ f →× 1d ∗ g, f →× g
;

f →× g, f →× g.

h →× i
h →× i
h →× i

; h →× i ∗ 1c →× 1d, 1c→×d
; h ∗ 1c →× i ∗ 1d, 1c→×d
; h →× i, 1c→×d.

Finally, we have to prove associativity. We have to consider two more arrows, let us use j : x → w

and k : y → z. We have a new arrow in C; the arrow is j →× k. In terms of the notation for ∗,

j →× k ;
j →× k ;
j →× k ;
j →× k ;
j →× k ;
j →× k ;
j →× k, f →× g ;

( j →× k) ∗ (h →× i ∗ f →× g), h →× i ∗ f →× g
( j →× k) ∗ (h ∗ f →× i ∗ g), h →× i ∗ f →× g
j ∗ (h ∗ f ) →× k ∗ (i ∗ g), h →× i ∗ f →× g
( j ∗ h) ∗ f →× (k ∗ i) ∗ g, h →× i ∗ f →× g
( j ∗ h →× k ∗ i) ∗ ( f →× g), h →× i ∗ f →× g
( j →× k ∗ h →× i) ∗ ( f →× g), h →× i ∗ f →× g
j →× k ∗ h →× i, h →× i ∗ f →× g

Proposition 5.10. The opposite of a product category, is the product of the opposites; that is to say
(C1 × C2)op and Cop

2 are the same category.

1 × Cop

5. FUNCTOR

37

Proof. A category and its opposite have the same c-objects, so we have not much to prove about the
c-objects, we are interested in the arrows. Let g →× op f represent the arrow ( f →× g)op, in (C1 ×C2)op.
The arrow f →× g is of the form a →× b −→ c →× d because f : a →C1 c and g : b →C2 d. We are
able to express g →× op f : c →× d −→op a →× b which means that we want to deﬁne ( f →× g)op as an
1 × Cop
ordered pair, of c →C1 a and d →C2 b. We deﬁne ( f →× g)op := f op →× gop, which is in A|(Cop
2 ).
We have to show that this deﬁnition and the deﬁnition of product for opposite category are consistent.
: a →C1 c,
with each other. We reiterate the naming of arrows, as in the previous result; let
h : c →C1 x, g : b →C2 d, and i : d →C2 y. We know f →× g takes a →× b into c →× d, and
h →× i takes c →× d into x →× y.

f

( f →× g)op
( f →× g)op
( f →× g)op
( f →× g)op
( f →× g)op
( f →× g)op

( f →× g)op ∗ (h →× i)op, (h →× i)op
f op →× gop ∗ hop →× iop, (h →× i)op
f op ∗ hop →× gop ∗ iop, (h →× i)op
(h ∗ f )op →× (i ∗ g)op, (h →× i)op
(h ∗ f →× i ∗ g)op, (h →× i)op
(h →× i ∗ f →× g)op, (h →× i)op

;
;
;
;
;
;

Product Functor for Common Domain It is interesting to see what happens when a functor is
deﬁned for product categories. What can be said about a functor F : C1 × C2 → D1 × D2? We will
carry out a detailed analysis, one step at a time. Begin, considering a functor into a product category.
Proposition 5.11. Given functors f, g : C → D1,D2, there is a functor f × g : C → D1 × D2, and we
say it is the product functor of common domain.
Proof. Let f : C → D1 and g : C → D2 be two functors. We shall build a functor F : C → D, where
the range is the product category. The object function, of F, sends a (cid:55)→ fa →× ga. We make the arrow
function send f : a →C c into f f →× g f . To verify we have a functor, apply 1D ◦ F to any c-object
a in C, the result is 1fa →× 1ga. On the other hand, a (cid:55)→1C (1a) (cid:55)→F (f1a →× g1a); we can say 1) of
functors is true because it is true for f and g. We would like to see that F f is an arrow of the form
fa →× ga −→ fc →× gc, which is true because F f is f f →× g f . With this we have proven that an arrow
from a →C c is sent into an arrow Fa → Fc. Lastly, we will show that 3) holds. Let h : c → x, then

h ∗ f
h ∗ f
h ∗ f
h ∗ f
h ∗ f

; F(h ∗ f ), F
;
;
;
; Fh ∗ F f, F.

f(h ∗ f ) →× g(h ∗ f ), F
fh ∗ f f →× gh ∗ g f, F
fh →× gh ∗ f f →× g f, F

One may now ask, given a functor F : C → D1×D2, is it possible to decompose it into two functors
with common domain? We are saying that the functor sends c-objects a (cid:55)→ (F1a →× F2a); since the
image of a c-object is an order arrow →×, we use F1a to denote the source associated to a and F2a is

38
CHAPTER II. CATEGORY
the target. Also, the functor sends an arrow f : a →C c into an arrow F1a →× F2a −→ F1c →× F2c
which means we have two arrows, F1 f : F1a → F1c and F2 f : F2a → F2c. We can associate two
arrows in the range, to every arrow in the domain; f is assigned the arrows F1 f , F2 f .
Proposition 5.12. Given a functor F : C → D1 × D2, there are functors f : C → D1 and g : C → D2
such that f × g and F are the same functor.

We have proven a functor has a product category, in the image, if and only if it can be decomposed

as two functors with common domain.

Bifunctor[IX]

It is possible to give a functor that acts on pairs of c-objects, and pairs of arrows;
a product category is domain, instead of range. The ﬁrst thing to be brought to our attention will be
the limitations in dealing with these functors. One may expect to be able to form two functors with
common range, by decomposing a functor F : C1 ×C2 → D. This is not true, however. The reader may
convince himself that there is no straightforward way of deﬁning f : C1 → D or g : C2 → D, given a
functor C1×C2 → D. Also, it is interesting to notice that the range is a simple category (not necessarily
a product category) and we assign each pair of objects into a single object in D. Again, we take two
arrows f, g (from C1 and C2) and we give a single arrow.
When we try giving the product of common range, for two functors C1,C2 → D, we come across
the following diﬃculty. Is it possible to build a functor from the product category of the domains into
D? Take functors f, g : C1,C2 → D, and deﬁne F : C1×C2 → D such that the c-objects are transformed
according to (a →× b) (cid:55)→F F(a, b) := fa. Give arrows f : a → c and g : b → d, then the action of
F on the arrow f →× g is deﬁned by F( f, g) := f f
: fa → fc. Let us prove F this is a functor. It
is easily seen that (1D ◦ F)(a →× b) is 1fa, just as (F ◦ 1C1×C2)(a →× b). The second condition of
functors is satisﬁed; if we apply F to f →× g : a →× b −→ c →× d, the result is an arrow of the
form F(a, b) → F(c, d), because F(a, b) is fa and F(c, d) is fc. To verify that 3) also holds, take a
composable pair of arrows f →× g and h →× i, and apply F to their composition, which has been
deﬁned as h →× i ∗ f →× g := h ∗ f →× i ∗ g. This is expressed as F(h ∗ f, i ∗ g), and in reality it is the
arrow f(h ∗ f ). Also, F(h, i) ∗ F( f, g) is the same as fh ∗ f f . Of course, one can also build a functor G
such that a →× b is sent into gb and f →× g is sent into gg. Although we were able to ﬁnd functors F
and G, given f, g that have the same range, the functors we found are relatively simple. They are simple
in the sense that we are losing all the infomation of one functor, or another. We are building functors
whose transformation disregards the information regarding one functor. A solution to this, is proposed
in the following proposition.
Proposition 5.13. Let f, g : C1,C2 → D be functors, then we can deﬁne a functor f×g : C1×C2 → D×D
called the product of common range.
Proof. We deﬁne a c-object function, (f × g)(a, b) := fa →× gb. Let the arrow function be deﬁned by
that transformation (f × g)A( f, g) := f f →× gg. The reader may prove that this is a functor. If he runs
across any diﬃculty, a similar construction and proof is carried out, in the theorem of this division.

Let B : C1×C2 → D be a function which has a product category in the domain, and suppose it sends
a c-object a →× b into a c-object B(a, b). An arrow f →× g : a →× b −→ c →× d, is sent into an arrow
B( f, g) : B(c, b) → B(a, d). We know there are arrows c →× b and a →× d in C1 × C2. We will say B
is contravariant with respect to the ﬁrst argument and covariant with respect to the second argument if
the source and target objects of B( f, g), are the images of c →× b and a →× d, respectively. Although

5. FUNCTOR

39

we are sending pairs into singles, we do it in such a way that the source of B( f, g) depends on c and b.
Conversely, the target depends on a and d. A function B can be suitably deﬁned to be covariant in the
ﬁrst argument and contravariant in the second. There can also be functions covariant (or contravariant)
in both arguments.
In (II.1), we are giving an operation ∗ : A|C → A|C fA|C. For every f →× g, there is a right
operation function (∗ f,∗g) : A|C → A|C. The function (∗ f,∗g) sends h →× i into h ∗ f →× i ∗ g. We
have potential for more functions than just the right operation. The left operation of h →× i is deﬁned
as the function (h∗, i∗) such that f →× g; h ∗ f →× i ∗ g, (h∗, i∗). Still this is not all, since we can deﬁne
the right-left operation which is a function (∗ f, i∗) that sends h →× g into h ∗ f → i ∗ g. Finally, we
deﬁne the following the left-right operation and use this to express contravariance in the ﬁrst argument
and covariance in the second. Given two arrows h : c →C1 x and g : b →C2 d, we deﬁne the function
(h∗,∗g) : A|C → A|C that sends ( f →× i) (cid:55)→ (h∗ f →× i∗ g), where f : a →C1 c and i : d →C2 y. If we
apply B to h ∗ f →× i ∗ g, the result is the arrow B(h ∗ f, i ∗ g), which is of the form B(x, b) → B(a, y).
On the other hand, applying ∗B(h, g) to B( f, i), we get
; ∗B(h, g)B( f, i),∗B(h, g)
; ∗[B(x, b) → B(c, d)][B(c, d) → B(a, y)],∗B(h, g)
[B(c, d) → B(a, y)] ∗ [B(x, b) → B(c, d)],∗B(h, g)
;
; B(x, b) → B(a, y),∗B(h, g).

B( f, i)
B( f, i)
B( f, i)
B( f, i)

With this we show that B( f, i) ∗ B(h, g) is parallel to B(h ∗ f, i ∗ g), given B is contravariant in the ﬁrst
argument and covariant in the second. A function B : C1 × C2 → D is a bifunctor if

1) 1D, 1C1×C2; BA, BO
2) a →× b, c →× d; B(c, b), B(a, d)
3) B, B;∗B(h, g), (h∗,∗g).

The ﬁrst condition is stating that for any c-object, in C, B(1a, 1b), is the same arrow in D, as 1B(a,b). It
is the usual ﬁrst condition for functors, where C is now a product category. The second request for a
bifunctor is the statement that the arrow f →× g : a →× b −→ c →× d is sent into an arrow of the
form B(c, b) → B(a, d). In 3) we are expressing that applying B ◦ (h∗,∗g) or ∗B(h, g) ◦ B to ( f →× i),
yields the same result in both cases. If it is a bifunctor, then h ∗ f →× i ∗ g; B( f, i) ∗ B(h, g), B is true.
Equivalently, to 3), we can say for every composable pair of arrows, f →× g and h →× i, we verify
condition 3)(cid:48) h →× i ∗ f →× g; B( f →× i) ∗ B(h →× g), B.
Proposition 5.14. F : C1 × C2 → D is a functor if and only if there is a bifunctor B : Cop
Proof. To verify that we have a bifunctor, we start with the property of unit arrows.

1 × C2 → D.

(1D ◦ F)(a →× b), 1D ◦ BO
1DF(a, b), 1D ◦ BO

a →× b ;
a →× b ;
a →× b ; 1F(a,b), 1D ◦ BO
a →× b ; FA1(a→×b), 1D ◦ BO
a →× b ; FA(1a →× 1b), 1D ◦ BO
a →× b ; BA[1op
a →× 1b], 1D ◦ BO
a →× b ;
(BA ◦ 1Cop

1 ×C2)(a →× b), 1D ◦ BO

40

CHAPTER II. CATEGORY

With this we are saying that BO(a, b) and FO(a, b) are the same, while BA( f op, g) := FA( f, g). An
arrow, in the domain of B, say f op → g : c →× b −→ a →× d, is transformed into the arrow
F( f, g) : F(a, b) → F(c, d). We prove that composition is preserved, with
f op →× i ∗ hop →× g ; B( f op ∗ hop →× i ∗ g), B
f op →× i ∗ hop →× g ; B( f op ∗ hop, i ∗ g), B
f op →× i ∗ hop →× g ; B[(h ∗ f )op, i ∗ g], B
f op →× i ∗ hop →× g ; F(h ∗ f, i ∗ g), B
f op →× i ∗ hop →× g ; F(h →× i) ∗ F( f →× g), B
f op →× i ∗ hop →× g ; F(h, i) ∗ F( f, g), B
f op →× i ∗ hop →× g ; B(hop, i) ∗ B( f op, g), B

Given B, we deﬁne a functor with F(a, b) := B(a, b) and F( f, g) := B( f op, g).
There is a bifunctor, for every functor with a product category in the domain. We will continue to
give examples of bifunctors, from given functors. Given two functors, it shouldn’t be diﬃcult to build
a bifunctor, since it is contravariant in the ﬁrst argument and covariant in the second argument. In fact,
the reader may verify that the following result is a corollary of the last two propositions. Nevertheless,
we still give the proof, so as to help the reader with understanding the constructions better.
Proposition 5.15. Given two functors f, g : C1,C2 → D, it is possible to deﬁne a bifunctor of the form
f×g : Cop
1 ×C2 → D×D. The object function is deﬁned so that (f×g)(a, b) is fa →× gb, and (f×g)( f op, g)
is the same as f f →× gg.
Proof. To prove 1),

B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)
B(a, b)

1D×DB(a, b), 1D×D
1D×D(fa →× gb), 1D×D

;
;
; 1(fa→×gb), 1D×D
; 1fa →× 1gb, 1D×D
f1a →× g1b, 1D×D
;
; B(1op
a , 1b), 1D×D
a →× 1b), 1D×D
; B(1op
(B ◦ 1Cop
;

Let us now look at the second condition of bifunctors; an arrow f op →× g : c →× b −→ a →× d is

sent into f f →× gg : fa →× gb −→ fc →× gd, which is of the form B(a, b) → B(c, d). Finally,

1 ×C2)(a →× b), 1D×D.

f op →× i ∗ hop →× g ; B( f op →× i ∗ hop →× g), B
f op →× i ∗ hop →× g ; B( f op ∗ hop →× i ∗ g), B
f op →× i ∗ hop →× g ; B( f op ∗ hop, i ∗ g), B
f(h ∗ f ) →× g(i ∗ g), B
f op →× i ∗ hop →× g ;
f op →× i ∗ hop →× g ;
fh ∗ f f →× gi ∗ gg, B
f op →× i ∗ hop →× g ;
fh →× gi ∗ f f →× gg, B
f op →× i ∗ hop →× g ; B(hop, i) ∗ B( f op, g), B.

5. FUNCTOR

41
Decomposing Bifunctors We proceed with the study of a functor F : C1 × C2 → D1 × D2. To
begin with, it sends a c-object, say a →× b in C1 × C2, into a c-object F(a, b) := x →× y in D1 × D2.
Arrows have to be sent into arrows; give f : a → c and g : b → d in C1 and C2, respectively. Suppose
F(b, d) = w →× z, then f →× g is an arrow of the form a →× b −→ c →× d, in the domain. The
corresponding image is an arrow F( f →× g) : F(a, b) −→ F(c, d). Let us make observations based on
the results that we already have. First, is an extension of propositions 5.11 and 5.13.
Proposition 5.16. Given two functors f, g : C1,C2 → D1,D2, there is a functor f×g : C1×C2 → D1×D2.
Proof. The product functor is deﬁned as FO(a, b) := fa →× gb and FA( f, g) := f f →× gg.
Theorem 5.17. B : C1 × C2 → D1 × D2 is a bifunctor if and only if B can be expressed as a product of
common domain for two bifunctors p, q : C1 × C2 → D1,D2.
Proof. Proposition 5.12 implies that the corresponding functor Cop
B, can be decomposed as two functors of common domain f, g : Cop
bifunctors p, q : C1 × C2 → D1,D2, by applying proposition 5.14 a second time.
f, g : Cop
f × g : Cop

1 × C2 → D1 × D2, associated to
1 × C2 → D1,D2. We consider
Let p, q : C1 × C2 → D1,D2 two bifunctors of common domain, then we can construct two functors
1 ×C2 → D1,D2, again with result 5.14. From these two we form a functor of common domain,
1 × C2 → D1 × D2. Now we can give a bifunctor B : C1 × C2 → D1 × D2.

The reader is left to prove the eequality of the product with B.

Corollary. B : C1 × C2 → D × D is a bifunctor if and only if there are bifunctors p, q : C1 × C2 → D,
parallel in Cat.

Natural Transformation

Our ultimate goal is to generalize concepts, and the natural transformation is next, as exposed by [I].
We see that one way of giving meaning to the situations so far discussed is by interpreting the binary
relations by stronger and weaker arrows. We will see the natural transformation as a strong arrow
between two weak arrows, the functors.
In the last section, given f, g : C → D1,D2, we were able to give a functor that was product for
common domain. We did this by giving a category D1 × D2, and then we can assign a c-object in C,
into an arrow →×, which is a c-object of the product category. Let us consider the situation where D1
and D2 are the same category. We give a functor from C into D × D. Here, we take a turn. Because
D × D is a collection of non-discernible arrows, instead of assigning an arrow →×, to an object in C,
we will assign it an arrow in D.
Let functors f, g : C → D, and function τ : O|C → A|D be such that a (cid:55)→τ τa : fa → ga. We say τ
is a bridge from f to g, and we write τ : f → g.
Proposition 5.18. Given a bridge, τ : f → g, we can give a category (cid:126)D := (cid:126)D(τ; f, g), with O| (cid:126)D := Im τ,
and a functor T : C → (cid:126)D such that TO := τ.
Proof. First, we must deﬁne the arrows of (cid:126)D. Given an arrow f : a → b, deﬁne an arrow τ f : τa → τb,
for the category (cid:126)D. The composition in (cid:126)D is deﬁned by τg ∗ τ f := τ( f ∗ g); we guarantee the existence
of τ( f ∗ g), for composable arrows in the category C.

42

CHAPTER II. CATEGORY

Given a c-object τb, we have a unit arrow 1τb := τ1b : τb → τb, such that

; 1τb ∗ τ f, τ f
; τ1b ∗ τ f, τ f
; τ(1b ∗ f ), τ f
; τ f, τ f.

1τb
1τb
1τb
1τb

Similarly, we have τ f ; τ f, 1τa which proves (cid:126)D has a unit arrow for every c-object τa. The reader should
not have diﬃculty showing associativity holds for the composition, so we conlcude (cid:126)D is a category.

If we deﬁne TA f := τ f , we have a functor.

Deﬁnition 7. A bridge τ : f → g is a natural transformation if for every arrow f : a → b, in C, we have
τb, τa; g f, f f in terms of composition for D.

The expression τb, τa; g f, f f means that τb ∗ f f is the same arrow as g f ∗ τa. It is reasonable to
request this because they are parallel, τb∗ f f : fa → gb and g f ∗ τa : fa → gb. Equivalently, one can say
the bridge is a natural transformation if and only if f f, g f are a natural pair of functions, under τa, τb.
Proposition 5.19. Let τ, a bridge for two functors f, g : C → D, and suppose the arrows of D are
non-discernible. Then τ is a natural transformation.
Corollary. Suppose there are two order preserving functions f, g : O|P → O|Q such that f a ≤ ga for
every c-object in C. Then, τ : O|P → A|Q that sends a (cid:55)→ f a ≤ ga is a natural transformation f → g,
where the functors satisfy fO := f and gO := g.

We are playing with an order deﬁned on the functors of the partial orders. For any two order
preserving f, g : O|P → O|Q, we say f (cid:22) g if and only if f x ≤ gx, for every object in P. Of course, if
f, g are the functors corresponding to f, g, respectively, then we say f ≤ g.
Proposition 5.20. Let f and g be two functors P → Q, for partial orders. The relation f ≤ g, is a partial
order on the functors.
Proof. Let f represent the object function of f. We observe reﬂexivity holds in the fact that f ≤ f is
equivalent to the statement f x ≤ f x, for every x in P. Suppose f ≤ g ≤ h. Transitivity holds because we
can assert f x ≤ gx ≤ hx, for every x in P, where g, h is the object function of g, h. If f ≤ g and g ≤ f,
then we have f x ≤ gx and gx ≤ f x for every x. This means f x = gx.

We will build two diﬀerent categories, using natural transformations as strong arrows for weak
arrows, the functors. That is to say, our categories will have functors as c-objects and natural transformations
as arrows. Consider the collection of natural transformations f → g, for a pair of parallel functors
f, g : C → D; we deﬁne Nat(f, g) := {f → g}.
Cat(C,D) is a category if Cat(C,D)O := {CFD} and the natural transformations are arrows. First,
every functor has a natural transformation 1f : f → f so that x (cid:55)→1f 1fx := fx → fx; in other words, the
unit arrow of f sends an object x, in C, into the unit arrow 1fx, in D. Let use deﬁne the operation of
arrows as · so that x (cid:55)→σ·τ σx ∗ τx for τ, σ : f, h → h, j. Of course, σx ∗ τx : fx → jx is the composition,
in D, of σx : hx → jx and τx : fx → hx. To prove this is indeed a natural transformation, use the arrow

5. FUNCTOR
43
σb ∗ h f ∗ τa. Suppose we have a natural transformation τ : f → h, then τ · 1f and 1h · τ are the same as
τ. To prove associativity; show ρ · (σ · τ) and (ρ · σ) · τ are the same function. Applying ρ · (σ · τ) to x,

[ρ · (σ · τ)]x, ρ · (σ · τ)
x ;
x ; ρx ∗ (σ · τ)x, ρ · (σ · τ)
x ; ρx ∗ (σx ∗ τx), ρ · (σ · τ)
(ρx ∗ σx) ∗ τx, ρ · (σ · τ)
x ;
(ρ · σ)x ∗ τx, ρ · (σ · τ)
x ;
[(ρ · σ) · τ]x, ρ · (σ · τ)
x ;

Now we study the category of all categories, (cid:126)Cat. Let τ, α : f, g → h, i be natural transformations for
the functors f, h : C → D and g, i : D → E. If we apply τ to x, the reuslt is τx : fx → hx. If we apply α
to fx, we get αfx : g(fx) → i(fx). In the same way, αhx : g(hx) → i(hx). We deﬁne α ◦ τ : g ◦ f → i ◦ h, a
natural transformation such that

(II.2)
We can equivalently say (α ◦ τ)x := i(τx) ∗ α(fx) because α(hx), α(fx); i(τx), g(τx). To prove (α ◦ τ) is in
Nat(g ◦ f, i ◦ h), we must prove (α ◦ τ)b, (α ◦ τ)a; (i ◦ h) f, (g ◦ f) f for any f : a → b, in C. Recall that for
every arrow h f : ha → hb in D, we have α(hb), α(ha); i(h f ), g(h f ) because α is in Nat(g, i).

(α ◦ τ)x := α(hx) ∗ g(τx).

(α ◦ τ)b ;
(α ◦ τ)b ∗ (g ◦ f) f, (g ◦ f) f
(α ◦ τ)b ; α(hb) ∗ g(τb) ∗ gf f, (g ◦ f) f
(α ◦ τ)b ; α(hb) ∗ g(τb ∗ f f ), (g ◦ f) f
(α ◦ τ)b ; α(hb) ∗ g(h f ∗ τa), (g ◦ f) f
(α ◦ τ)b ; α(hb) ∗ g(h f ) ∗ gτa, (g ◦ f) f
(α ◦ τ)b ;
i(h f ) ∗ α(ha) ∗ gτa, (g ◦ f) f
(i ◦ h) f ∗ (α ◦ τ)a, (g ◦ f) f
(α ◦ τ)b ;
(α ◦ τ)b, (α ◦ τ)a ;
(i ◦ h) f, (g ◦ f) f.

To prove associativity, let µ : l → m, where l, m : E → F . This implies µ ◦ α : l ◦ g → m ◦ i such that
(µ ◦ α)hx := µi(hx) ∗ lα(hx). Thus,

[µ ◦ (α ◦ τ)]x, µ ◦ (α ◦ τ)

x ;
x ; µ(i ◦ h)x ∗ l(α ◦ τ)x, µ ◦ (α ◦ τ)
x ; µi(hx) ∗ l(αhx ∗ gτx), µ ◦ (α ◦ τ)
x ; µi(hx) ∗ lα(hx) ∗ (l ◦ g)τx, µ ◦ (α ◦ τ)
x ;
x ;

(µ ◦ α)hx ∗ (l ◦ g)τx, µ ◦ (α ◦ τ)
[(µ ◦ α) ◦ τ]x, µ ◦ (α ◦ τ).

Lemma. Let α, β : g, i → i, k be natual transformations of functors g, i, k : D → E. In terms of the
notation operation ◦ of (cid:126)Cat, we verify β · α; (β ◦ σ) · (α ◦ τ), σ · τ. Equivalently, if the notation is used
for ·, which is the operation in the categories Cat(C,D) and Cat(D,E), then β◦ σ; (β· α)◦ (σ· τ), α◦ τ.

44
Proof. Notice β · α : g → k, and σ · τ : f → j.

CHAPTER II. CATEGORY

[(β · α) ◦ (σ · τ)]x, (β · α) ◦ (σ · τ)
(β · α)(jx) ∗ g[(σ · τ)x], (β · α) ◦ (σ · τ)
[β(jx) ∗ α(jx)] ∗ g(σx ∗ τx), (β · α) ◦ (σ · τ)

x ;
x ;
x ;
x ; β(jx) ∗ [α(jx) ∗ g(σx)] ∗ g(τx), (β · α) ◦ (σ · τ)
x ; β(jx) ∗ [i(σx) ∗ α(hx)] ∗ g(τx), (β · α) ◦ (σ · τ)
[β(jx) ∗ i(σx)] ∗ [α(hx) ∗ g(τx)], (β · α) ◦ (σ · τ)
x ;
(β ◦ σ)x ∗ (α ◦ τ)x, (β · α) ◦ (σ · τ)
x ;
[(β ◦ σ) · (α ◦ τ)]x, (β · α) ◦ (σ · τ).
x ;

Theorem 5.21. Given categories C,D,E, there is a functor F : Cat(C,D) × Cat(D,E) → Cat(C,E)
such that FO(f →× g) := g ◦ f and FA(τ →× α) := α ◦ τ.
Proof. We will need to prove, ﬁrst of all, that the unit natural transformation, 1g◦f, is the same as 1g◦ 1f.
To see that this is true, note (II.2) implies x; 1g(fx) ∗ g(1fx), 1g ◦ 1f so that for any c-object x in C

x ; 1g◦fx, 1g◦f
x ; 1(g◦f)x, 1g◦f
x ; 1(g◦f)x ∗ 1(g◦f)x, 1g◦f
x ; 1g(fx) ∗ g1fx, 1g◦f
x ; 1g(fx) ∗ g1fx, 1g◦f
(1g ◦ 1f)x, 1g◦f.
x ;

We know (1Cat(C,E) ◦ FO)(f →× g), results in 1g◦f. On the other hand, (FA ◦ 1C)(f →× g) is 1f ◦ 1g, where
we use C := Cat(C,D) × Cat(D,E).
Let τ : f → h and α : g → i, which means τ →× α : f →× g −→ h →× i. The image of the arrow in
the domain category is α ◦ τ : g ◦ f → i ◦ h.

The proof that F satisﬁes 3) is given by the lemma:

(σ →× β) · (τ →× α)
(σ →× β) · (τ →× α)
(σ →× β) · (τ →× α)
(σ →× β) · (τ →× α)
(σ →× β) · (τ →× α)

; F[(σ →× β) · (τ →× α)], F
; F[σ · τ →× β · α], F
;
;
; F(σ →× β) · F(τ →× α), F.

(β · α) ◦ (σ · τ), F
(β ◦ σ) · (α ◦ τ), F

The functor is an object function FO : O|Cat(C,D) × O|Cat(D,E) → O|Cat(C,E) and an arrow
function given by FA : A|Cat(C,D) × A|Cat(D,E) → A|Cat(C,E). These functions give operations.
The operation for functors is FO : O|Cat(C,D) → {O|Cat(D,E) f O|Cat(C,E)}, and the operation for
natural transformations is FA : A|Cat(C,D) → {A|Cat(D,E) f A|Cat(C,E)}.

6. INTEGER SYSTEMS

Integer Systems

45

We have proven the existence of a discrete number system, but there are many such systems. For any
discrete number system Z, consider the system obtained by adding transitive arrows. We conserve
the property of having non-discernible arrows; add only one arrow for every pair a → b and b → c.
We denote such a system with Z<. If we add one reﬂexive arrow to every c-object of Z<, the system
obtained is denoted by Z≤. This new system is a partial order, in which we consider the arrows in the
natural order, of axiom 3. When considering a partial order, we may write a < b to make it clear a and
b are not the same object.
Now that there is a partial order, associated to any discrete number system Z, we can consider
functors Z≤ → Z≤. We have the identity functor, which we assign to the object 0, by +0 := IZ≤.
But, there is another functor to consider. We call it the functor sum 1, denoted +1 : Z≤ → Z≤. To
prove that we have a functor, we will give an order preserving function, and then we deﬁne +1 as the
functor associated to said function. It is not necessary to look far for our function, the arrows of Z
form a bijective function. These arrows form a function, with Z in the domain, because every object
is source of one arrow only. Since every object of Z is target of exactly one arrow, we can say that the
object function of +1, is bijective. Take a < b in Z≤, then we also have a + 1 ≤ b. Since we also have
b < b + 1, it turns out a + 1 < b + 1.
Proposition 6.1. The arrows of a discrete number system Z, are the components of an order bijectivity
for the objects of Z≤. The corresponding functor, +1, is an automorphism of the partial order Z≤.

Compose this automorphism with itself to form a new automorphism, and call it sum 2. For any
x + 1 of the partial order Z≤, such that 0 < x + 1, we give the automorphism +(x + 1) := +1◦ +x. Since
we have given a functor +x, the object function is order preserving and the corresponding functor is
precisely +x. We will prove that these functors are related as in proposition 5.20.

Lemma I. If x, x + 1 are two comparable objects, in a discrete number system, and 0 < x + 1, then the
functors satisfy +x < +(x + 1).

Proof. In terms of the order preserving functions, we have a + x < (a + x) + 1 = a + (x + 1) for any a
in Z≤. This is the same as saying +xO (cid:22) +(x + 1)O.

Since +1 is an automorphism, we have the inverse automorphism +(−1) : Z≤ → Z≤. This is the
functor minus 1. If x < 0, we deﬁne +(x− 1) := +(−1)◦ +x, and +(−1) := +1−1. The reader may verify
that, in general, +(−x) is the inverse of +x. Here, we give the second part of the last result.
Lemma II. For comparable objects x, x − 1 with x − 1 < 0, the functors satisfy +(x − 1) < +x.
Proof. Note that a + (x − 1) = (a + x) − 1 < a + x.
Theorem 6.2. If Z is a discrete number system, then there is an isomorphism ⊕ : Z≤ → {+x}≤, where
{+x}≤ is the partial order on automorphisms +x. Given any two a ≤ b, in Z≤, there is a natural
transformation +a → +b.
Proof. The lemmas give a discrete number system, ··· < +(−2) < +(−1) < +0 < +1 < +2 < ··· . The
object function of ⊕ is bijective; we have deﬁned it to be onto, and we need to show it is monic. We
verify this last, because any two functors +a, +b are diﬀerent.

46

CHAPTER II. CATEGORY

The arrow function is also bijective because partial orders consist of none discernible orders. All
Finally, if a ≤ b, we know +a ≤ +b. From the corollary of proposition 5.19, we have a natural

we need to do is assign arrows amongst respective objects.
transformation of the form +a → +b.

The following lemma will be extremely useful in proving our next theorem, where we wish to show

the functors in the image of ⊕, commute under composition.
Lemma. Let f, g : O → O be bijective functions that commute. Then f −1, g also commute.

Proof.

g ; g ◦ f −1, f −1
g ;
g ;
g ;
g ;
g ;
g, g ;

( f −1 ◦ f ) ◦ (g ◦ f −1), f −1
f −1 ◦ ( f ◦ g) ◦ f −1, f −1
f −1 ◦ (g ◦ f ) ◦ f −1, f −1
( f −1 ◦ g) ◦ ( f ◦ f −1), f −1
f −1 ◦ g, f −1
f −1, f −1

Theorem 6.3. Let Z be a discrete number system. The object function, of the isomorphism ⊕, deﬁnes
a full operation + : O|Z → {O|Z fisoO|Z}.

1) The functors of {+x}≤ form a commutative group, under composition; we represent it with Z†.

2) Using +, we construct a commutative group Z, on the objects of the discrete number system.
3) There is an isomorphism Z → Z†.

Proof. The object function ⊕O sends x into the automorphism +x, for Z≤. The object function of +x is
+xO, we may also write it as +x. Thus, every object in Z≤ is assigned a function +xO : O|Z≤ → O|Z≤.
The fact we are sending every x into an automorphism, implies the operation is full. The operation can
be expressed as + : O|Z → O|Z fO|Z because the objects of Z and Z≤ are the same.

1) We know that the collection of automorphisms is a group. Since +0 is the identity, we only need
to notice the functors of {+x}≤ have inverse also in {+x}≤. Therefore, the functors +x form a
group, under ◦.
Now we would like to see the group is commutative. We wish to prove +x ◦ +y and +y ◦ +x are
the same function, whoever x, y of Z may be. If 0 ≤ x, then +1 ◦ +x is the same as +x ◦ +1
because +x is compositions of +1; using the lemma, one can prove +(−x) ◦ +1 and +1 ◦ +(−x)
are the same. This proves +1 commutes with all. Now, suppose +y commutes with all; we will

6. INTEGER SYSTEMS

47

prove +(y + 1) commutes with all other functors of the group.
; +(y + 1) ◦ +x, +x
(+1 ◦ +y) ◦ +x, +x
;
; +1 ◦ (+y ◦ +x), +x
; +1 ◦ (+x ◦ +y), +x
(+1 ◦ +x) ◦ +y, +x
;
(+x ◦ +1) ◦ +y, +x
;
; +x ◦ (+1 ◦ +y), +x
; +x ◦ +(y + 1), +x.

+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)
+(y + 1)

One can equally show +(y − 1) commutes with all +x, given +y commutes with all.

2) We know the unit exists because +0 is identity. It will be useful to see how other objects act on 0.
We know 0 + 1 is the target in the arrow 0 → 1. Suppose 0 + x is x, then we also have 0 + (x + 1)
is x + 1. The same is true for x − 1, so that 0; x, x for every x.
Also, we see that every x has an inverse. Since +(−x) := +x−1 is true, we can conclude the inverse
of x, is −x because

x ; x + (−x),−x
x ;
x ;
x ;
x ; 0,−x

(0 + x) + x−1,−x
(0 + x) + x−1,−x
(+x−1 ◦ +x)0,−x

Commutativity of two objects x, y follows from commutativity of their functors:

x ; x + y, y
x ;
x ;
x ;
x ; y + x, y

(0 + x) + y
(+y ◦ +x)0, y
(+x ◦ +y)0, y

x, x ; y, y.

Associativity is proven using commutativty of the operation and commutativity of the functors.
To prove the operation is associative we will prove x+ and +y commute. We use the fact +x and
+y commute and that the operation itself commutes, which means left and right operations are
the same functions.

+x, +x ; +y, +y
x+, x+ ; +y, +y.

Up to this point we have proven that there is an commutative operation that satisﬁes the properties
of group. However, we still need to build a group which consists of one c-object and objects of

48

CHAPTER II. CATEGORY

operation on it. We may consider the objects of a discrete number system as automorphisms on
a category that is suﬃciently large. We mean suﬃciently large in the sense that we can make
a category as large as we want to give as many automorphisms (arrows) as can be needed. We
know that this is true for the group of ordered automorphisms Z†. So, for any discrete array of
numbers, we say each is an automorphism of a suitable category. This category is the c-object of
the group, and we will give it the symbol Z†. Our group Z is deﬁned as the algebraic category
with Z† as object of the automorphisms, which are the objects of the discrete number system Z.
We are deﬁning A|Z := O|Z≤. The operation of Z is the one deﬁned by the functors of Z†, which
are the inverses and compositions of the functor determined by the arrows of Z.

3) Lastly, consider the algebraic functor i : Z → Z† such that iOZ† := Z≤, and iAx := +x for every
automorphism x : Z† → Z†. To show this is indeed a functor, we must prove the third condition
of functors. That would be to verify i(x + y) is the same object of operation as ix ◦ iy. In other
words, one must prove i(x + y) := +(x + y) and ix ◦ iy := +x ◦ +y. Start with associativity and
apply commutativity to prove this:

a, x ; a + y, y + x
a, x ; a + y, x + y.

Every discrete number system generates a group of functors, that determine the objects of the
discrete number system as a group; both groups involved will be isomorphic. At the same time, the
discrete number system is a group of automorphisms of another category. Thus, automorphisms of
the kind generated by discrete number systems, follow the pattern of a discrete number system. Every
object is in the same position; every object has one arrow into it and one arrow from.

a

For practical purposes,

c or a c will express a ≤ c. We have freedom to write a b c··· or its
vertical counterpart, in order to express all the possible relations a ≤ b, a ≤ c, b ≤ c, . . . . The question,
now, is how we got from ≤ to this +. This is basically an explanation of (II.3), below. We generalize
the system of integers, in the following manner. Begin with one row, which represents Z≤, and to each
object of that row assign a function. The function +x, represented by the columns of 0 and x, consists
of the arrows from the column 0 into the column x. One object is chosen, 0, for which the arrows of its
function are all reﬂexive; the identity function. The functions +x, all preserve the natural order of Z≤;
every column is Z≤. The functions are order bijectivities and since the functors are ordered, natural
transformations deﬁne a partial order for them. If 0 ≤ x, the natural transformation +0 −→τ +x is the
function that assigns to each object a of Z≤, the arrow a → a + x, so a →τ τa : a ≤ a + x.
The fact that our bridge is a natural transformation, means τb, τa; +x(a ≤ b), +0(a ≤ b). This can
otherwise be written as b ≤ b + x, a ≤ a + x; a + x ≤ b + x, a ≤ b. This last is equivalent to saying
b ≤ b + x ◦ a ≤ b is the same composition as a + x ≤ b + x ◦ a ≤ a + x; both are a ≤ b + x.
The grid of objects (II.3) is a representation of the constructions we have carried out. We can see
it as a collection of arrows for the objects of Z≤. In this case, we are providing no new information,
to what is given by a discrete number system. We can also, and more meaningfully, interpret this as
comparability of relations.

7. RATIONAL SYSTEMS

49

...

...

...

...

...
...
··· −5 −4 −3 −2 −1 0 ···
0 1 ···
··· −4 −3 −2 −1
··· −3 −2 −1
1 2 ···
0
··· −2 −1
2 3 ···
1
0
··· −1
3 4 ···
0
1
2
4 5 ···
···
3
2
1
0
...
...
...
...
...

...

.

(II.3)

4)

3)

2)

0 a
x n

a n
0 x

n x
a 0

x 0
n a .

We say a ≤ c and b ≤ d are comparable if they appear in a rectangle:

a b
c d . This would of course
be expressed as a, c; b, d. We have chosen this deﬁnition of comparability for good reason. Suppose 0
is one of the four objects, and you have a rectangle of the form:
1)
This means we have applied the functor +a to 0, and x. After applying +a to 0, we naturally get a. If
we apply +a, to x, the result is n. In terms of the notation for +, we can assert 0, x; a, n. The operation
is deﬁned by a →+x n if 1) or 3) occur. If, on the contrary, we have the occurence of 2), the rectangle
in which a, x occur will be unique. The same is true for 4). One can see this is true in general; we need
a b
c d , we have a, c; b, d in terms of the operation as well
not take 0 as a corner. Given any rectangle
as the comparability of arrows. Although, we must be careful in using the notation , ; , for the following
reason. When representing comparability for the order relation, or the operation, a, c; b, d and a, b; c, d
a
c means the same thing as a c. However, changing
mean the same thing, because we have said that
a, c; b, d for b, d; a, c is only valid if the notation is used in representation of the operation. This is due
to anti-symmetry of the order. Deﬁning the operation in terms of comparability, with arrows that have
a 0, assures the operation is an ordered triple; we are eliminating one component, by ﬁxing 0.

Rational Systems

Product

A new operation is deﬁned, in terms of the sum, for the objects of Z. For x ≥ 0 we deﬁne the product as
the operation · given by a; (a· x) + a, x + 1. This is to say ·(x + 1)a := (+a◦·x)a. It is in our best interest
to deﬁne the operation in such a way that x · 1 means we add x once. Said diﬀerently, we want x; x, 1.
To achieve this, we deﬁne x; 0, 0. If we have 0; 0, x, we also have 0; 0, x + 1. Similarly, 1; x + 1, x + 1 if
1; x, x. From this point on, we will use the notation a − x to express a + (−x). The product for x ≤ 0,
is deﬁned by a; (a · x) − a, x − 1. It is immediate, from this deﬁnition, that x;−x,−1. Again, we have
0; 0, x − 1 and −1;−(x − 1), x − 1 given 0; 0, x and −1;−x, x. We thus have, for every integer a,

a; 0, 0

0; 0, a

1; a, a

a; a, 1.

Theorem 7.1. The product is a full operation · : Z → {·x}, where {·x} is a collection of functions ·x.
Every ·x determines a functor ·x on Z. Furthemore, the operation is commutative and associative.

50
Proof. To prove ·x is a functor suppose, for x ≥ 0, that a + b; (a · x) + (b · x), x.

CHAPTER II. CATEGORY

(a + b) · x + (a + b), x + 1
[(a · x) + (b · x)] + (a + b), x + 1
[(a · x) + a] + [(b · x) + b], x + 1

a + b ;
a + b ;
a + b ;
a + b ; a · (x + 1) + b · (x + 1), x + 1.

This implies ·x is a functor from Z to itself. It is not, however, an automorphism. It is not diﬃcult to
see under what condidtions it is monic.

We know 0 commutes with any integer, so now we wish to know if the same is true for x + 1, given

that x commutes with any integer. Using the last result we ﬁnd

a + 1 ;
a + 1 ;
a + 1 ;
a + 1 ;
a + 1 ;
a + 1 ;
a + 1 ;

(a + 1) · x + (a + 1), x + 1
[(a · x) + x] + (a + 1), x + 1
[((a · x) + x) + a] + 1, x + 1
[((a · x) + a) + x] + 1, x + 1
[(a · x) + a] + (x + 1), x + 1
[(x · a) + a] + (x + 1), x + 1
(x + 1) · (a + 1), x + 1

a + 1, a + 1 ; x + 1, x + 1

Of course we can prove that x; x·a+x·b, a+b because of commutativity. We now turn to associativity

for the product. If a, b; a · x, x · b then,

a ; a · [(x + 1) · b], (x + 1) · b
a ; a · [(x · b) + b], (x + 1) · b
a ; a · (x · b) + a · b, (x + 1) · b
(a · x) · b + a · b, (x + 1) · b
a ;
[(a · x) + a] · b, (x + 1) · b
a ;
a, b ; a · (x + 1), (x + 1) · b

Similar proofs hold for x ≤ 0. That is, we are able to prove that if the properties hold for x, they

also hold for x − 1.

Dual Orders

The main concept of a ratio is that of comparing two relations. Therefore, we will take a more general
view, by deﬁning an order on arrows of Z× Z. We will carry out a construction of two ordered systems,
seperately, and then we will combine them. This process will be iterated three times; until we have
a satisfactory system. At which point in time we will close out the construction by deﬁning the two
resulting systems as the same.

We build a new system by taking away, from Z, all the objects x < 0, and relations of such objects.
This new system is N0. If we take away the object of operation 0 from N0, we are left with the system N.
The notation used here is a convenience in representation of arrows of the cartesian products; a →× c

7. RATIONAL SYSTEMS
51
c if a ≤ b. The order with respect
c ≤ b
c. An order will be deﬁned for the c-objects of N × N; make a
is a
c ≤ a
to the target objects is a bit diﬀerent. We say d ≤ c if and only if a
d. The ﬁrst order is represented
by N† := N × {c}. The second is N† := {a} →× N, for any 0 < a, c.

Proposition 7.2. The orders N† and N† are dual; explicitly N†, (N†)op; (N†)op, N†. Therefore, there is a
contravariant isomorphism N† → N†.

Proof. If we hold the target ﬁxed, then there is an order bijectivity to N. In the case we hold ﬁxed the
source, the resulting order is dual to N.

We will give the contravariant functor, to be more precise, and better understand the situation. Let

N† := N×{c} and N† := {a}×N. Then we make the object function x

c ≤ y

c (cid:55)→ a

y ≤ a
x.

x. For arrows, x

c (cid:55)→ a

In a similar manner, we form the system −N0, where we now take away the objects x > 0 and
relations of every x > 0. Notice that the systems N† are order bijective with −N. What we want then, is
to deﬁne a partial order −N × N which is dual to N × N. Consider a functor d : −N × N → N × N. The
c. This
object function is deﬁned as d
deﬁnes a partial order that is dual to the order of N × N because we have deﬁned the order in terms of a
contravariant functor.

c. So, we deﬁne the arrow function d(−a

c ≤ −b

(cid:16)−a

d ≤ a

d ) := b

:= a

(cid:17)

c

−∞ → ···

−∞ → ···

−∞ → ···

1

1 → 4
1 → 3
1 → 2
1 → 1
1 → 0
1 → −1
1 → −2
1 → −3
−4
↑
↑
↑
(cid:108)
↓
↓
↓
↓
↑
2 → −3
2 → 4
2 → 3
2 → 2
2 → 1
2 → 0
2 → −1
2 → −2
−4
↓
↓
↓
↓
(cid:108)
↑
↑
↑
↑
3 → 4
3 → 3
3 → 2
3 → 1
3 → 0
3 → −1
3 → −2
3 → −3
−4
...
...
...
...
...
...
...
...
...

2

3

··· → ∞

··· → ∞

.(II.4)

··· → ∞

We combine the two systems already formed, into one system, represented above. We give a partial
c, for every 0 < a, c.
x := 0, for every x in N. Said diﬀerently, any order Z × {x} is a partial order

order Q†, with O|Q† := O|Z × N. We do this in such a manner that −a
To achieve this, we deﬁne 0
generated by a discrete number system, for 0 < x.

c < 0 and 0 < a

52

−∞ ↔ ···

−∞ → ···

−∞ → ···

−∞ → ···

−∞ → ···

∞ ← ···

∞ ← ···

∞ ← ···

∞ ← ···

∞ ↔ ···

CHAPTER II. CATEGORY

1

0

1

0

0 ↔ 2
0 ↔ 4
0 ↔ 3
0 ↔ −3
0 ↔ −1
0 ↔ −2
−4
↑
↑
↑
↑
↓
↓
↓
↓
1 → 4
1 → 3
1 → 2
1 → 1
1 → 0
1 → −1
1 → −2
1 → −3
−4
↑
↑
↑
(cid:108)
↓
↓
↓
↑
↓
2 → −3
2 → −2
2 → −1
2 → 0
2 → 1
2 → 2
2 → 3
2 → 4
−4
↑
↑
↑
↑
(cid:108)
↓
↓
↓
↓
3 → −3
3 → −2
3 → −1
3 → 0
3 → 1
3 → 2
3 → 3
3 → 4
−4
↑
↑
↑
↑
(cid:108)
↓
↓
↓
↓
4 → 4
4 → 3
4 → 2
4 → 1
4 → 0
4 → −1
4 → −2
4 → −3
−4
...
...
...
...
...
...
...
...
...
↑
↑
↑
↑
(cid:108)
↓
↓
↓
↓

3

4

2

··· ↔ ∞

··· → ∞

··· → ∞

··· → ∞

··· → ∞

0
↓

0
↓

0
↓

0
↓

0
(cid:108)

0
↑

0
↑

0
↑

0
↑

.(II.5)

...

...

...

...

...

...

↓

↑

↑

↑

(cid:108)

↓

↓

↓

...
...
−4−4 ← −3−4 ← −2−4 ← −1−4 ← 0−4 ← 1−4 ← 2−4 ← 3−4 ← 4−4
↑
↓
−4−3 ← −3−3 ← −2−3 ← −1−3 ← 0−3 ← 1−3 ← 2−3 ← 3−3 ← 4−3
↑
↓
−4−2 ← −3−2 ← −2−2 ← −1−2 ← 0−2 ← 1−2 ← 2−2 ← 3−2 ← 4−2
↓
↑
−4−1 ← −3−1 ← −2−1 ← −1−1 ← 0−1 ← 1−1 ← 2−1 ← 3−1 ← 4−1
↓
↓
↓
↓
↑
↑
↑
↑
0 ↔ −4
0 ↔ −3
0 ↔ 1
0 ↔ 2
0 ↔ 3
0 ↔ −2
−1

↓

↓

↓

↓

(cid:108)

(cid:108)

↑

↑

↑

↑

↓

...

↑

↑

4

0

0

··· ← −∞

··· ← −∞

··· ← −∞

··· ← −∞

··· ↔ −∞

7. RATIONAL SYSTEMS

53

An extended rational system is any collection of objects such that the order between them is given
by (II.5). The objects that are connected to ∞, or −∞, by double arrows, will all be denoted by ∞, or
−∞. If the collection of objects does not include the objects ∞,−∞, then the system is simply rational.
We will call the objects of such systems, rationals. Our objects −∞, +∞ are comparable in the order
but not so much in the operations. The object 0
0 is not comparable even in the order; the reader may
closely study (II.5) to see that there is no convenient deﬁnition.

Involution

O := O|Z×−N. There is an order bijectivity Q† → Q†.
The bottom part of the system (II.5) is Q†, and Q†
We shall prove that they are also dual orders. This means that (II.5) is the combination of two dual
systems that are actually the same system. Thus, in this case we can consider the simpliﬁed version
(II.4), or its dual, because it is self dual.
−a−c. The function p has the same
x−c. Also, r1, r2 : N0 × N, N0 × −N → −N0 × N,−N0 × −N such that
c (cid:55)→p
domain and and image, but x
x (cid:55)→r
−a
for any integer x, we have a
x .

Consider the bijective function q : Q† → Q† that sends a

c (cid:55)→q

Proposition 7.3. The function q is a two part function

q|N0×N = r2 ◦ p|N0×N = p|−N0×N ◦ r1
2 ◦ p|−N0×N = p|N0×N ◦ r−1
q|−N0×N = r−1
1 .

In the following proposition we are saying that p establishes an order bijectivity Q†, (Q†)op; (Q†)op, Q†.

On the other hand, q establishes an order bijectivity Q†, Q†; (Q†)op, (Q†)op.
Proposition 7.4. q : Q† → Q† is an order bijectivity. What is more, both systems are dual orders if we
consider the function p.

We can say, more concisely, that p is a bijective function from one collection onto itself, with the
interesting characteristic that its action on a rational number, with respect to the order, is that of taking
opposite order. Given our equivalence relation, we see that p and r are the same function −, that gives
the inverse under +. The interesting thing to notice is that if we reverse the arrows two times, we have
the same order; that is to say, the opposite, of the opposite order, is the original order. This is why
we have an order bijectivity q, after applying the function − two times (once with the function p and
once with the function r). This is a special case of something more general. An involution is a function
f : O → O such that f x; x, f which means f ( f x) is x. We will encounter many kinds of involutions.

Product for Rational Systems

Presently, we will deﬁne a relation for determining when we will regard two arrows of Z × Z as the
same. This of course is given in terms of the product for integers. The arrows a →× c and b →× d
are = comparable if a, c; b, d in terms of the product; we will say a →× c = b →× d. This has an
important meaning in terms of the notation: a, c; b, d is used for stating 1) a · d and b · c result in the
same object of operation, and 2) a
d. First, we observe that a, c; a, c, is obtained from a, a; c, c by
c
using commutativity. Second, we see that a, c; b, d can be re-written as b, d; a, c. We will later see that

= b

54

CHAPTER II. CATEGORY

transitivity holds, because in terms of the operation we have a, c; b, d and b, d; e, f which we will prove
implies a, c; e, f . Some arrows in the equivalence are −a
= a−c. This is proven by the rules for product:

c

(−a) · (−c),−c
[(−1) · a] · [(−1) · c],−c
[(−1 · a) · −1] · c,−c
[a · (−1 · −1)] · c,−c

−a ;
−a ;
−a ;
−a ;
−a ; a · c,−c
−a, c ; a,−c.

b is b
a.

We turn to deﬁne the product for the objects of the dual systems in (II.4); notice we are excluding
d. We ﬁrst have to ﬁnd the unit for this
b and a

objects of the form x
operation. It is not diﬃcult to verify 1

c; a·b
c·d , b
1 is unit. We see 0; 0, a

0. We deﬁne the operation by a

Application of associativity, commutativity for integers, and the relation of equality deﬁned above,
allow us to prove a
x. Proofs for associativity and commutativity are a direct application of the
deﬁntion of product for rationals. So now, we turn to ﬁnd inverse, under the product. We readily verify
that the inverse of a

b; 0, 0.

c; a

c , x

= x

= a·x

b·y, then c
d
d · f = e

There is one more thing we wish to prove in this section. That is, if we multiply a

b by any two
rationals that are the same with respect to =, then the results are the same. That is, given c
y, we
have to verify (a · c) · (b · y) and (a · x) · (b · d) are the same object. These expressions are rewritten as
d
(a · b) · (c · y) and (a · b) · (x · d) which are both the same, since c · y and x · d are the same object. Also,
if a·c
y. Let us now return to the matter of transitivty for the relation = deﬁned above.
b·d
This means we have the equalities a
f . The equalities give
c
c · f = b
a
Theorem 7.5. The system Q, with rational numbers as objects of operation, is a commutative group
under the product. As with the sum, the product is also a functor; in this case · : Q → QFQ.
Proof. The condition ·,·;◦(·y),·y is the statement that ·(x·y) is the same function as ·x◦·y. Again, this is
proven by applying commutativity once to the expression a, x; a· y, y· x, of associativity for the product.
The result is a, x; a · y, x · y.

f , and we wish to prove a
c

f · f = e.

d and b
d

= b

= e

= e

= x

Sum for Rational Systems
Now, given that arrows of the form a
rationals is deﬁned in the last step

0 are not rationals, we do not deﬁne the sum for these. The sum for

a
c
a
c
a
c
a
c
a
c

;

;

;

;

;

+

b
a
b
d ,
d
c
b
· c
b
a
· d
+
c ,
d
d
c
d
b · c
a · d
b
d · c ,
c · d
d
a · d
b · c
b
c · d ,
c · d
d
a · d + b · c
b
d .
,

c · d

+

+

7. RATIONAL SYSTEMS

55

Once we multiply by c
and not by a
associativity for this operation, we proceed as follows, ﬁrst with commutativity:

d, the rest is straightforward. But why did we choose to multiply by that,
b? Because we have guarantee that c, d are both not 0. To prove commutativity and

a and b

c and d

a
c
a
c
a
c
a
c

a
c ,

;

;

;

;

b
d
b
d

,

,

a · d + b · c
b · c + a · d

c · d
d · c
b
a
c ,
d
b
d .

+

b
d
b
d ,

For associativity,

a
c
a
c
a
c
a
c
a
c
a
c
a
c
b
d

;

;

;

;

;

;

;

;

a
c ,

x · d + b · y

,

+

+

b
d

x
y · d
y
c · (y · d)

a
c
a · (y · d) + (x · d + b · y) · c
b
d
a · (y · d) + [(x · d) · c + (b · y) · c]
b · (y · c) + [(x · c) · d + (a · y) · d]

x
y

+

,

x
y
x
y

+

+

b
d
b
d

,

,

+

c · (d · y)
(cid:33)
d · (y · c)
(cid:33)
b
x
d
y
x
b
d
y
b
x
y
d

+

+

,

,

a
c
x
y
b
d ,
b
d .

+

+

(cid:33)

x
y

+

(cid:32) x
(cid:32)a

y

c
x
y
x
y ,

b
d
b
d

(cid:32)a

c
a
c

+

+

+

+

+

As before, the object 0 which absorbs with product, serves as unit for sum. This is veriﬁed by

a
c
a
c
a
c
a
c
a
c

;

;

;

;

;

0
x

,

+

0
0
x ,
x
c · x
0
x
0
x

a
c
a · x + 0 · c
a · x
c · x ,
· x
a
x ,
c
a
0
x .
c ,

In light of the fact that we consider 0
by 0, and we verify that objects dual with respect to the unit 0, are objects a
equivalence relation makes a

x to be the same element for all x, we represent each such rational
b . Of course, our

b and a−b dual. In the same manner, −a−b is dual with −a

b and −a
b and a−b.

56

CHAPTER II. CATEGORY

Embedding

1 · y

c ≤ b

1 and x·y

1 are the same.

1 is x+y
+ y
c·d ≤ b·c
d if and only if a·d
d·c

1. It is not diﬃcult to prove ι is an isomorphism
1 . This is also

Deﬁne a bijective function ι : Z → Z×{1} such that x (cid:55)→ x
for the operations sum and product. We follow the deﬁnition of sum to prove x
1
true for the product because x
= b·c
means that a · d ≤ b · c if and only if we have c · d > 0, and b · c ≤ a · d if and only if c · d < 0.

The order for objects of operation, in Q, is deﬁned by a
c·d. This
In this case, ι is a functor for Z≤ as a partial order and not an algebraic category. Additionally,
we will prove that the system Q is a natural order. We know exactly one arrow is assigned to any two
objects of Q; this is given from the deﬁnition. We must prove transitivity for the order of Q.
c ≤ b
Proposition 7.6. a
d·c; this is the deﬁnition of the order in Q≤. Then, c · d < 0 if
c ≤ b
Proof. We have a
and only if b · c ≤ a · d.
First, we take x > 0 which means (c · x) · d = d · (c · x) = (c · d) · x < 0. Since b · c ≤ a · d we also
have (b · c) · x ≤ (a · d) · x which is the same as b · (c · x) ≤ (a · x) · d. We conlude that (a·x)·d
Now we let x < 0 and we get 0 < (c · x) · d = d · (c · x) = (c · d) · x. Here, x reverses inequalities, so
that (a · x) · d ≤ b · (c · x). The conclusion is the same.
The reader can similarly treat the case for c · d > 0.

d ⇐⇒ a
d if and only if a·d

(c·x)·d ≤ b·(c·x)
d·(c·x).

c·d ≤ b·c

x ≤ b

d

c

x

Proposition 7.7.

c ≤ b
c ≤ b

d ⇐⇒ a
d ⇐⇒ b

d

c

x

d

y ≤ b
y ≤ a

x

c

x
y

x
y

1) If x

2) If x

y > 0, then a
y < 0, then a

Proof. Suppose c · y, d · y < 0 which means 0 < (c · y) · (d · y) and 0 < c · d. If a
d we then have
y we can easily see 0 < x · y. This means that (a · x) · (d · y) ≤ (b · x) · (c · y) and
a · d ≤ b · c. From 0 < x
c·y ≤ b·x
we may conclude a·x
d·y.
Let us make 0 < d · y so that (c · y) · (d · y) < 0 and c · d < 0. Hence, (b · x) · (c · y) ≤ (a · x) · (d · y).

c ≤ b

c ≤ b

The conclusion is the same as before. The reader may follow a similar proof for 2).
Proposition 7.8. The order of Q is transitive.
f·d. Let 0 < c · d and f · d < 0, then
f , we have a·d
Proof. Supposing a
a · d ≤ b · c and e · d ≤ b · f . We also have c · f < 0. The inequality a · d ≤ b · c is the equivalent
(a· f )·(d· f ) ≤ (b· f )·(c· f ). The inequality e·d ≤ b· f is true if and only if (b· f )·(c· f ) ≤ (e·d)·(c· f ).
We apply transitivity for Z≤, and get (a· f )· (d · f ) ≤ (e· d)· (c· f ) = (e· c)· (d · f ). This last expression
is the same as e · c ≤ a · f . Since c · f < 0 we conclude a
The remainding cases 1) c · d < 0, and f · d > 0, 2) 0 < c · d, f · d, 3) c · d, f · d < 0. Can be treated

d·c and b· f

d· f ≤ e·d

c·d ≤ b·c

d ≤ e

c ≤ e
f .

in a similar manner.
Theorem 7.9. Q is a natural order and there is an embedding of Z into Q for +,·,≤.

We can say more about the order of the rationals. Because, we have already seen that the orders
of (III.2) are dual. Daulity appears in many forms in Q, but the real duality here is what we did at
the beginning by deﬁning columns dually to rows at the beginning of the section Dual Orders. In the
right side of system (III.2), we have a system such that rows and columns are dual. The rows are order
isomorphic to N and the columns are dual to N.

Set Theory

In the foregoing, and to maintain the rigor of mathematics, we will use the ⇒ relation that is representative
of implication. We will not use it in a rigorous sense as of yet; for now ⇒ is representative for i f . We
will say the collection of all objects is Obj. Consider the system Obj∈ whose collection of objects is
Obj; the relations of the system are x ∈ A if and only if A is a collection and x is an object of A. We
say x is element o f A; of course (cid:60) will be used in the opposite manner in such cases x is not element of
A. Two collections A, B are related A ⊆ B if for every arrow x ∈ A, we also have x ∈ B. If the arrow ⊆
has been ruled out to be reﬂexive we will write A ⊂ B. In case we have A ⊆ B and B ⊆ A we will say
A = B; this is saying that the arrow between A, B is double ended and when that happens we regard the
two collections to be the same.

Any collection or object is said to be normal if it is not an elment of itself. First of all, we have
a case because the collection of all collections is an object in itself. Furthermore, any collection can
be turned into a normal collection; if O ∈ O we make the new collection O by taking away the object
O. Now consider the collection of normal objects, denote it by R. This collection is elusive in nature.
Suppose R ∈ R, then R (cid:60) R. If R (cid:60) R, then by deﬁnition, R ∈ R. We cannot establish if this collection
contains itself or not; both conclusions are simultaneously true and, therefore, simultaneously not true.
Let U be a normal subcollection of Obj that will be called the universe of sets. We will use V as
the collection which is obtained from U by adding one object: U. If two sets are related A ⊆ B, we
say A is a subset of B. If x ∈ X, for some set X ∈ X, we say X is a family. The union of a family is the

collection of objects that consists of objects that belong to any member of the family; we write(cid:83)X.

The collection of all subsets of A is PA.
Deﬁnition 8. The following poperties deﬁne U.

1) A|Z ⊆ U
2) x ∈ A ∈ U ⇒ x ∈ U
3) A ⊆ B ∈ U ⇒ A ∈ U
4) A, B ∈ U ⇒ A →× B ∈ U
5) A ∈ U ⇒ PA ∈ U

6) X ∈ U ⇒(cid:83)X ∈ U

7) If a function f : A → B ⊆ U is onto and A ∈ U, then B ∈ U.
We ask 3) and 7) hold because we do not want sets to have too many objects; we want to keep them

small so as to distinguish them from arbitrary collections, which can be unimaginably large.

57

58
Deﬁnition 9. A set is any object of U. A set function is any function f : A → B, where A, B ∈ U.

CHAPTER III. SET THEORY

We see that the properties deﬁning the universe allow us to ﬁnd that any set function is an object in
the universe because f ⊆ A →× B. This allows us to deﬁne a category where the collection of objects
is U and the collection of arrows is the set of all set functions. This is the category of small sets and
it will be written as Set. A set A may be represented by the notation A = {x}x∈A. If, for example a set
consists of two objects, we then have A = {x, y} = {y, x}. A set that consists of one element is called a
singleton; if the element of the singleton is x, then the singleton is {x}.

Set Operations

First Generation

Proposition 8.1. For any A, B, C ∈ V and X ⊆ Y ∈ V we verify

Union Take A, B ∈ V. We will establish(cid:83) as an operation V → V fV. When we are considering
such a union, we will write A ∪ B in place of(cid:83){A, B}.
1) (cid:83)X ⊆(cid:83)Y
Notice that we have a special case for 1); namely that A ⊆(cid:83)X, for every A ∈ X.

2) A ∪ B = B ∪ A
3) A ∪ (B ∪ C) = (A ∪ B) ∪ C = A ∪ B ∪ C.

Diﬀerence The union has an inverse operation, just as the sum has. The function ∪B adds the
objects of B to A. Well, in view that systems are created by adding and taking objects, it is natural to
give a function −B that takes the objects of B from A. Of course, A − B ⊆ A.
It is easily veriﬁed that the diﬀerence is not symmetric, just as the operation − is not symmetric; we
recall that a − b and b − a are not the same. Also, the diﬀerence is not associative, just as (a − b) − c is
not the same as a − (b − c):

(A − B) − C = A − (B ∪ C)
A − (B − C) = (A − B) ∪ [A − (A − C)].

To reason this, let us examine the expression A − (A − C). It is the collection of objects obtained
by taking from A the objects of A − C ⊆ A. We are leaving only those objects that are in C. That is,
x ∈ A − (A − C) if and only if x is in A and C because A − C consists of all objects in A and not in C.

Second Generation
Intersection In set theory there will be an analogy between sum and product. The corresponding

operations to sum and product, here, are union and intersection.

In general we say x ∈(cid:84)X if and only if x ∈ A, for every A ∈ X.

A ∩ B = A − (A − B).

8. SET OPERATIONS
Proposition 8.2. For any A, B, C ∈ V and X ⊆ Y ∈ V we verify

1) (cid:84)Y ⊆(cid:84)X

2) A ∩ B = B ∩ A
3) A ∩ (B ∩ C) = (A ∩ B) ∩ C = A ∩ B ∩ C.

And we see that 1) gives for a special case;(cid:84)X ⊆ A, for every A ∈ X.

59

Complement Now, we consider the function that is left operation U−. The image of A may be

represented by Ac.
Proposition 8.3. For any A ∈ V we have

1) A ∪ Ac = U

2) (Ac)c = A
We see that 2) takes the form A = U − (U − A) = U ∩ A

Properties
Unit We now study the units of these operations, starting with the union. Notice that A ∪ B = A if
and only if B ⊆ A. Since ∅ is a subset of any set, we have found the unit of the union operation to be ∅.
If we consider the intersection, we see that A ∩ B = A − (A − B) = A if and only if A ⊆ B. We need
not look any further to ﬁnd the unit, U.
It is easily seen that A = A− B if and only if A ⊆ A− B and this is true if and only if ∅ = A−(A− B) =
A ∩ B. Thus, ∅ is a right unit for the diﬀerence. In the case of the left operation, we are unable to ﬁnd a
unit; clearly there is no set B such that B − A = A.

Inverse It is now desireable to ﬁnd the inverse set of A, for each of the operations. However, after
a quick inspection we see that this is impossible. For the union we must ﬁnd B such that A∪ B = ∅, and
for the intersection C must satisfy A ∩ C = U.
We will ﬁnd a way around this, but the developments here will not give us an inverse set, in the strict
sense. We will say A and A−1 are inverse sets for the union if A∪ A−1 = U. We say they are inverse sets
for intersection if A ∩ A−1 = ∅. We say that Ac is the exact inverse of A.

Other Representations We have an interesting consequence of our deﬁnition for the operations −

and ∩. Each of these operations takes away objects from the source and this is in such a way that

A = (A ∩ B) ∪ (A − B)
∅ = (A ∩ B) ∩ (A − B).

(III.1)

We have a similar decomposition for A ∪ B:

60

CHAPTER III. SET THEORY

A ∪ B = A ∪ (B − A)
∅ = A ∩ (B − A).

(III.2)

We also have

A − B = A − (U − Bc)

= (A − U) ∪ [A − (A − Bc)]
= A − (A − Bc)
= A ∩ Bc

(III.3)
We are stating that the functions −A,∩Ac are the same, for any A ∈ U. Of course we can also say

A ∩ B = A − Bc

Distributions In the foregoing we will accept a notation that will allow us to express some general

relations for set operations:

(cid:91)X =
(cid:92)X =

(cid:91)
(cid:92)

A∈X

A∈X

A

A

Of course there is a natural distribution for the union and intersection; as we had mentioned, there

would be a clear parallelism with sum and product. However, the distribution here is both ways:

Now we give the distributions that involve the diﬀerence.

Naturally, the complement has a distribution rule, following that it is a special case of diﬀerence.

(III.4)

(III.5)

B∈X

B∈X

A ∪(cid:92)
A ∩(cid:91)
A −(cid:91)
A −(cid:92)
U −(cid:91)
U −(cid:92)

B∈X

B∈X

B∈X

B∈X

B =

B =

B =

B =

B =

B =

(cid:92)
(cid:91)

B∈X

B∈X

(cid:92)
(cid:91)

B∈X

B∈X

(cid:92)
(cid:91)

B∈X

B∈X

(A ∪ B)

(A ∩ B)

(A − B)

(A − B)

(U − B)

(U − B)

9. CATEGORIES

This is re-written as,

61

(III.6)

(III.7)

Ac

Ac

=

=

A∈X

(cid:92)
(cid:91)

c
c
B ⊆ (cid:91)
B ⊆ (cid:92)

A∈X

A

A

A∈X

A∈X

(cid:91)
(cid:92)
A −(cid:91)
A −(cid:92)

B∈Y

B∈Y

(cid:91)
(cid:92)

A∈X

(X − Y)

(X − Y).

These last expressions are the laws of DeMorgan. The following relations are not diﬃcult to prove.

A∈X

Categories

We have constructed the category of sets Set, and the main objective in this section is to give other
descriptions of sets in terms of categories. That is, any set can be viewed as either a collection category
or a partial order.

Collection Category

Unless it is otherwise speciﬁed, we deﬁne {{A}} := {{a}}a∈A, for any set A. We will build a category A
whose collection of c-objects is the family {{A}}. Consider a selection function for {{A}}; this function
must send every set {a} into the object a. We have exactly one selection function f and it is deﬁned by
Dom f = {{A}}, Range f = A and {a} (cid:55)→ f a. This is clearly a category; the unit arrow of each object is
the only arrow corresponding to it.
Let A, B be two collection categories and suppose there is an operation ∗ on each of the collections.
We have a natural way of deﬁning a functor F : A → B, given a function f
: A → B such that
f, f ;∗ f x,∗x. When considering the collection category of a power set we will write PA.

Partial Order, Under Inclusion

Let us consider the partial order deﬁned on collection V; we form a category Set⊆ where the objects
are ordered by inclusion. In other words, arrows are A ⊆ B. We see that we have a category because
A ⊆ A and if A ⊆ B ⊆ C, then A ⊆ C. Recall that in a partial order we are dealing with non-discernible
arrows. In light of this, associativity of the composition holds. We note that a partial order may have
objects which are not related; and in this order, that is the case. There are no arrows between {1} and
{2}, for example. Given a set A, we can identify it with a partial order, where the collection of objects
is PA; this order is a simpliﬁed version of Set⊆, and we denote it by PA.

62

Concrete Category

CHAPTER III. SET THEORY

We had the idea that given a discrete number system, there is a category such that the objects of the
system are automorphisms of the category. After all, categories are quite large. So, we will consider
the universe of sets in order to formailze the concept of a category whose arrows are functions. A
category C is concrete if we can provide a faithful functor C : C → Set. We are sending the c-
objects of the category into sets, while the arrows are sent into functions. Parallel arrows are sent into
diﬀerent functions of the same form. There have been several instances in which we have used arrows
of categories as functions of one component. We have really been trying to represent the arrows as
functions to deﬁne an equality of compositions in terms of natural pair of functions. A particular case
was the second request in the deﬁnition of functors. What happens if the category is concrete?

We are giving a way of studying absract categories in terms of a well deﬁned category. We had
previously said that some algebraic categories can be seen as consisting of a category as c-object, and
automorphisms of that category as arrows. For a concrete category, all the c-objects x, y, z, ... can be seen
as sets, and all the arrows can be seen as set functions, in such a way that the transformation is a functor.
This means we will not study a general abstract category with objects and arrows. We are going to study
a collection of domains and ranges and set functions. This is a concrete concept because sets are well
deﬁned. The composition in set functions can be described as an operation ◦ : A|Set → A|Set fA|Set
such that f (cid:55)→◦ ◦ f , where g (cid:55)→◦ f g ◦ f .

Hom Set Recall {a → c} is the collection of arrows in C, such that a is source and c is target. Also,
we have deﬁned {a →} and {→ c} as the collections of arrows from a, and arrows into c, respectively.
If {a → c} is a set, for every pair of c-objects in the category, we say C has all Hom sets.
Deﬁnition 10. Let x be any c-object of C, and deﬁne the contravariant functor R(cid:110)
x : C → Set, where
a (cid:55)→ {a → x}; every arrow f : a → c is sent into the set function ∗ f : {c → x} → {a → x}, of Hom sets.
Deﬁne the covariant functor Lx : C → Set such that a (cid:55)→ {x → a}, so that f is sent into a set function
f∗ : {x → a} → {x → c}.
Lemma I. Let F : C1×C2 → D be a functor. Then, every arrow f : a → c, in C1, determines a natural
transfomation τ f : Fa → Fc that sends x (cid:55)→ F( f, 1x). The functors are of the form Fa, Fc : C2 → D.
A similar result can be formulated if C2 takes the place of C1.
Proof. The functors of the natural transformation are deﬁned by the object functions Fax := F(a, x)
and Fcx := F(c, x). Let g be an arrow in C2, then the arrow functions are Fag := F(1a, g) and
Fcg := F(1c, g). We will show τy, τx; Fcg, Fag for any arrow g : x → y in C2.

τy ; τy ∗ Fag, Fag
τy ; F( f, 1y) ∗ F(1a, g), Fag
τy ; F( f ∗ 1a, 1y ∗ g), Fag
τy ; F(1c ∗ f, g ∗ 1x), Fag
τy ; F(1c, g) ∗ F( f, 1x), Fag
τy ; Fcg ∗ τx, Fag

τy, τx ; Fcg, Fag.

9. CATEGORIES
63
Lemma II. Let C1,C2,D be categories. For every x in C1, and y in C2, let Rx, Ly : C2,C1 → D be
functors such that y, Ly; x, Rx. There exists a functor F : C1 × C2 → D, such that Fx is Rx and Fy is
Ly, if and only if for every arrow f →× g : a →× b −→ c → d, in C1 × C2, we verify

We deﬁne F( f, g) := Ld f ∗ Rag, and F(a, b) := Rab.
Proof. We will ﬁrst suppose the condition (III.8). First of all, 1D ◦ FO is the same as FA ◦ 1C1×C2:

Ld f, Lb f ; Rcg, Rag.

(III.8)

Given an arrow f →× g : a →× b −→ c →× d, we have F( f, g) : F(a, b) → F(c, d). To prove this,
notice Rag, Ld f : Rab, Lda → Rad, Ldc. Since d, Ld; a, Ra and d, Ld; c, Rc are true, we may conlcude
F( f, g) : Fab → Rcd. We move on to prove the third condition of functors. Let h : c → x and i : d → y,

(1D ◦ FO)(a →× b), 1D ◦ FO
a →× b ;
1D(F(a, b)), 1D ◦ FO
a →× b ;
a →× b ;
1D(Rab), 1D ◦ FO
a →× b ; 1(Rab), 1D ◦ FO
a →× b ; 1(Rab) ∗ 1(Rab), 1D ◦ FO
a →× b ; 1(Lba) ∗ 1(Rab), 1D ◦ FO
a →× b ; Lb1a ∗ Ra1b, 1D ◦ FO
a →× b ; FA(1a, 1b), 1D ◦ FO
a →× b ;

(FA ◦ 1C1×C2)(a →× b), 1D ◦ FO.

h →× i ∗ f →× g ; F(h ∗ f, i ∗ g), F
h →× i ∗ f →× g ; Ly(h ∗ f ) ∗ Ra(i ∗ g), F
h →× i ∗ f →× g ; Lyh ∗ (Ly f ∗ Rai) ∗ Rag, F
h →× i ∗ f →× g ; Lyh ∗ F( f, i) ∗ Rag, F
h →× i ∗ f →× g ; Lyh ∗ (Rci ∗ Ld f ) ∗ Rag, F
h →× i ∗ f →× g ;
(Lyh ∗ Rci) ∗ (Ld f ∗ Rag), F
h →× i ∗ f →× g ; F(h, i) ∗ F( f, g), F
h →× i ∗ f →× g ; F(h →× i) ∗ F( f →× g), F

Finally, we must show Fx is the same functor as Rx, and Fy is the same as Ly. The observation is
trivial for the object function; Fxy is F(x, y), whom we have deﬁned as Rxy. This implies that Lyx is
Fyx := F(x, y). For the arrow functions, we have

i ∗ g ; Fx(i ∗ g), Fx
i ∗ g ; F(1x, i ∗ g), Fx
i ∗ g ; Ly1x ∗ Rx(i ∗ g), Fx
i ∗ g ; 1(Lyx) ∗ Rx(i ∗ g), Fx
i ∗ g ; 1(Rxy) ∗ Rx(i ∗ g), Fx
i ∗ g ; Rx1y ∗ Rx(i ∗ g), Fx
i ∗ g ; Rx[1y ∗ (i ∗ g)], Fx
i ∗ g ; Rx(i ∗ g), Fx.

64

CHAPTER III. SET THEORY

h ∗ f
h ∗ f
h ∗ f
h ∗ f
h ∗ f
h ∗ f
h ∗ f
h ∗ f

; Fy(h ∗ f ), Fy
; F(h ∗ f, 1y), Fx
; Rx(1y) ∗ Ly(h ∗ f ), Fy
; 1(Rxy) ∗ Ly(h ∗ f ), Fy
; 1(Lyx) ∗ Ly(h ∗ f ), Fy
; Ly1x ∗ Ly(h ∗ f ), Fy
; Ly[1x ∗ (h ∗ f )], Fy
; Ly(h ∗ f ), Fy.

Now, suppose the contrary and prove (III.8)

Ld f
Ld f
Ld f
Ld f
Ld f
Ld f
Ld f
Ld f

; Ld f ∗ Rag, Rag
; Fd f ∗ Fag, Rag
; F( f, 1d) ∗ F(1a, g), Rag
; F( f ∗ 1a, 1d ∗ g), Rag
; F(1c ∗ f, g ∗ 1b), Rag
; F(1c, g) ∗ F( f, 1b), Rag
; Fcg ∗ Fb f, Rag
; Rcg ∗ Lb f, Rag.

The two functors that constitute Hom, are called the contravariant and covariant Hom functors.

Theorem 9.1. Given any category with all Hom sets, we can form a bifunctor Hom : C × C → Set;
referred to as the Hom bifunctor.
Given an arrow f : a → c in C, we have natural transformations f † : Lc → La and f† : R(cid:110)
Proof. For every x in C, there are covariant functors Rx : Cop → Set and Lx : C → Set; the functor
xg)op. Notice that Ld f is the function f∗ : {d → a} → {d → c} that
Rx is deﬁned by Rx(gop) := (R(cid:110)
sends h : d → a into f ∗ h. On the other hand, Ra(gop) is (R(cid:110)
ag)op : {b → a} → {d → a} that sends
iop : b →op a into iop ∗ gop. Therefore, Ld f ◦ Ra(gop) is the function ( f∗) ◦ (∗gop) : {b → a} → {d → c};
the arrow function sends i into f ∗ (iop ∗ gop), which is f ∗ (g ∗ i).
One can just as easily prove Rc(gop) ◦ Lb f is the function (∗gop) ◦ ( f∗) : {b → a} → {d → c}
that sends i into ( f ∗ iop) ∗ gop which is f ∗ (iop ∗ gop). Using the second lemma, we ﬁnd a functor
F : Cop × C → Set; consequently, we have a bifunctor Hom : C × C → Set.
Finally, apply the ﬁrst lemma to the functor F. For any arrow f op : a →op c in Cop, we have a
natural transformation f † : Lc → La. The reader can ﬁnd f† : Ra → Rc in the same way.

a → R(cid:110)
c .

Yoneda’s Lemma Here we will see that the construction provided for the natural numbers is not
a coincidince.
It is a speciﬁc application of the following result that generalizes even results from
group theory (Cayley’s Theorem). We will try to see why Yoneda’s Lemma generalizes this result. The
Yoneda embedding is provided as a corollary to the lemma and it enables us to prove Cayley’s theorem.
Let E : Cat(C, Set) × C → Set, be deﬁned by E(C, x) := Cx as object function. If τ →× f is an
arrow in the domain, with τ : C → D as a natural transformation and f : a → c, then the arrow function
of E is deﬁned by the element given in τc, τa; D f, C f . That is to say, E(τ, f ) := τc ◦ C f .

9. CATEGORIES

65
Now let N : Cat(C, Set) × C → Set such that N(C, x) := Nat(Lx, C). Suppose C →× a and D →× c
are c-objects in the domain such that τ : C → D and f : a → c. If we want for N to be a functor, we
have to give an arrow function that sends τ →× f into a function N(τ, f ) : Nat(La, C) → Nat(Lc, D).
Take any α in Nat(La, C) and deﬁne N(τ, f )α := τ · α · f †; this is the vertical composition of natural
transformations where we recall f † : Lc → La.

We say that a natural transformation is a natural isomorphism if all the components τx are isomorphisms

of the category in the range of the functors. This serves as a natural transformation from each functor
to the other so that we can jump from one functor to the other and back.
Yoneda Lemma. Let a be any c-object in a category C, with all Hom sets.

1) Let C : C → Set be a functor, then there is a bijective function φCa : Nat(La, C) → Ca.
2) E, N are functors and the functions φCa are components of a natural isomorphism Φ : N → E.

Proof.

1) Let us deﬁne the function φ so that τ : La → C is transformed by τ (cid:55)→ τa(1a). We know τ
sends any c-object x, in C, into the function τx : {a → x} → Cx. This means τa(1a) is an
element of Ca. We also know that for any f : a → c, the relation τc, τa; C f, f∗ holds in terms of
composition of functions; recall La f is a function f∗ : {a → a} → {a → c}. Therefore, we may
say τc( f ∗ 1a) is the same as C f [τa(1a)]. If we use the notation for applying functions, we express
f ; C f [τa(1a)], τc. Let us suppose τ and σ are diﬀerent natural transformations in Nat(La, C); that
is, there exists an object c such that τc and σc are diﬀerent set functions. As a consequence, we
can give an arrow f ∈ {a → c} and we verify τc f (cid:44) σc f . Thus, C f (φτ) (cid:44) C f (φσ), which implies
φτ (cid:44) φσ, and we conlcude φ is monic.
Let x ∈ Ca, and deﬁne τx : O|C → A|Set such that τxc : {a → c} → Cc. The function τxc
transforms f (cid:55)→ C f (x). We will show this deﬁnes a natural transformation in Nat(La, C). Apply
the function τxc ◦ f∗ to an arrow g ∈ {a → a}:

(τxc ◦ f∗)g, τxc ◦ f ∗
g ;
g ; τxc( f ∗ g), τxc ◦ f ∗
g ; C( f ∗ g)(x), τxc ◦ f ∗
(C f ◦ Cg)(x), τxc ◦ f ∗
g ;
g ; C f [Cg(x)], τxc ◦ f ∗
g ; C f [τxa(g)], τxc ◦ f ∗
(C f ◦ τxa)g, τxc ◦ f ∗
g ;
(C f ◦ τxa)g, τxc ◦ f ∗ .
g ;

We have thus proven τxc, τxa; C f, La f and we conclude φ is bijective.

2) Now, we would like to show E, N are functors. We begin with E, verifying 1SetE(C, x) is the
identity function. The same results from sending C →× x into its unit arrow, and transforming
that with E; this results in (1Cx) ◦ (C1x), which is the composition of the identity function ICx
with itself. Take a c-object in the domain, say C →× a and D →× c, then the second condition of

66

CHAPTER III. SET THEORY
functors is given by E(τ, f ) := τc ◦ C f : Ca → Cc → Dc. The last condition is not diﬃcult to
prove either; let τ →× f and σ →× g be composable arrows in the domain:

σ →× g ∗ τ →× f
σ →× g ∗ τ →× f
σ →× g ∗ τ →× f
σ →× g ∗ τ →× f
σ →× g ∗ τ →× f
σ →× g ∗ τ →× f

; E(σ →× g ∗ τ →× f ), E
; E(σ · τ, g ∗ f ), E
(σ · τ)c ◦ C(g ∗ f ), E
;
; σc ◦ τc ◦ Cg ◦ C f, E
; σc ◦ Dg ◦ τb ◦ C f, E
; E(σ, g) ◦ E(τ, f ), E.

To show the ﬁrst condition of functros is valid for N, notice (1Set ◦ N)(C, x) results in the identity
function of Nat(Lx, C). On the other hand, if we apply N to the unit arrow of C →× x, we get a
function N(1C, 1x) : Nat(Lx, C) → Nat(Lx, C) such that α (cid:55)→ 1C · α · 1†
x is the natural
transformation 1Lx : Lx → Lx, we say 1) for functors is true. The second condition for N to
be a functor has been shown to be true, by construction. We are left to prove 3); we must show
N(σ · τ, g ∗ f ) is the same function as N(σ, g) ◦ N(τ, f ).

x. Since 1†

α ; N(σ · τ, g ∗ f )α, N(σ · τ, g ∗ f )
(σ · τ) · α · (g ∗ f )†
, N(σ · τ, g ∗ f )
α ;
(σ · τ) · α · ( f † · g†), N(σ · τ, g ∗ f )
α ;
α ; σ · (τ · α · f †) · g†
, N(σ · τ, g ∗ f )
α ; N(σ, g)(τ · α · f †), N(σ · τ, g ∗ f )
α ;

[N(σ, g) ◦ N(τ, f )]α, N(σ · τ, g ∗ f ).

[Φ(C, a) ◦ N(τ, f )]α, Φ(C, a) ◦ N(τ, f )

α ;
α ; φCa(τ · α · f †), Φ(C, a) ◦ N(τ, f )
α ;
α ;
α ;

[(τ · α · f †)b](1b), Φ(C, a) ◦ N(τ, f )
[(τ · α)b ◦ f †b](1b), Φ(C, a) ◦ N(τ, f )
[(τ · α)b] f, Φ(C, a) ◦ N(τ, f )

(τb ◦ αb) f, Φ(C, a) ◦ N(τ, f )
α ;
α ; τb(αb f ), Φ(C, a) ◦ N(τ, f )
α ; τb[C f (αa(1a))], Φ(C, a) ◦ N(τ, f )
(τb ◦ C f )(αa1a), Φ(C, a) ◦ N(τ, f )
α ;
α ; E(τ, f )(φCaα), Φ(C, a) ◦ N(τ, f )
α ; E(τ, f )[Φ(C, a)α], Φ(C, a) ◦ N(τ, f )
α ;

[E(τ, f ) ◦ Φ(C, a)]α, Φ(C, a) ◦ N(τ, f ).

Here, we are considering that for composable arrows f, g : a, b → b, c we have the natural
transfomations f † : Lb → La and g† : Lb → Lc.
Now we prove there is a natural transformation from Φ : N → E. To verify this, let τ →× f be
an arrow C →× a into D →× b and let α : La → C:

Since f † is a natural transformation that sends c-objects in C, into set functions, we know f †b is a
function {b →op b} → {b →op a}, so that f †b(1b) is deﬁned as f op ∗ 1op
b , which is f . We continue,

9. CATEGORIES

67

Notice we are using the fact that αb f is the same as C f [αa(1a)]. With this we have proven Φ is
natural. Now, we only need to notice that the components are bijective functions, to conclude Φ
is a natural isomorphism.

The result presented below has been proven above, for the most part; it is commonly known as the

Yoneda Embedding.
Corollary. There is a contravariant functor Y† : C → Cat(C, Set) such that Y†x := Lx. There is a
covariant functor Y† : C → Cat(Cop, Set) that makes Y†x := Rx. The functors Y† and Y† are full
embeddings, with the arrow functions f (cid:55)→Y† f † and f (cid:55)→Y† f†.
Proof. We only need to prove the arrow function is bijective. In the lemma, make C := Lb, so that we
have a bijective function φ : Nat(La, Lb) → Lba; this is a bijection {b → a} → Nat(La, Lb). Given any
arrow f , we know there is a natural transformation f † in Nat(La, Lb). Additionally, we have proven
φ f † := f †a(1a) = f .
Corollary. Suppose G is a group such that the collection of objects of operation is a set, A|G ∈ Set.
Then G is isomorphic to a group of transformations G†, G† : {e → e} → {e → e}.
Proof. Let C := G, be the group. The functor C := Le : G → Set is as we have described before;
the c-object e is sent into a set S , while objects of operation are sent into set functions S →iso S . The
Yoneda embedding provides a functor Y† : G → Cat(G, Set), where the c-object is transformed into
the Hom functor Le. The existence of inverse objects of operation, in the group G, implies f∗ and ∗ f
are isomorphisms (bijective function) for the set A|G; this was proven in proposition (4.2). This means
we indeed have a group of transformations for A|G, if we replace the image by a category where S is
c-object, instead of Le.

In building the group of integers, we took a category Z† as the c-object of the group. The objects of
operation are of course the integers which we considered as automorphisms for the category mentioned.
Then, the group of functors Z† was constructed as compositions and inverses of +1. This is the functor
we used to later prove that we can view the discrete number system as a group. This is the functor that
gave an operation.

of C : C → Set. The functor is said to be representable and x is called a representing object.

Representable Functors An object in the collection C →× Nat(Lx, C), is said to be a representation
We see that given two representations of a functor, it is possible to ﬁnd an isomorphism, in C, that

relates the natural transformations.
Proposition 9.2. Let (x, β) and (y, γ) be two representations of a functor F : C → Set. Then there is a
unique isomorphism f : x → y such that γ = β · f †.
Proof. We can deﬁne a composition of natural isomorphisms, β−1 ◦ γ : Ly → C → Lx, where β−1 is the
natural isomorphism of inverse arrows. From Yoneda’s embedding, we know there is an arrow f such
that β−1 ◦ γ = f †. We have proven that functors send isomorphisms into isomorphisms; proposition
5.1.

68

Set Function

Image

CHAPTER III. SET THEORY

Here we will give relations for the image and preimage of set functions. If we have an object in f A, for
some A ⊆ Dom f , then there is an x ∈ A such that our original object, in f A, is the object f x. For this
reason, we will be justiﬁed in denoting our object of interest with ( f x) ∈ f A. The notation says that
( f x) is an object in Range f , such that ( f x) = f x.
When considering a family of sets, we also consider another family, to be regarded as the image of
the original. Let X = {A}A∈X be a family of subsets of Dom f . The image of family X, is the family that
consists of the images of sets in X. This means, f [[X]] = { f A}A∈X. Let us suppose we have a family
Y = {B}B∈Y of subsets B ⊆ Range f . We deﬁne the inverse image of family Y, as the family consisting
of the sets that are inverse image of sets in Y. Let f −1[[Y]] be the inverse image of Y, and take an
object of it. Then there exists B ∈ Y such that our original object is the inverse image of B. We are
justiﬁed in representing an arbitrary object in f −1[[Y]], with ( f −1B).

Image and Inclusions The image and preimage preserve subsets. That is, f A ⊆ f B and f −1A ⊆

f −1B; the ﬁrst relation holds given A ⊆ B ⊆ Dom f and the second holds given A ⊆ B ⊆ Range f .

Proposition 10.1. Let f
B ⊆ Range f we verify

: Dom f → Range f be a set function. Then, for every A ⊆ Dom f and

1) A ⊆ f −1 f A, and A = f −1 f A if f is monic.
2) B ⊇ f f −1B, and B = f f −1B if f is onto.

Proof. x ∈ A implies f x ∈ f A, which is true if and only if x ∈ f −1 f A. If f is monic, then x ∈ A if and
only if f x ∈ f A, which proves the equality holds.
We have ( f x) ∈ f f −1B if and only if there exists x ∈ f −1B such that ( f x) = f x ∈ B. Let f be onto,
then for every ( f x) ∈ B there exists x ∈ f −1B such that ( f x) = f x, which proves ( f x) ∈ f f −1B.

Using the results so far given, we get

f A ⊆ B ⇐⇒ A ⊆ f −1B

which was to be expected since we deﬁne the inverse image by x ∈ f −1A ⇔ f x ∈ A. If f is onto,

If f is monic, then

f −1B ⊆ A =⇒ B ⊆ f A.

B ⊆ f A =⇒ f −1B ⊆ A.

10. SET FUNCTION

69
Image and Set Operations The diﬀerence is preserved under preimage; x ∈ f −1(B − A) ⇔ f x ∈
B − A ⇔ f x ∈ B and f x (cid:60) A ⇔ x ∈ f −1B and x (cid:60) f −1A ⇔ x ∈ f −1B − f −1A. We get the following
result, as a consequence of this:

f −1(Range f − A) = Dom f − f −1A.

We will generally say Ac is X − A if we accept that all work will be done in a certain set X. If we are
considering the sets Dom f and Range f , we may re-write the above expression as f −1Ac = ( f −1A)c.
Let B ⊆ Range f , then f|−1
A B. It is easy to prove
A ∩ f|−1

A B = A ∩ f −1B, so we conclude

A [(Bc)c] = A − f|−1

A B)c = A ∩ f|−1

A Bc = A − ( f|−1

A B = f|−1

f|−1
A B = A ∩ f −1B.

(III.9)

This means the inverse image of B, under f|A, is equal to A ∩ f −1B.
Proposition 10.2. Let X = {A}A∈X a family of subsets A ⊆ Dom f and Y = {B}B∈Y a family of subsets
B ⊆ Range f . Then

f A

f A

(III.10)

f

A∈X

(cid:91)
(cid:92)
f −1(cid:91)
f −1(cid:92)

B∈Y

A∈X

f

f A∈ f [[X]]

A =

(cid:91)
A ⊆ (cid:92)
(cid:91)
(cid:92)

B =

f A∈ f [[X]]

B =

B∈Y

f −1B∈ f −1[[Y]]

f −1B∈ f −1[[Y]]

f −1B

f −1B.

A∈X A such that ( f x) = f x. This is the

We verify equality in the second relation, given f is monic.
Proof.

same as saying ( f x) ∈ f A, for some f A ∈ f [[X]].

A∈X A. Now,
let ( f A) ∈ f [[X]]. Then ( f A) = f A, for some A ∈ X such that f x ∈ f A. In other words,
( f x) ∈ ( f A), for every ( f A) ∈ f [[X]].
f A∈ f [[X]] f A. This is stating that ( f x) is in the image of every A ∈ X. This holds
if and only if, for every A ∈ X, there exists xa ∈ A such that ( f x) = f xa. If f is monic, then
A∈X A because

A∈X A if and only if there exists x ∈(cid:83)
1) We know ( f x) ∈ f(cid:83)
2) The relation ( f x) ∈ f(cid:84)
A∈X A holds if and only if ( f x) = f x, for some x ∈ (cid:84)
Take ( f x) ∈ (cid:84)
xa = x, for some x that is the same for all A ∈ X. We conclude ( f x) = f x ∈ f(cid:84)
x ∈(cid:84)
3) It is from the deﬁnition of inverse image that we have f x ∈(cid:83)
Then, x ∈ f −1B, for some B ∈ Y. We conclude x ∈ (cid:83)
4) x ∈ f −1(cid:84)

B∈Y B, for every x ∈ f −1(cid:83)

B∈Y B if and only if f x ∈(cid:84)

B∈Y B. It follows from this that x ∈ f −1B, for every B.

B∈Y B.
B∈Y f −1B. All the implications in the

argument are ⇔.

A∈X A.

70

CHAPTER III. SET THEORY
Fiber We say that the preimage of a singleton {z} ⊆ Im f is the ﬁber for z, under f . We will
express this by f −1{z} or f −1[z], in place of the strict notation f −1[{z}]. We notice that x ∈ f −1[z] ⇔ x ∈
f −1{z} ⇔ f x ∈ {z} ⇔ f x = z. It is clear that f −1[z] = ∅ implies z ∈ Range f − Im f . From the deﬁnition
of function we know every object in the domain belongs to exactly one ﬁber of f . If f A = z ∈ Im f ,
then A ⊆ f −1[z]. A function with z ∈ Im f such that f −1[z] = Dom f is called constant function to z and
we write → z.
A function is onto if and only if every ﬁber of f is non-empty. Let f be a bijective function and let
g be the inverse function of f , then x ∈ f −1[z] if and only if z ∈ g−1[x]. Said diﬀerently, this last means
x ∈ f −1{z} if and only if z ∈ ( f −1)−1{x}; we take notice that f −1{z} is the inverse image of {z}, under f ,
while ( f −1)−1{x} is representative of the inverse image of {x} under f −1.
Let us consider the family f −1{{B}} := f −1[[{{b}}b∈B]] = { f −1{b}}b∈B, which represents inverse image
of the family {{b}}b∈B.

Proposition 10.3. Let f be a monic function and take A ⊆ Dom f . Then f A = B ⇔ A =(cid:83) f −1{{B}}.
Proof. Suppose A =(cid:83) f −1{{B}} =(cid:83){ f −1{b}}b∈B, then
(cid:91){ f −1{b}}b∈B
(cid:91)
(cid:91){{b}}b∈B
(cid:91)

f{ f −1{b}}b∈B

f A = f

=

=

=

{b}.

b∈B

If on the contrary, f A = B, then

A =

=

=

=

a∈A

(cid:91)
(cid:91)
{a}
(cid:91)
f −1 f{a}
f −1{b}
(cid:91){ f −1{b}}b∈B.

b∈ f A

a∈A

Quotient Sets and Decomposition of Functions

We start this section by giving a result that characterizes onto functions as functions that have and right
inverse. Consider the family {{Im f}} = {{x}}x∈Im f , which means it consists of the sets {x}, where
x ∈ Im f . The inverse image, f −1[[{Im f}]], is a family of sets in Dom f which turn out to be the ﬁbers
of f . We will view f −1[[{{Im f}}]] as a simple set, in which we will not take into account what the
objects of the sets in the family are; we only care for the sets of the family.
composition of one onto function and one monic function. Let f|Im f
function f restricted to the image.

A function can always be expressed as a composition of an inmersion and an onto function; a
: Dom f → Im f , denote the

10. SET FUNCTION
Lemma I. For any f and ι f : Im f → Range f we verify f = ι f ◦ f|Im f .

71

Further on, we will complete this description by expressing a function as the composition of three

functions, one of each type: onto, bijective, and monic.
Given a set function f , we will give an equivalence relation E f deﬁned for Dom f . We say two
objects x, y ∈ Dom f are related, xE f y, if f x = f y. We call such a relation the image equivalence of f.
Another way of seeing this is

xE f y ⇐⇒ x, y ∈ f −1[z],

for some z ∈ Im f . We may conclude that the ﬁbers of f form the simple equivalence reations of E f .

Deﬁne a new domain Dom f /E f := f −1[[{{Im f}}]], for the function

f /E f : Dom f /E f → Im f.

Naturally, we deﬁne f −1[z] (cid:55)→ f /E f z, because for every x ∈ f −1[z], we have x (cid:55)→ f z.
Lemma II. The function f /E f is said to be the function f module E f and it is bijective.

Proof. The function is onto because every ﬁber of Im f is non-empty. To see that it is also monic, take
two diﬀerent ﬁbers f −1[w] and f −1[z]. These two ﬁbers consist of objects x (cid:55)→ f w and y (cid:55)→ f z and they
form simple equivalence relations under E f . Therefore, w (cid:44) z.

Let p f : Dom f → Dom f /E f that sends an object to its ﬁber. We can do this because we have
already stated that every object in Dom f is associated one ﬁber. We know the function is onto because
every ﬁber in f −1[[{Im f}]] is non-empty.
Theorem 10.4. Given a function f , we can decompose it as f = ι f ◦ f /E f ◦ p f

Sequence

From this point on, we may use N to refer either to the collection or N≤. A sequence is a set function
s : N → A. A general sequence is a sequence in which the image A is a collection, not necesarilly a set.
We will say a set function is a sequence, if Dom s is N0 instead of N. Let n ∈ N, and deﬁne n as the set
of all x ∈ N such that 1 ≤ x ≤ n. A ﬁnite sequence is a function n → A. Also, a set A is said to be ﬁnite
if there exists n ∈ N such that there is a bijective function n → A.
Consider now the category N which stands for the partial order. Let S : N → N be a functor on the
order. Then s ◦ S is a sequence and we will call it a subsequence of s. We request S to be a functor so
that the the order of N is preseved.

Representation A sequence is, informally, an ordered collection. It makes sense to, for example,
write a sequence of two numbers as (a, b) and not {a, b} which is a simple set. In general, to express a
sequence with components n (cid:55)→ xn, we will write (xi)i. If the sequence is ﬁnite, we will write (xi)n
i=1.
When we write (x)i, we are expressing that the sequence is a constant function, → x.

Monotonic Sequence Suppose we deﬁne a functor N → A, where A is a partial order. Then, the
object function of such a functor is called a increasing sequence in A. If there is a functor N → Aop, we
will call the object function of such a functor, a decreasing sequence in A.

72

CHAPTER III. SET THEORY

Sequence of Objects for an Operation We can give a general form of expressing the operation
union and intersection for sets. Let I be a set, the index set, and let I → X such that i (cid:55)→ Ai. The

following may be used as a common notation(cid:91)X =

(cid:91)

i∈I

Ai.

and intersection and this is expressed by(cid:83)

Similar remarks hold for the intersection. We will use the set of integers as an index set, in order to
express general operations. Let ⊕ be an operation ⊕ : O → O fO and let ON represent the collection of
sequences N → O. We will give, for n + 1 ∈ N0, a function Λn+1
i=1(xi)i ⊕
i=1(xi)i = x1. These functions are called the ﬁnite operators. The sequence Λ : N → ON fO
xn+1, where Λ1
is deﬁned by n (cid:55)→Λ Λn
i=1; we call it the general operator. For any sequence of sets, we can give union
n∈N Im Λn. If there is a
sensible way of deﬁning a function ΛN : A ⊆ ON → O, we may say the series of (xi)i is the result in
(xi)i; Λi∈Nxi, ΛN. We may also represent the series by Λ∞
We may use this development to express the general sum of multiple rational numbers. Just as we
use the notation ON, we will say On stands for the collection of all ﬁnite sequences n → O. Thus the
sum of a ﬁnite sequence of rational numbers, (xi)i ∈ Qn, is given by

i∈N Ai. We deﬁne ΛO =(cid:83)

i=1 : ON → O such that (xi)i (cid:55)→ Λn

i∈N Ai or(cid:84)

i=1xi.

n(cid:88)

n−1(cid:88)

xi =

xi + xn

i=1

i=1

and from this we get

n(cid:88)

We are making it clear that ·n and(cid:80)n
and the sequence (a)i ∈ Qn. Note that every natural number a ∈ N is represented as a =(cid:80)a

i=1 are the same function when applied, respectively, to a ∈ Q

a.

i=1

i=1 1.

a · n =

Sequence of Functions We have just deﬁned a sequence of functions, that can be applied to a
sequence, and the result is another sequence. We study this with a general view. A sequence of objects,
in a collection of functions, is called a sequence of functions. A sequence of functions from O into Q
is a function Φ : N → O fQ. Let n (cid:55)→Φ fn be the components of Φ, and deﬁne φ : O → QN such that
x (cid:55)→φ ( fix)i; it is the sequence function.
(cid:17)
In the case of series, the general operator Λ : N → ON fO is the sequence of functions Φ. The
sequence function is φ : ON → ON. The image of (xi)i, under φ, is the sequence of partial operations for
(xi)i and we represent it with (φi)i. Clearly, every φn is Λn
.
We will consider an important special case of this. Let (a)i ∈ ON be a constant sequence, and suppose
deﬁned as the sequence of partial products. For the operation of product · in Q, we use(cid:81) as the general
there is an operation on the collection, called the product operation. Then the sequence of powers is

i=1(xi)i, so we have stated φ(xi)i is

Λn
i=1(xi)i

(cid:16)

n

operator and

an =

n(cid:89)

a,

in representing the ﬁnite operator of product, applied to (a)i.

i=1

10. SET FUNCTION

73

Sequence for Composition There is something important to be noticed in the last paragraph. For
a ﬁxed sequence (xi)i ∈ ON, we have a sequence of functions (⊕xi)i which we compose to ﬁnd Λn
i=1(xi)i.
This sequence of functions has something particular about it. If the operation is full, each one of these
functions is of the form O → O. Let us make the case for a more general situation.

Let ( fi)i be a sequence of functions such that Im fn = Dom fn+1. This is a composable sequence
of functions and to better understand this deﬁnition we will give a more speciﬁc description of the
composition of functions. Let f : Dom f → Range f and g : Dom g ⊆ Range f → Range g. Let D =
f x (cid:55)→g g( f x).
f −1[Im f ∩ Dom g], then the composition is g ◦ f : D → Range g; we are assured x (cid:55)→ f
The composition is onto if and only if g is onto, and it is monic if and only if both f, g are monic.

i=1 ( fi)i

(cid:55)→ (cid:13)n

i=1( fi)i ◦ fn+1, remembering that (cid:13)1

The compositions of a sequence are (cid:13)n+1

i=1( f )i is the function f n. We see that Im f 2 = f [Im f ], Im f 3 = f [ f [Im f ]], etc...

i=1( fi)i is f1.
We have a special case, when we take a constant sequence ( f )i, consisting of only one function f . The
composition (cid:13)n
If x (cid:55)→ f x, then we say x is an invariant object under f. If f A = A, then A is an invariant subset
under f. Notice that it is not the same to say A is an invariant subset under f as opposed to saying A
is a set of invariant objects under f . In this last case we say that A is a strongly invariant subset; these
are subsets of Inv f which is the set of invariant objects. If Im f is strongly invariant, Im f ⊆ Inv f ,
then the function is said to be once-eﬀective. The situation is that f 2 : Im f → f [Im f ] = Im f and
x (cid:55)→ f 2 f x because f x is invariant under f . This means the sequence of compositions ( f i)i is the constant
sequence of the function f|Im f .
Let a be invariant under f and suppose that for every x ∈ Dom f there exists n ∈ N such that
x (cid:55)→ f n a; we say f stableizes at a. If there is n ∈ N such that x (cid:55)→ f n a, for every x ∈ Dom f , then f is
nilpotent into a.

Let us now consider the cartesian product of a sequence of sets; that is, A = ×n+1

Sequence and Cartesian Product From this point on, we make the convention of writing A × B
in the place of A →× B. The cartesian product of two collections A, B is a collection of arrows a →× b,
with a, b ∈ A, B respectively. Let 2 f (A(cid:116) B) be the collection of two part functions 2 → A∪ B that send 1
to an object in A and send 2 into object of B. We have a bijective function of the form A×B → 2 f (A(cid:116)B).
i=1 Ai. This is the set
of all arrows a1 −→ an+1 : (a1 −→ an) →× an+1, where a1 −→ a2 is a1 →× a2 and ai ∈ Ai. We see that
If we limit ourselves to Ai = A, for all i ∈ n+1, then we have a ﬁnite sequence on A. In making
i=1 A → An+1, where An+1 is the collection of all

each of these arrows a1 −→ an+1 is a ﬁnite sequence n+1 →(cid:70)n+1

such considerations, we have a bijective function ×n+1
sequences n+1 → A. We deﬁne AN = ×i∈NA as the collection of all sequences for A.

i=1 Ai with i (cid:55)→ ai.

Net

We will be working with functions that have a kind of special domain. This will lead to a useful
generalization of sequence. Sequence is generalized because we generalize the concept of ordered
index set; where we have used N we will now use a general kind of set called directed set.

Bounds Let X be a set that forms a partial order with some relation ≤. A subset A ⊆ X has a
unique object max A ∈ A that is maximum if a ≤ max A, for every a ∈ A. Now consider the set ↓ A of
all x ∈ X such that a ≤ x, for every a ∈ A. This is the set of upper bounds of A and it need not have
a minimum, deﬁned dually to the maximum. Therefore, we cannot always say that there is an upper
bound; if ↓ A (cid:44) ∅ we still cannot say their is a least upper bound min ↓ A; even if min ↓ A does exist

74
CHAPTER III. SET THEORY
we cannot say that it is in A. When this most important object min ↓ A, exists in X, we say it is the
supremum and denote it by sup A. The inﬁmum, denoted inf A is deﬁned, when it exists, as max ↑ A.
Of course, if the supremum is in A, then it is the same as the maximum.
If ↓ A = ∅, then A is not bounded by above. Similarly, we deﬁne sets that are not bounded by below.

If a set is not bounded by below and is not bounded by above it is simply not bounded.

Directed Set A set I that has deﬁned a preorder is said to be a directed set if for every i, j ∈ I there

is a k ∈ I such that i, j ≤ k. We give an equivalent deﬁnition for directed set, in terms of bounds.
Proposition 10.5. A partial order is directed if and only if every ﬁnite subset has an upper bound.
Proposition 10.6. Q ⊇ Z ⊇ N are directed sets. In general, a natural order is a directed set.

We already know of an important directed set that is not the set of integers or rationals. The category

PN is directed, under inclusion.
Proposition 10.7. For any set A, the category PA gives a directed set. Let x ↑ x0 represent the set of
objects x ∈ X such that x ≤ x0 ∈ X. Then x ↑ x0 is a directed set.

Given preorders ≤1,≤2 on sets I, J, we can form the new order ≤ by deﬁning (i1, j1) ≤ (i2, j2) if and

only if i1 ≤ i2 and j1 ≤ j2.
Proposition 10.8. If I, J are two directed sets with orders ≤1,≤2, then the cartesian product I × J is
also a directed set under the corresponding product order.

Deﬁnition A net is a function η : I → O, where I is a directed set. The concept of net generalizes

that of a sequence because we know N is a directed set.
When considering a ﬁnite sequence, we now think in a broader sense. A ﬁnite sequence is a function
N → O, where N ⊆ N is bijective to n, for some n ∈ N. A general deﬁnition of a sequence, but less
general than a net, is to replace the set N with any directed subset I ⊆ N. But, it turns out that any
subset of N is directed. So, a sequence is a function I ⊆ N → O. A net generalizes this deﬁnition. The
ﬁrst thing we will do to put to use the conpcept of net, is to give a deﬁnition of of matrix.

Matrix

The reason why we did not consider the object 0
0 in our grid of the rational numbers, (II.5), is that we
did not have any way of considering this strange object in terms of our operation. So we leave it out,
and in fact, we make changes to the normal behavior of the grid, along the border. This does not mean,
however, that we are not able to deﬁne a good order in Z × Z, if we just ignore the operation in this
process. Again, representing a →× b with a
d if and only
if a < b or, if this fails to be true, c ≤ d. This order is a natural order.
i )i, j : J × I ⊆ Z2≤ → A is a matrix for the objects
Deﬁnition 11. Let I, J ⊆ Z, then we say the function (a j
of A. If i, j ∈ I, J respectively, then the image of j
A matrix is said to be ﬁnite if I, J are bijective to sets m, n ⊆ N respectively. The matrix is regular
if it is of the special form m × n → A, that is, if I = m and J = n. In any case, we say the matrix is of
order m × n.

b, we say Z2≤ is the matrix order, deﬁned by a

c ≤ b

i , under the matrix, is represented by a j
i .

11. SPECIAL FAMILIES

75
i )i, j|m×{ j}, of the
i )i, j. A similar remark holds for

i )i = (a j

If we restrict the matrix to one of the sets m × { j}, then we have a matrix (a j

i )i is the j-th column of the matrix (a j

i )i, j to a set {i} × n; in this case we say (a j

i ) j is the i-th row of (a j

i )i, j.

form m × { j} → A and we say (a j
the restriction of (a j
Proposition 10.9.

1) Every column or row is a matrix

2) Every matrix is uniquely identiﬁed with a sequence of rows and with a sequence of columns.

3) Any sequence can be uniquely identiﬁed with one column matrix and one row matrix.

Special Families

(cid:91)

A∈X

X ⊆ P

Power Set
Power Functor We move on to study the power set P. We will ﬁnd a functor P : Set → Set such
that its object function is given by B (cid:55)→ PB. Since we are to give a functor, we need to specify an arrow
function such that f : B → C is assigned a function P f : PB → PC. To this end, we deﬁne the arrow
function such that P f is the function that makes A (cid:55)→ f [A]. We verify that P is indeed a functor. We
must ﬁrst prove that 1Set, 1Set; P, P, where 1SetB is the identity function for B. That is, (1Set ◦ P)B and
(P◦ 1Set)B are the same functions, for every B ∈ Set. We also observe that P(g◦ f ) is the same function
as Pg ◦ P f . Let A ⊆ B, then P(g ◦ f )A = (g ◦ f )[A] = g[ f [A]] = g[P f A] = Pg(P f A) = (Pg ◦ P f )A.
Properties and Relations Here we ﬁnd equalities that involve expressions of power sets. We ﬁrst
note that for any family of sets X = {A}A∈X,

A.

in the power set of such union.

We verify the validity of this. If A ∈ X, then every object of A is in(cid:83)X. Therefore, A is an object
We know A =(cid:83){A} ⊆(cid:83) PA. Also, X ⊆ A, for every X ∈ PA, we may conlcude A =(cid:83) PA.

The arrow in (III.11) leads to the trivial relation A ∈ PA. The relation A ∈ PA implies PA ∈ PPA.

In particular, we have

{A} ⊆ PA.

(III.11)

We will give a generalization of this last relation.
Proposition 11.1. Let A be any set and XA ⊆ PA any family of subsets of A. Then XA ∈ PPA.

Consider a family X, and an element A ∈ X. We wish to prove PA ⊆ P(cid:83)X. This is clear because
PA is a family of subsets of A ⊆(cid:83)X. Applying the last proposition,
Proposition 11.2. For A ∈ X ∈ U, we verify PA ∈ PP(cid:83)X.

Proposition 11.3. The object function of the power functor, satisﬁes

P(A ∩ B) = PA ∩ PB
PA ∪ PB ⊆ P(A ∪ B).

76

X∈P f −1{B} B = B.

CHAPTER III. SET THEORY
Direct Image Now we deﬁne the direct image of a family of sets as the collection f [X] of all
B ⊆ Range f such that f −1B ∈ X. Of course, the direct inverse image of a family Y, is the collection
f −1[Y] of sets A ⊆ Dom f such that f A ∈ Y. Let f →A be the collection of all subsets of the range,
(cid:83) P f −1{B}. All we need to verify is that B = P f M. This is straightforward, f M = f [(cid:83) P f −1{B}] =
whose inverse image is A, and f ←B be the collection of all subsets of the domain, whose image is B.
Let P f −1{B} be the ﬁber of B ⊆ Range f , for the function P f . Then the ﬁber has a maximum M =
(cid:83)
X∈P f −1{B} f X =(cid:83)
Lemma I. Let B ∈ Im P f , then f −1B =(cid:83) P f −1{B}.
f −1B ⊆(cid:83) P f −1{B}.
1) Let f be an onto function, then B ∈ f [X] if and only if(cid:83) P f −1{B} ∈ X
2) Let f be a monic function, A ∈ f −1[Y] if and only if A =(cid:83) f −1{{B}}, for some B ∈ Y.
On the other hand, A ∈ f −1[Y] if and only if f A ∈ Y. From proposition 10.3, we get A =(cid:83) f −1{{B}},

Proof. By deﬁnition of direct image and lemma I, B ∈ f [X] if and only if M = f −1B ∈ X.
for B = f A ∈ Y.

Proof. We know M ⊆ f −1 f M = f −1B. Also, f −1B ∈ P f −1{B} because P f ( f −1B) = B. This implies

Lemma II.

Deﬁne f∅ := Range f − Im f , and let f (A∪∅) be the collection of all Y such that f A ⊆ Y ⊆ f A∪ f∅.

Lemma III.

1) If f is onto, then f ←B = P f −1{B}
2) f →A ⊆ f (A ∪ ∅) and equality holds given f is monic.

Proof. The ﬁrst result is a direct consequence of the deﬁnitions of f ←B and P f .
To prove the second result we ﬁrst take B such that A = f −1B. We get f A = f f −1B ⊆ B. Suppose
that ( f x) ∈ B and ( f x) (cid:60) f A∪ f∅. This means ( f x) ∈ ( f A∪ f∅)c = ( f A)c ∩ Im f = Im f − f A. But, we
have A = f −1B which is equivalent to saying f x ∈ B if and only if x ∈ A. This is a clear contradiction,
therefore B ⊆ f A ∪ f∅. We conlcude B ∈ f (A ∪ ∅).
If we wanted to prove f (A ∪ ∅) ⊆ f →A by taking Y that satisﬁes the conditions of being an object
of f (A ∪ ∅), then A ⊆ f −1 f A ⊆ f −1Y ⊆ f −1( f A ∪ f∅) = f −1 f A. We would get x ∈ f −1Y ⇒ f x ∈ f A,
but f x ∈ f A does not imply x ∈ A. We request the function be monic.
Theorem 11.4. Suppose X is a family of non-empty subsets of Dom f and Y is a family of non-empty
subsets of Range f . If B ⊆ Im f , then

We know that A ∈ f −1[Y] if and only if B = f A =(cid:84) f (A ∪ ∅) =(cid:84) f →A, for some B ∈ Y.

Proof. The ﬁrst result follows from lemmas II,III.

We see that there is a duality relationship for ﬁber and image in the forms of f ←B and f →A.

If f is monic, we have

B ∈ f [X] ⇐⇒ (cid:91)
A ∈ f −1[Y] ⇐⇒ (cid:92)

f ←B ∈ X.

f →A ∈ Y.

11. SPECIAL FAMILIES

77

Another Functor We form yet another functor, using the power set P as object function of this
functor Set⊆ → Set⊆. This means the second condition is satisﬁed because the functor applied to any
arrow A ⊆ B results in PA ⊆ PB. Since the ﬁrst condition is trivial, we are left to give a proof of
condition 3) for functors. It means that transitivity is preserved. This is veriﬁed by

P[(A ⊆ B) ◦ (B ⊆ C)] = P(A ⊆ C)
= PA ⊆ PC
= (PA ⊆ PB) ◦ (PB ⊆ PC)
= P(A ⊆ B) ◦ P(B ⊆ C).

Family of Families

We will now give two basic results in applying the operations of sets to families of families of sets. We
will be using X = {X}X∈X to represent the family that consists of families, such that X = {A}A∈X. This is
X ⊆(cid:91)(cid:91)
to say, we have a two generation family of sets.(cid:91)(cid:92)
(cid:92)(cid:91)
X ⊆(cid:92)(cid:92)
Both of these follow from the fact that(cid:84) X ⊆(cid:83) X.

(III.12)

(III.13)

X.

X

Nest

We have pointed out that the power set is a partial order under inclusion. The objects of study in the
present section are those families of sets that form a natural order, under inclusion. In particular, there
are two cases of main interest. We will use this context to extend results (III.1) and (III.2).

Increasing Nest The ﬁrst case happens when we have an inﬁnite chain going forward. This means
that there is a sequence of sets {Ai}i∈N such that An ⊆ An+1. When such a family is encountered, one
usually needs to ﬁnd the union; the intersection is clearly A1. The union will be expressed in terms of
i Ai because each
i Ai, then x ∈ Bm, where m is the smallest integer such that x ∈ Am. We conclude

a family of disjoint sets. Consider the family Bi = Ai − Ai−1. We know(cid:83)
Bi ⊆ Ai. Also, if x ∈(cid:83)

i Bi ⊆ (cid:83)

Decreasing Nest Now we analyze a sequence of sets such that An+1 ⊆ An. We are able to express

(III.15)

Ai =

∅ =

Bi

Bi.

(III.14)

(cid:91)

i

(cid:91)
(cid:92)

i

i

(cid:91)
(Ai − Ai+1)

A1 =

i

78

CHAPTER III. SET THEORY
To prove this, we begin with A1 = (A1∩A2)∪(A1−A2) = A2∪(A1−A2). Then, since A2 = A3∪(A2−A3)
we can say A1 = (A1 − A2) ∪ (A2 − A3) ∪ A3. We continue in this manner and see that this is the union
of a disjoint family.

Often, when using nests, one needs to ﬁnd the intersection. It is expressed by

(cid:92)

i

Ai =

=

c

Ac
i

(cid:91)
(cid:91)

i

i

i − Ac
(Ac
i−1)

c

(III.16)

This is obtained by using the sequence of Ac

i as a growing nest.

σ-Algebra

Xc ∈ A, and 3) For any sequence B ⊆ A we verify(cid:83)B ∈ A. This is similar to having a group, where
For the same subset B, we have(cid:84)B ∈ A. The proof is(cid:84)B =(cid:83)Bc, since the objects of Bc are

A set of subsets of some A ∈ U can be such that it is closed for the operations of union, intersection and
complement. Formally, a σ − algebra, A, is an object of PPA such that 1) A ∈ A, 2) If X ∈ A, then
the objects of operation are the objects of the σ−algebra. Remember, however, that the complement is
not the inverse in the sense deﬁned for categories.
also in A.

Generated σ−algebra Let B ∈ PPA, then the σ−algebra generated by B is represented by σ(B).
We deﬁne it as the smallest σ−algebra that contains all the objects of B. In other words, if B ⊆ A,
where A is a σ−algebra, then B ⊆ σ(B) ⊆ A.

Let Σ(B) be the collection of all σ−algebras that contain all the objects of B.

Proposition 11.5. The σ−algebra generated by a collection B, of subsets of A, is expressed by

Proof. We know σ(B) ⊆ (cid:84) Σ(B) because σ(B) ⊆ A, for every A ∈ Σ(B). Also, (cid:84) Σ(B) ⊆ σ(B)

σ(B) =

Σ(B)

because σ(B) ∈ Σ(B).

(cid:92)

Set Filter

A ﬁlter F is a non-empty family of non-empty subsets (there is at least one set in the ﬁlter and each set
has at least one object) of X such that for every F, G ∈ F and any H ⊇ F:
A) F ∩ G ∈ F
B) H ∈ F

A ﬁlter base is a non-empty family of non-empty subsets of X such that A) holds. We say a) holds

if for every F, G ∈ F there exists an H ∈ F such that

11. SPECIAL FAMILIES

79

a) H ⊆ F ∩ G.

X ⊆ F we have(cid:84)X ∈ F . A base ﬁlter can be deﬁned equivalently, if we ask for the condition a)

Condition A) can be taken to be the ﬁnite intersection property because for any ﬁnite family of sets

instead of condition A). So, a ﬁlter may also be deﬁned as a family that veriﬁes conditions a) and B).

Filter Generated by a Base We will now give a construction that sheds light on the terms selected.
We will at times be justiﬁed in saying that a certain ﬁlter base, is base of some ﬁlter. Let B ∈ FBX
be an element in the set of all ﬁlter bases for X, and say (cid:104)B(cid:105) ∈ PPX consists of those sets A such that
F ⊆ A, for some F ∈ B. We note that B ⊆ (cid:104)B(cid:105).
Proposition 11.6. The family (cid:104)B(cid:105) is a ﬁlter and we will say the ﬁlter base is B.
Proof. We only need to prove that condition B) in the deﬁnition of ﬁlter, holds. Take B ⊇ A ∈ (cid:104)B(cid:105).
Then, there is F ∈ B such that F ⊆ A ⊆ B. This means B ∈ (cid:104)B(cid:105).

Let FBX and FX represent the collections of ﬁlter bases and ﬁlters for X. Then, the last proposition
is simply stating that there is a function from FBX onto FX, because every ﬁlter is also a ﬁlter base
and the ﬁlter generated by any ﬁlter is itself. Two base ﬁlters that generate the same ﬁlter are called
equivalent bases. For any X ∈ U, we have FiltX : (FBX) → (FX), and FiltXB = (cid:104)B(cid:105). All we have said
with respect to this is that for every F ∈ FX we also have F ∈ FBX and FiltXF = F .
Proposition 11.7. For any B ∈ FBX, we have (cid:104)B(cid:105) = B if and only if B ∈ FX.

What is more, for any ﬁlter base B we ﬁnd that the ﬁlter FiltXB is the smallest ﬁlter that contains

the ﬁlter base.
Proposition 11.8. Let B ∈ FBX and F ∈ FX. If B ⊆ F , then B ⊆ (cid:104)B(cid:105) ⊆ F .

Principal Filter and Filter Generated by a Point

It is clear that a family {F} consisting of one
non-empty set is a ﬁlter base. The ﬁlter generated from such a ﬁlter base is called a principal ﬁlter. Of
course, if we consider the inclusion order, we have (cid:104){F}(cid:105) =↓ F.
Lemma. Let F ∈ F , then FiltX{F} ⊆ F .

From this, we get the following result, where we consider the ﬁlter as an index set by noting the

function F → PPX that makes F (cid:55)→ (cid:104)F(cid:105) = FiltX{F}.
(cid:91)
Theorem 11.9. Any ﬁlter is the union of principal ﬁlters. In particular,

F =

(cid:104)F(cid:105).

F∈F

In case we have F = {x}, for some x ∈ X, then we write (cid:104)x(cid:105) instead of the strict notation FiltX{{x}} =

(cid:104){{x}}(cid:105). These are called point generated ﬁlters.

80

CHAPTER III. SET THEORY
Coﬁnite Filter Consider the family of all ﬁnite subsets, of X, and denote it by F c. Then, the family

F = {F}Fc∈F c, is called the coﬁnite ﬁlter of X. We are using F to represent the complement of Fc.
Proposition 11.10. The coﬁnite ﬁlter of X is a ﬁlter of X.
Proof. First, we see that Fc ∩ Gc = (F ∪ G)c, where Fc, Gc ∈ F c. We know F ∪ G is ﬁnite because A, B
are ﬁnite. This proves that Fc ∩ Gc ∈ F .

Now, let F ⊆ H. This means Hc ⊆ Fc, thus proving Hc is ﬁnite.
Fréchet Filter Base and Filter Let I be a directed set and consider, for every i ∈ I, the set of
objects i that consists of all x ∈ I such that x ≤ i. Let i, j ∈ I, then we can ﬁnd k ∈ I such that i, j ≤ k.
This means that kc is a subset of ic and jc. This proves that {ic}i∈I is the Fréchet ﬁlter base of I.
If {i}i∈I is a family of ﬁnite sets, then the coﬁnite ﬁlter of I is called the Fréchet ﬁlter of I and we
will write Fr(I) = {ic}i∈I.

Filter as a Directed Set A ﬁlter can easily be seen as a directed set, if we consider the partial order
PX, with arrows reversed. This new partial order can of course be written as P−1X. That is why we
may say that a ﬁlter is downward directed.
We now give a proof for our assertion. Let F be our ﬁlter and deﬁne an order for this family, where
F ≤ G if G ⊆ F. We know we have a partial ordering and all that needs to be shown is that given
F, G ∈ F , we have H ∈ F such that F, G ≤ H. This follows from condition a) for ﬁlters.

Image The image of a ﬁlter base behaves in a good manner. By this we mean that functions send
bases into bases. However, ﬁlters are not sent into ﬁlters. They are sent into base ﬁlters, but this is not
a problem because we already have a construction that sends base ﬁlters into ﬁlters!

: X → Y be a set function. Also, let B ∈ FBX and F ∈ FX. Then

Proposition 11.11. Let f
f [[B]], f [[F ]] ∈ FBY.
Proof. Take ( f F), ( f G) ∈ f [[B]], then there exist F, G ∈ B for which f F = ( f F) and f G = ( f G).
Therefore, ( f F) ∩ ( f G) = f F ∩ f G ⊆ f (F ∩ G) ∈ f [[B]]. In particular, this conclusion also holds for
ﬁlters in place of bases.

We will say that the generated image (cid:104) fF (cid:105), of the ﬁlter F , is the ﬁlter generated by the corresponding

image, which is a ﬁlter base; this is (cid:104) fF (cid:105) = FiltY f [[F ]].

The preimage of a ﬁlter base behaves well, under certain conditions.

Proposition 11.12. Let f : X → Y be a set function and B ∈ FBY. Then f −1[[B]] ∈ FBX if and only if
F ∩ f X (cid:44) ∅, for every F ∈ B.
Proof. If we suppose f −1[[B]] is a ﬁlter base of X, then for every F ∈ B we have f −1F (cid:44) ∅. This
implies that there exists an x ∈ X such that f x ∈ F.
If ( f −1F), ( f −1G) ∈ f −1[[B]], then there exist F, G ∈ B such that ( f −1F) ∩ ( f −1G) = f −1F ∩ f −1G =
f −1(F ∩ G) ∈ f −1[[B]].

The generated inverse image of F ∈ FY is deﬁned as (cid:104) f −1F (cid:105) = FiltX f −1[[F ]]; given, of course,

F ∩ f X (cid:44) ∅, for every F ∈ F .

11. SPECIAL FAMILIES

81
Elementary Filter of a Net Given a net η : I → X, we can give a ﬁlter associated to it,
η[FiltX{ic}i∈I]. This is nothing more than the direct image, under η, of the ﬁlter generated by {ic}i∈I.
In case we have a Fréchet ﬁlter, we will of course write η[Fr(I)]. In any case, the ﬁlter given is called
the elementary ﬁlter of η.

Ultraﬁlter We have seen how a ﬁlter is a partial order, that is ﬁlters have an internal order. Well it
turns out that the concept of ﬁlter gives rise to another type of order, an external order. This has already
been manifest in that we have enconutered a minimal ﬁlter (cid:104)B(cid:105) that contains B. In this paragraph we
will dedicate ourselves to the study of a special kind of maximal ﬁlters. In the next section we will
study the order deﬁned on FX, using a more general deﬁnition of ﬁlter.
Deﬁnition 12. If B,C ∈ FBX are such that for every B ∈ B there is C ∈ C such that C ⊆ B then we say
C is ﬁner than B, or that C is a reﬁnement of B. This is represented by B (cid:22) C.
A ﬁlter F is an ultraﬁlter if for every A ⊆ X we have A ∈ F or Ac ∈ F . The collection of ultraﬁlters

on a set X is UFX.
Proposition 11.13. The relation of reﬁnement (cid:22) is a preorder for FBX.
Proof. This follows from reﬂexivity and transitivty for set inclusion.
Proposition 11.14. Let F ,G ∈ FX. Then F ⊆ G if and only if F (cid:22) G.
Proof. Take F ∈ F ⊆ G, then for F ∈ G we have F ⊆ F.
we have F ∈ G.
Corollary. The relation (cid:22) for ﬁlters is a partial order.

Now suppose G is ﬁner than F and let F ∈ F . We have G ⊆ F for some G ∈ G. Since G is a ﬁlter

We do not generally have anti-symmetry for the reﬁnement relation in FBX but we do have the

following important result.
Proposition 11.15. Let B,C ∈ FBX. Then B (cid:22) C and C (cid:22) B if and only if (cid:104)B(cid:105) = (cid:104)C(cid:105).
Proof. Let F ∈ (cid:104)B(cid:105). Then B (cid:22) C is true if and only if there exists B ∈ B, and consequently C ∈ C, such
that C ⊆ B ⊆ F. Therefore F ∈ (cid:104)C(cid:105) and we may conlcude (cid:104)B(cid:105) ⊆ (cid:104)C(cid:105).
Theorem 11.16. A ﬁlter F is ultraﬁlter if and only if for every G ∈ FX such that F ≤ G, then G = F .
Proof. Suppose F is an ultraﬁlter. Since (cid:22) is a partial order relation, we only need to prove that G (cid:22) F .
As we have just seen, this is equivalent to proving G ⊆ F . Let G ∈ G, then G or Gc are in F ; we cannot
have both in F because that would imply ∅ = G ∩ Gc ∈ F which is a contradiction to the deﬁnition of
ﬁlter. So, we suppose Gc ∈ F . Since G is ﬁner than F we have H ∈ G such that H ⊆ Gc. This leads to
a contradiction because ∅ = G ∩ H ∈ G.
Now, we would like to show that F is an utraﬁlter, given the second condition. Let G be a ﬁlter
that contains F in the strict sense, F ≺ G. That is, there exists G ∈ G such that G (cid:60) F . If it were the
case Gc ∈ F we would have H ∈ G, such that H ⊆ Gc, because G is ﬁner than F , but this would imply
∅ = G ∩ H ∈ G. Therefore, no such G exists and F is maximal.

We see that the subcollection of ultraﬁlters absorbs under union of sets. Let us make a general and

fomal statement, for this last observation.

82
CHAPTER III. SET THEORY
Theorem 11.17. Let F ,G be two ﬁlters on a set X such that F ∪G ∈ UFX, then F ∈ UFX or G ∈ UFX.
Also, if F ∈ UFX and G ∈ FX, then F ∪ G ∈ UFX given F ∪ G ∈ FX.
Proof. Suppose F ∪ G is an ultraﬁlter and G is not an ultraﬁlter. So we take F ⊆ X such that F, Fc are
not both G; we have F ∈ F ∪ G or Fc ∈ F ∪ G. From this it follows that F ∈ F or Fc ∈ F .
Now let F be an ultraﬁlter and G a ﬁlter. Take H ⊆ X and suppose H (cid:60) F ∪G, then Hc ∈ F ⊆ F ∪G.
This means F ∪ G is an ultraﬁlter.

We have a similar result on the internal structure of ﬁlters.

Proposition 11.18. F ∈ UFX if and only if F ∪ G ∈ F implies F ∈ F or G ∈ F .
Proof. Let F be an ultraﬁlter and let F, G ⊆ X such that F ∪ G ∈ F . We know F or Fc is in F , the
same is true of G, Gc. Of course we cannot have Fc, Gc both in F .
Now suppose F ∪ G ∈ F ⇒ F ∈ F or G ∈ F for any F, G ⊆ X and any F ∈ FX. Consider the
special case F ∪ Fc = X ⊆ X which means F ∈ F or Fc ∈ F . We conclude F is an ultraﬁlter.

We give the easiest example of an ultraﬁlter in the following result.

Proposition 11.19. If x ∈ X then (cid:104)x(cid:105) =↓ {x} ∈ UFX and we call it a principal ultraﬁlter.

This is to say that a point generated ﬁlter is an ultraﬁlter.

Proposition 11.20. If F is an ultraﬁlter on a ﬁnite set X, then F is a principal ultraﬁlter.

Zorn’s Lemma and the Axiom of Choice

Here, we will formulate the axiom in terms of partial order. Essentially, we will suppose that given a
partial order, we are able to take away objects and relations so as to build a new system that is a natural
order. Of course we can take away so few objects and relations so as to be left with an order that is not
necessarily natural. The important aspect of the way in which we will take away objects and relations
is that we can take away many enough to get a natural order but just enough so that if we take away any
less, then we don’t get a natural order.
Axiom of Choice. Given a non-trivial partial order P and a natural order N ⊆ P, there exists at least
one maximal natural order M such that N ⊆ M ⊆ P.

Maximality of M means that if Q ⊇ M is a natural order then Q = M. If we have a maximal
natural order then any upper bound of the natural order is the maximum. Having a natural order that is
maximal means we are not able to add any objects to it and conserve the status of natural order. This
means that any object we add will not be comparable with the objects of the order. Therefore, if M is
an upper bound we must have M in the natural order and we conclude it is the maximum.
Zorn’s Lemma. Suppose for every natural order N ⊆ P we have ↓ N (cid:44) ∅. Then there exists a maximal
element in P.
Proof. If the partial order is trivial then we have maximal elements. Suppose it is not trivial, then there
is a natural order consisting of the comparabale objects x, y. We know that there is a maximal natural
order M ⊇ {x, y} and M has an upper bound, call it M. This object M is the maximum of M and it is
maximal in P because M is maximal.

Universal Concepts

The topics we have covered in sequences and ﬁlters are of relation to a concept known as limit. The
notion of limit has been found to be most general in the setting of categories, and this is a case of
universal properties. We will see how instances of this occur when deﬁning the functor of common
domain, and a bifunctor. We will discuss here, how ﬁlter limits arise from the general deﬁnition. We
will build the real number system, with the tools provided. Then, we will retake this subject in a later
chapter for topologies.

Although the general concept of comma category was not trivial to develop, it has arisen aleady in
certain occasions; we call them arrow categories. The instances in which it has appeared have been
very particular cases. Let f, g : C1,C2 → D be two functors with common range. An arrow category
D(f, g) is a category such that the c-objects are all the arrows fa → gb, for any (a, b) ∈ O|C1 ×O|C2. The
arrows of D(f, g) are τ → σ : fa → gb −→ fc → gd, such that σ, τ; gi, fh for h, i : a, b → c, d.

83

84

CHAPTER IV. UNIVERSAL CONCEPTS

Lattice

In this chapter we will study certain partial orders that satisfy certain properties in regards to the their
bounds or supremum/inﬁmum.

Lattices are a special type of order and one of the main reasons why it is special is that it can be
viewed as an algebraic structure. That is, the supremum concept of the order is described in terms of an
operation. Here, we will denote partial orders with L, or the like.

In a sense, we may think that the main idea behind this chapter is that the procedure of saying a is

greater than b, c is greater than a,... can be viewed as an operation.

Supremum and Inﬁmum

We recall that in the study of bounds we deﬁne a special bound, whether it be for upper/lower bounds.
These bounds are the supremum and inﬁmum. Here we will write the supremum of {x, y} as x ∨ y, and

the inﬁmum as x ∧ y. More generally,(cid:87) A = min ↓ A and(cid:86) A = max ↑ A. As we know, a set can be
written as A = {x}x∈A and in such cases we may write(cid:87)
We take the posture that, by default, any object is an upper bound of ∅, so that(cid:87)∅ = minL = m. We
can just as easily say(cid:86)∅ = maxL = M. Now, consider the set of upper bounds of L; it is obviously
the maximum of L. Therefore,(cid:87)L = M, while(cid:86)L = m.

Before moving on, we take on the problem of deﬁning the supremum/inﬁmum of empty set/universe.
Let us consider the empty set, ﬁrst. The supremum is, by deﬁnition, the least among upperbounds of ∅.

x∈A x = min ↓ A and(cid:86)

x∈A x = max ↑ A.

We provide some properties for supremum and inﬁmum. The proof to the ﬁrst three is trivial and
always follows directly from the deﬁnition. Result 4), in the next proposition, requires little knowledge
from sets, to reason.
Proposition 13.1. Let L be a partial order and A ⊆ B be subsets of L such that their supremum and
inﬁmum exist.

1) For every a ∈ A we have(cid:86) A ≤ a ≤(cid:87) A
2) For every x ∈ L, we have x ≤(cid:86) A if and only if x ≤ a, for every a ∈ A.
3) For every x ∈ L, we have(cid:87) A ≤ x if and only if a ≤ x, for every a ∈ A.
4) (cid:87) A ≤(cid:87) B and(cid:86) B ≤(cid:86) A.

85

86

CHAPTER V. LATTICE

Lattice

Consider a partial order with a full operation(cid:87) : L → L fL that sends x (cid:55)→∨y x ∨ y = min ↓ {x, y}. All
operation from this. If we are also able to build(cid:86) : L → L fL, for the inﬁmum, we say that L is a

this means is that the supremum exists for every pair of objects in the order and we make a commutative
lattice. Let us be more speciﬁc. Take a lattice L and H ⊆ L, where x ∨ y ∈ H, for every x, y ∈ H.
Then H is called an upper sublattice. If, instead, the inﬁmum exists for every pair, we have a lower
sublattice. In the case H is both upper and lower sublattice of L, we simply say H is sublattice of L.
Consider a bounded partial order; we will seek properties of unit. For the supremum, we have as
unit, the minimum. That is, x ∨ m = x. In case of the inﬁmum operation, the operation has M for
unit, this is, x ∧ M = x. Also, for the supremum, we have x ∨ M = M, and for the inﬁmum operation,
x ∧ m = m. The reader should be able to relate this with the situation encountered in sets.

Recall that the left and right operations of a given object are functions. The following result leaves

it clear that a given object may be invariant under more than one right/left operation.
Proposition 14.1. Let L be a lattice, then x ≤ y if and only if x ∨ y = y and x ∧ y = x.
Proof. If x ≤ y, then y is a the maximum of {x, y} and x is the minimum. We conclude x ∨ y = y and
x ∧ y = x. On the contrary, if x ∨ y = y we know that y is an upper bound of {x, y} which gives x ≤ y.
Proposition 14.2. The functions ∨x, ∧x, of a lattice, preserve the order.
Proof. Suppose x ≤ a ≤ b, then a ∨ x = a ≤ b = b ∨ x. If a ≤ x ≤ b, then a ∨ x = x ≤ b = b ∨ x.
Finally, a ≤ b ≤ x implies a ∨ x = x = b ∨ x.

The next proposition gives a special case of proposition (14.1). We will say that a constant function,
for some object x ∈ Range f , is the function onto x. Also, the compositions ∨x ◦ ∧x and ∧x ◦ ∨x
are the constant function that sends every a ∈ L into x and manifests that the supremum and inﬁmum
operations are commutative and associative. If we have an operation ∗ : O → O fO, such that for some
object e of O, the notation yields e; e, e, then we will say e is a primitive unit for ∗.
Proposition 14.3. For any lattice L, and any a, b ∈ L, we have

1) a is primitve unit under both operations.
2) The functions ∨a ◦ ∧a and ∧a ◦ ∨a are the function onto a.
3) Both operations are commutative.

4) Both operations ae associative.

Proof. From 1), we have a = a ∨ a =(cid:87){a, a} ≤(cid:87){a, b} = a ∨ b, because {a, a} = {a} ⊆ {a, b}. Using

proposition (14.1) in the last inequality proves the ﬁrst part of 2); the second part is similar.

Proposition (14.2) gives a ∨ y ≤ (x ∨ a) ∨ y and x ≤ x ∨ y ≤ (x ∨ a) ∨ y. We use (14.2) and the ﬁrst

inequality, then we use (14.1) and the second inequality to prove

x ∨ (a ∨ y) ≤ x ∨ [(x ∨ a) ∨ y]

= (x ∨ a) ∨ y

We can just as easily say (x ∨ a) ∨ y ≤ x ∨ (a ∨ y).

15. SEMILATTICE AND ALGEBRAIC ASPECTS

87

The following result states that the supremum of a ﬁnite union of sets, is supremum of supremums.

Ai =

Ai =

i=1

i=1

n(cid:87)
n(cid:86)

i=1

i=1

(cid:87) Ai
(cid:86) Ai.

Proposition 14.4. If (Ai)n
bounded and

i=1 is a sequence of bounded subsets of a lattice, then their union is also

1) (cid:87) n(cid:83)
2) (cid:86) n(cid:83)
Proof. Let A, B ⊆ L, then(cid:87) A,(cid:87) B ≤(cid:87) A∨(cid:87) B; this follows from 4) in proposition (13.1). Therefore,
every object in the union is less than or equal to(cid:87) A ∨(cid:87) B. This means that(cid:87) A ∨(cid:87) B is an upper
bound of A ∪ B, and we conclude(cid:87)(A ∪ B) ≤(cid:87) A ∨(cid:87) B.
We wish to prove the other inequality and it is suﬃcient to prove(cid:87)(A ∪ B) is greater than or equal
to(cid:87) A and(cid:87) B; this also follows from 4).

We give a characterization of the supremum in terms of the 3-diagram; the result will be rather

useful dealing with supremum and inﬁmum. This result inverts 2) and 3) in proposition (13.1).
Proposition 14.5. Let L ⊆ N, be a lattice, subset of a natural order N.

1) For every x ∈ L, we have x ≤(cid:87) A if and only if there exists a ∈ A such that x ≤ a ≤(cid:87) A.
2) For every x ∈ L, we have(cid:86) A ≤ x if and only if there exists a ∈ A such that(cid:86) A ≤ a ≤ x.
x ≤ (cid:87) A means x is not an upperbound of A. So then we know that there is some element a ∈ A

Proof. Let L ⊆ N, be a lattice, subset of a natural order N.
such that x is not greater than it. But, a, x are comparable so that x ≤ a.

The proof of 2) is similar.

One can see that it is crucial to have a natural order, otherwise we cannot assure comparability for

the objects in the proof.

Semilattice and Algebraic Aspects

A semilattice is a, commutative, associative category with every object as a primitive unit. A semilattice
with unit is a commutative algebraic category with every object as a primitive unit. When we describe
a lattice as an algebraic structure, we will consider two, dual, semilattices.

Order of a Semilattice

A semilattice always has an order deﬁned in terms of the operation. Let (cid:5) be the operation of the
semilattice. We deﬁne an order on the collection of objects, x ≤ y if and only if x; y, y. In this case,
our operation will act as the supremum of the order. We could have just as well said that the order is
deﬁned by y ≤ x if and only if x; y, y and in such instance the operation is inﬁmum.
Proposition 15.1. A semilattice L deﬁnes two, opposite, partial orders and the operation acts as
supremum or inﬁmum, respectively.

88
CHAPTER V. LATTICE
Proof. We will ﬁrst prove that the semilattice deﬁnes the supremum operation. Let x, y ∈ L, we wish
to prove x ∨ y = x (cid:5) y. It is quite obvious that x (cid:5) (x (cid:5) y) = x (cid:5) y means x ≤ x (cid:5) y. Of course, we also
have y ≤ x (cid:5) y and therefore x ∨ y ≤ x (cid:5) y. On the other hand, (x ∨ y) (cid:5) (x (cid:5) y) = [(x ∨ y) (cid:5) x] (cid:5) y = x ∨ y
because of associativity and the deﬁnition of the order; this means that x(cid:5)y ≤ x∨y. We have associated
an order to (cid:5), such that (cid:5) is the supremum operation of the order.
The order just used is deﬁned as x ≤ y if x; y, y and we denote it by L, as well. The order that is
deﬁned as y ≤ x, under the same conditions, is the opposite order Lop. Now we wish to prove that (cid:5)
acts as inﬁmum for Lop. From x (cid:5) (x (cid:5) y) = x (cid:5) y we get x (cid:5) y ≤ x, and similarly x (cid:5) y ≤ y. Finally, to
prove that x ∧ y = x (cid:5) y we need only show that x ∧ y ≤ x (cid:5) y. We again have (x ∧ y) (cid:5) (x (cid:5) y) = x ∧ y,
so we are done.

In this last result we see a strong relation between supremum and inﬁmum; namely, supremum
and inﬁmum are the same operation on opposite orders. Further on, we shall establish a more precise
statement to this observation, in terms of a functor. The following theorem states every lattice determines
two semilattices.
Proposition 15.2. Let L be a partial order such that the least upper bound exists for every pair of
objects, then the supremum operation deﬁnes a semilattice.

A similar remark holds if the greatest lower bound exists for every pair.

Proof. We know that the operation of supremum is commutative and associative. Also, it is easily seen
that any object in the partial order is a primitive unit.

Lattice as an Algebraic Structure

What we have done is to show that an order can induce a pair of operations that have a certain algebraic
aspect to them. Two semilattices, on the same collection of objects, with operations (cid:5),♦, are dual if
they satisfy condition 2) of proposition (14.3).
Proposition 15.3. Two dual semilattices of operations (cid:5),♦ verify x (cid:5) y = y if and only if x♦y = x.
Proof. Let the conditions of proposition (14.3) hold for the operations. We have x♦y = x♦(x (cid:5) y) = x.
If x♦y = x, then we can say x (cid:5) y = (x♦y) (cid:5) y = y becuase of commutativity in the operations.

Now we will see that the algebraic implications of the lattice are actually determinant in the structure
of a lattice. That is, if we have an associative category, for two operations that satisfy 1)-4) of (14.3),
then we have a lattice. This following result holds if L is replaced with an associative category, but in
such cases the order will not be bounded.
Theorem 15.4. Let (cid:5),♦ be two dual semilattices, both with unit and both on the collection L, and deﬁne
an order such that x ≤ y if and only if x (cid:5) y = y. Then the order is a lattice with x ∨ y = x (cid:5) y and
x ∧ y = x♦y. Additionally, the units are maximum and minimum of the order.
If L is a bounded lattice, then we have two dual semilattices. The operations for these are supremum

and inﬁmum; the maximum and minimum are units.
Proof. From proposition (15.1) we can say that (cid:5) is supremum, on the order deﬁned by x ≤ y if
x; y, y. By the same proposition, the operation ♦ is the supremum or inﬁmum, on the order already
deﬁned. Because of proposition (15.3) and duality of operations, we know that x♦y = x; therefore ♦

16. COMPLETENESS

89

is the inﬁmum. This proves that supremum and inﬁmum are full operations because the operation of a
semilattice is full.

Using proposition (15.2) we have two sublattices deﬁned by supremum and inﬁmum. Since supremum

and inﬁmum satisfy condition 2) of proposition (14.3), which means the sublattices are dual. It is not
diﬃcult to see that minimum and maximum of orders are units for supremum and inﬁmum, respectively.
In fact, one can also prove that minimum absorbs inﬁmum and maximum absorbs supremum.

Completeness

In this section we develop notions that guarantee some existence of supremum.

Complete Partial Order

The concept of completeness is best studied for a lattice in terms of the order, and not the operation.
Therefore, before we introduce completeness in the context of lattice, we will give deﬁnitions for partial
order. First, we establish a notion for diected subsets of a partial order. After this, we do so for bounded
subsets of the order. The following proposition will help prove some results in this section.

Proposition 16.1. The following are equivalent statements

1) The maximum of A exists

2) The supremum of A exists and(cid:87) A = max A
3) The supremum of A exists and(cid:87) A ∈ A.

Proof. The maximum is upper bound and if any other object is greater than the maximum, it fails to be
in the set. This means that 1) implies 2). Of course 2) implies 1), trivially. To verify 2) implies 3), we
simply note that max A ∈ A. If 3), then 2) is true; the supremum is greater than every x ∈ A.

Directed Complete If L is a directed set, it is a non-empty partial order such that for every pair
of objects x, y ∈ L we have ↓ {x, y} (cid:44) ∅. The deﬁnition of semilattice, is more speciﬁc, requiring that
min ↓ {x, y} exist for every pair. We can conclude that a partial order which is not a directed set, cannot
be a semilattice either.
Let DL be the non-empty collection of directed subsets of some partial order L. Suppose we have
a function DL ⊆ PL → L that sends every object in the domain into its supremum; we are of course
making it implicit that the supremum exists for every directed subset of the order. In such cases we
say that L is directed complete. If, additionally, L has a minimum, we say it is a complete partial
order. We restate this: a partial order is complete if and only if it has a minimum and there is a function
sup : DL → L such that I (cid:55)→sup
consider the opposite order. Since the set I is directed, for every x, y ∈ Lop we have k ∈ Lop such
that k ≤ x, y. By proposition (15.1) we conclude that the order has a maximum and there is a function
inf : DLop → Lop such that I (cid:55)→inf

(cid:87) I. This can be stated in terms of the inﬁmum operation if we
(cid:86) I.

We recall that a set L is ﬁnite if there a bijective function n → L, for some n ∈ N.

Proposition 16.2. If L is a ﬁnite partial order, then it is directed complete.

90
CHAPTER V. LATTICE
Proof. To prove that the order is directed complete, we take any directed subset I ⊆ L. The set is ﬁnite
so we know that there is ﬁnite sequence of the form n → L. We represent I with (xi)n
i=1 and since it is
directed, for every pair xi, x j ∈ I, we have xi, x j ≤ xk ∈ I.
Take x1, x2 and ﬁnd xk1 such that x1, x2 ≤ xk1. Suppose xk1 is not maximum of I. Then there is xk2
such that xk1, x3 ≤ xk2 and xk1 < xk2. If xk2
(cid:44) max I, then there is xk3 such that xk2, x4 ≤ xk3 and xk1 <
xk2 < xk3. We can continue in this manner and if we get to xn, then xk1 < xk2 < ··· < xkn−1 < xn = max I.
There is, however, the possibility that we ﬁnd max I = xkm at some step m < n. This means that there is

a function sup : DL → L that makes I (cid:55)→sup max I =(cid:87) I; use proposition (16.1).

Naturally Complete We say that a partial order P is naturally complete if and only if every natural
order N ⊆ P has supremum. That is, if min ↓ N exists for every N. Zorn’s lemma is applied to a partial
order whose natural orders are bounded; ↓ N (cid:44) ∅ for every N. Thus, we can apply Zorn’s lemma to
any naturally complete order and conclude that it has a maximal element.
There is a more particular deﬁnition, and it will be useful since it will help to take the concept of
completeness into the realm of sequences. Deﬁne the collection IS L of all natural order N ⊆ L such
that there exists a functor s : N → N; this means that we are considering the collection of natural orders
that can be arranged in a growing sequence. If there is a function sup : IS L ⊆ PL → L, we will say L
is IS-complete.
Proposition 16.3. If L is directed complete, then it is also naturally complete. This last implies that L
is IS -complete.

No proof is needed for this last result; this is not the case is the next result, however.

Proposition 16.4. A partial order L is naturally complete if and only if min Inv F exists for every
functor F : L → L.

Bounded Complete If we are to consider a lattice that is not bounded, the question may arise:
does supremum and inﬁmum exist for the bounded subsets of the lattice? We are compelled to make
deﬁnitions in such direction, and we do so in the same manner as we did in the last subdivision. A
partial order is upper bound complete if and only if ↓ A (cid:44) ∅ implies the existence of min ↓ A, for any
A ⊆ P. We also deﬁne the dual concept of lower bound complete for partial orders such that ↑ A (cid:44) ∅
implies the existence of max ↑ A.
Proposition 16.5. A partial order is upper bound complete if and only if it is lower bound complete.
Proof. Let us prove P is lower bound complete, given that it is upper bound complete. Let A (cid:44) ∅ such

that ↑ A (cid:44) ∅. We know(cid:87) ↑ A exists given ↑ A is bounded above. Since A (cid:44) ∅ we know that ↑ A is
bounded above by some a ∈ A. Now we show that(cid:86) A =(cid:87) ↑ A. First of all, if x is upper bound of
↑ A, then(cid:87) ↑ A ≤ x. Since any object of A is upper bound of ↑ A, we have(cid:87) ↑ A ≤ x, for all x ∈ A.
This is equivalent to saying(cid:87) ↑ A ∈↑ A, and if we recall proposition (16.1) we see that it is the same
as(cid:87) ↑ A = max ↑ A.

This means that there is maximum and minimum if the order is upper or lower bound complete. In
light of the previous proposition, we say L is bounded complete if it is upper or lower bound complete.
Given a set L, let us deﬁne an order, for the objects of L fL, by f ≤ g if there exists A ⊆ L such
that f is the function g|A; we are deﬁning an order in terms of complicated versions of systems.

91

16. COMPLETENESS
Proposition 16.6. The order deﬁned for L fL is complete and bounded complete.
Proof. If we are to show that the order is complete we must prove it is directed complete and there is
a minimum. Let I ⊆ L fL be directed; this is I ∈ DL fL. If f, g ∈ I we have h ∈ I such that f, g ≤ h,
which means f, g are h|A, h|B, respectively for sets A, B ⊆ L. So, if a ∈ Dom f ∩ Dom g we have
i∈I Dom i we can write Ia in place of the image, under any function of I

a, g; a, f . Thus, for any a ∈(cid:83)
that is deﬁned for a. Consider the set function sup I :(cid:83)
We shall prove that sup I =(cid:87) I. It is not diﬃcult to see that sup I is an upper bound of I. This is,
every i ∈ I is a simpliﬁed version of sup I. If f < sup I, then there exists a ∈(cid:83)

i∈I Dom i − Dom f .
This object is in some g ∈ I. For this, f is not an upper bound of I and we may conclude that there is a
function sup : DL fL → L fL that sends every object in the domain into its supremum. The minimum
of this order is the function minL fL : ∅ → L.
We are left to prove the order is bounded complete. Take a set X ⊆ L fL that is bounded by above;
there is h ∈↓ X such that every function x ∈ X is a simpliﬁed version of h. We can restate this saying
x∈X Ax → L the function that is a simpliﬁed

every x ∈ X is of the form h|Ax. Denote with sup X : (cid:83)
version of h; the arrows are a (cid:55)→ ha. Proving sup X =(cid:87) X is similar to what was done above.

i∈I Dom i → L that makes a (cid:55)→ Ia.

Complete Lattice

(cid:87) A. The function is order preserving; this follows from 4) in proposition (13.1).
(cid:87) A, we are able to construct

The main idea in the concept of complete lattice is that any subset of a lattice has supremum and
inﬁmum. We now give a duality for supremum and inﬁmum. Consider any function sup ∈ (PL) fL
such that A (cid:55)→sup
Theorem 16.7. Given a function sup : PL → L, such that A (cid:55)→sup
inf : PL → L, such that A (cid:55)→inf
sup A = inf ↓ A.

(cid:86) A, for every A ⊆ L.

In other words, inf A = sup ↑ A and

Moreover, sup is order preserving and inf is order reversing.

Proof. We will show that inﬁmum is sup ↑ A. Let x ∈ A, then x is an upper bound of ↑ A. This means

sup ↑ A ≤ x. Therefore, sup ↑ A is a lower bound of A; this is equivalent to(cid:87) ↑ A = sup ↑ A ∈↑ A.
Recall that(cid:87) A ∈ A if and only if(cid:87) A = max A, so that(cid:86) A = max ↑ A = sup ↑ A.

The reader can just as easily prove that sup A = inf ↓ A. The second part of this result is 4) from

proposition (13.1).

A partial order that has functions sup and inf is a complete lattice. Of course, any complete lattice

is a lattice. We see that complete lattices are, trivially, bounded complete.
Proposition 16.8. Let L be a complete lattice, then L and Lop are directed complete.
Proof. By deﬁnition, a complete lattice is obviously directed complete. Since L is complete, we know
that the inﬁmum of every subset exists. But, this is the same as saying that the supremum exists for
every subset of Lop. In particular, the supremum exists for every directed subset and therefore Lop is
directed complete.

92

CHAPTER V. LATTICE

Group

Subcollections
We will sometimes express G instead of the collection of objects of operation, A|G. Given a group G,
we can consider systems obtained from G by taking away objects of operation. These systems are the
object of study in the present discussion.

Power operation

We deﬁne an operation such that source and target objects are the objects of operation of G. It is a
non-commutative operation; that is why sometimes we decide to treat it as an ordered collection of
functions. We deﬁne this operation in a way that generalizes the deﬁnition of product in terms of sum.
Given a group G and any object x, in Z, let ↑x : G → G. For x ≥ 0, we deﬁne a; a↑x ∗ a, x + 1
and a; (ax)−1,−x. We accept a; 1, 0 which means a↑0 is the unit of the group, for every object a of G
that is not the unit. In case G is abelian, we have a functor ↑x : G → G. To prove this, we must prove
↑x,↑ x;∗(b↑x),∗b. We see that the relation holds for 0, so now we shall verify it holds for x + 1, given it
holds for x.

a ∗ b ;
a ∗ b ;
a ∗ b ;
a ∗ b ;

[(a ∗ b)↑x] ∗ (a ∗ b), x + 1
[(a↑x) ∗ (b↑x)] ∗ (a ∗ b), x + 1
[(a↑x) ∗ a] ∗ [(b↑x) ∗ b], x + 1
[a↑(x + 1)] ∗ [b↑(x + 1)], x + 1.

So, we are deﬁning a function Z → GFG, which is an operation that we will call the power
operation of G. Notice that this operation is almost full, in fact, for it to be full we only need to deﬁne
1 ↑ 0 but there is no consistent way so we leave the operation as it is. If e is a primitve unit, then for all
x ∈ N, we have e; e, x.
The product operation, deﬁned for integers, is the power for Z. We note this because a; a· x+a, x+1.
We now wish to ﬁnd the power operation of Q. We see that this is the operation ↑ : Z → QFQ, where
we deﬁne a; ax · a, x + 1.

Subgroup

For any subcollection A, of a group G, and n ∈ Z, we will write An to represent the collection of objects
of the form a↑n, where a is any object of A. We write AB to express the collection of all objects of the
form a ∗ b, where a, b ∈ A, B. For any group, G = G−1. A subgroup of G is a group H such that H ⊆ G.
The collection of all subgroups of G is represented by G⊆.

93

94

CHAPTER VI. GROUP

Theorem 17.1. The following are equivalent statements

1) H ∈ G⊆
2) HH−1 ⊆ H
3) H2, H−1 ⊆ H

Proof. It is clear from the deﬁnition of a group, that 1) ⇒ 2), 3). We shall prove 2), 3) ⇒ 1). Supposing
3) to be true, we ﬁnd HH−1 ⊆ H2 ⊆ H. So, all we need to prove is 2) implies 1). Suppose H has at least
one object x:

x ; 1, x−1
1 ; x−1, x−1
x ; x · y, (y−1)−1

These three statements indicate 1, x−1, x · y are all objects of HH−1 ⊆ H.

Theorem 17.2. Let ax ⊆ G represent the collection of objects of such form, for ﬁxed a ∈ G and every
x ∈ Z. Then ax is an abelian subgroup of G.
Proof. First we will prove cummutativity with a, and then we will prove ax(ax)−1 ⊆ ax. Due to the last
theorem, this proves ax is a group. After that we will verify commutatvity.

1) Suppose that for the product we have a, a; an, an:

a ; a ∗ an+1, an+1
a ; a ∗ (an ∗ a), an+1
(a ∗ an) ∗ a, an+1
a ;
(an ∗ a) ∗ a, an+1
a ;
a ; an+1 ∗ a, an+1
a, a ; an+1, an+1

2) Given n, suppose an; an−m, a−m, for any m:

an+1
an+1
an+1
an+1
an+1
an+1

(an ∗ a) ∗ a−m, (am)−1
;
(a ∗ an) ∗ a−m, (am)−1
;
; a ∗ (an ∗ a−m), (am)−1
; a ∗ an−m, (am)−1
; an−m ∗ a, (am)−1
; an−m+1, (am)−1

17. SUBCOLLECTIONS

3)

an
an
an
an
an, an

; an ∗ a−m, a−m
; an−m, a−m
; a−m+n, a−m
; a−m ∗ an, a−m
; a−m, a−m

95

Congruence Class

Given an equivalence relation ↔ for a collection A, carry out a seperation of this system, without losing
information. The systems obtained are the subcollections of all equivalent objects. That is, we have all
simple equivalence relations. For objects of the same simple equivalence relation we will express

Let H ∈ G⊆, and deﬁne a ∼ x if h; a, x for some h ∈ H. This is, the collection of objects x such
that we have an arrow h →∗x a. In other words, x such that its right operation has an arrow with source
object in H and target is a.
Theorem 17.3. The relation ∼ is an equivalence relation and a ∼ b will be expressed by

a ≡ b mod ↔ .

a ≡ b mod Hx.

Each simple equivalence relation resulting from ∼ will be called a right congruence class. Every right
congruence class is the subcollection Hx, for any x in the class. For every x ∈ G, the subcollection Hx
is the right congruence class that contains x and, in particular, H is a congruence class.
Proof.

1) We will prove ∼ is indeed an equivalence relation. It is obvious that the reﬂexive property holds;

if we take h to be the unit of G we have h; a, a. To prove symmetry, suppose h; a, b:

h−1
h−1
h−1

; h−1 ∗ (h ∗ b), a
(h−1 ∗ h) ∗ b, a
;
; b, a.

The result follows from h−1 ∈ H. Finally, let h1, h2 ∈ H such that h1; a, b and h2; b, c. From this,

h1 ∗ h2
h1 ∗ h2
h1 ∗ h2
h1 ∗ h2

(h1 ∗ h2) ∗ c, c
;
; h1 ∗ (h2 ∗ c), c
; h1 ∗ b, c
; a, c.

We may conclude because h1 ∗ h2 ∈ H.

96

CHAPTER VI. GROUP
2) Let x be an element of a right congruence class. Then, a ∈ Hx ⇔ h; a, x ⇔ h−1; x, a ⇔ a is

in the right congruence class of x.
If x ∈ G, then x is in some right equivalence class; this is guaranteed by the reﬂexive property.
But this class is the subcollection Hx, because x is an object of it.

Theorem 17.4. There is a bijective function H → Hx, for every x ∈ G.
Proof. Our bijective function is ∗x. Let y ∈ Hx, then there is a unique solution to h; y, x, for h. This
means ∗x is monic and onto Hx.

It is clear that we still have work to do in the subject matter of congruence classes. We can take an
analogous path to prove similar theorems for the left congruence class, xH. The equivalence relation in
this context is given by a ∼ x if x; a, h. Similar theorems hold for the left congruence class. Of course
this is the collection of objects x ∈ G such that x →∗h a, for some h ∈ H.

Invariant subspace

A subgroup N ⊆ G is called invariant or normal if xN = Nx, for every x ∈ G. Simply put, it is any
subgroup such that the equivalence relation it deﬁnes yields the same right and left congruence classes.
The collection of all invariant subgroups of G is denoted by ˆG⊆.
Theorem 17.5. The following are equivalent:

1) xN = Nx, for every x ∈ G.
2) xNx−1 = N, for every x ∈ G
3) xNx−1 ⊆ N, for every x ∈ G.

Proof.
1)⇒2) For n1 ∈ N, we ﬁnd n2 ∈ N such that

x ∗ n1
x ∗ n1
x ∗ n1
x ∗ n1

(x ∗ n1) ∗ x−1, x−1
;
(n2 ∗ x) ∗ x−1, x−1
;
; n2 ∗ (x ∗ x−1), x−1
; n2, x−1

which proves that xNx−1 ⊆ N. Now, to prove N ⊆ xNx−1:

; n1 ∗ (x ∗ x−1), 1
(n1 ∗ x) ∗ x−1, 1
;
(x ∗ n2) ∗ x−1, 1.
;

n1
n1
n1

18. QUOTIENT GROUP

3) ⇒ 1) We wish to prove xN ⊆ Nx:

97

(x ∗ n1) ∗ 1, n1
(x ∗ n1) ∗ (x−1 ∗ x), n1
[(x ∗ n1) ∗ x−1] ∗ x, n1

x ;
x ;
x ;
x ; n2 ∗ x, n1.

Similarly, we verify Nx ⊆ xN.

Quotient group

Given an invariant subgroup N, consider the collection of congruence classes. We say congruence
classes because the classes on the right and left are the same. Thus, we can write

a ≡ b mod N

if there is an n ∈ N such that n; a, b. We see that every class Nx is related to N in the same manner,
so we will consider each class to be a reﬂexive arrow for N. Let G/N be the algebraic category with
one c-object, N, and objects of operation are the congruence classes. The operation for the classes is
deﬁned by Nx; N(x ∗ y), Ny. It is left to the reader to verify that the deﬁnition is consistent.
Theorem 18.1. The algebraic category G/N is a group. Moreover, if G is abelian so is G/N.

Proof.

1) We ﬁrst verify that the operation has a unit and the objects are dual to it. After that we will prove

associativity. The unit in G/N is the invariant subspace N = Ne:

Nx ; Nx ∗ Ne, N
Nx ; N(x ∗ e), N
Nx ; Nx, N.

Duality amongst the objects is determined by

Nx ; Nx ∗ Nx−1, Nx−1
Nx ; N(x ∗ x−1), N
Nx ; Ne, Nx−1.

We turn to associativity:

98

CHAPTER VI. GROUP

2) Supposing G is abelian:

Na ; Na ∗ N(b ∗ c), Nb ∗ Nc
Na ; N[a ∗ (b ∗ c)], Nb ∗ Nc
Na ; N[(a ∗ b) ∗ c], Nb ∗ Nc
Na ; N(a ∗ b) ∗ Nc, Nb ∗ Nc
(Na ∗ Nb) ∗ Nc, Nb ∗ Nc
Na ;

Na, Nc ; Na ∗ Nb, Nb ∗ Nc.

Na ; N(a ∗ b), Nb
Na ; N(b ∗ a), Nb
Na ; Nb ∗ Na, Nb

Na, Na ; Nb, Nb

We will now construct the two trivial quotient groups of G, obtained by considering N to be the
subgroup that consists of the unit, and the subgroup G. The quotient group G/1 is the same group as G.
We verify this because we only have one solution to 1; x, y, for y. The solution is x and that means all
the relations are reﬂexive:

x ≡ x mod 1.

Another way of seeing this is by ﬁnding the class of x by xe.
congruence class.
solution h ∈ G for h; x, y. That is any x, y ∈ G are related. We also see that this is due to Gx = G.

If we turn to ﬁnd G/G, we see its the subgroup e. This is true due to the fact that we always have a

In other words, every x ∈ G is its

Commutator

We go on to study the more general cases of an abelian group, in which not necessarilly all objects of
operation commute with all the rest.

We know that the inverse of an object a ∗ b is unique and we ﬁnd it by
a ∗ b ;
(a ∗ b) ∗ (b−1 ∗ a−1), (b−1 ∗ a−1)
a ∗ b ; a ∗ [b ∗ (b−1 ∗ a−1)], (b−1 ∗ a−1)
a ∗ b ; a ∗ [(b ∗ b−1) ∗ a−1], (b−1 ∗ a−1)
a ∗ b ; a ∗ a−1, (b−1 ∗ a−1)
a ∗ b ; e, (b−1 ∗ a−1).

For the following deﬁnition, note that a, b commute if and only if (a ∗ b); e, (a−1 ∗ b−1).

19. COMMUTATOR
99
Deﬁnition 13. Deﬁne the operation (cid:3) : G → G f G such that a(cid:3)b (cid:55)→ (a ∗ b) ∗ (a−1 ∗ b−1), for a, b ∈ G.
The image of b, under a(cid:3) is [a, b] and we call it the commutator of a, b. In other words, the notation for
∗ expresses a ∗ b; [a, b], a−1 ∗ b−1. The object a is said to be commutable if a(cid:3) : G → G is the function
into e. Deﬁne Comm(G) as the subcollection of commutable objects and call it the center of G.

Notice that the center of G is, by deﬁnition, the ﬁber corresponding to the function into e. That is,

if we represent the function into e with → e, then Comm(G) = (cid:3)−1[→ e]
Proposition 19.1. The center of G veriﬁes the relation Comm(G) ∈ G⊆ and we say it is the central
subgroup of G.
Proof. Take a ∈ Comm(G) and b−1 ∈ [Comm(G)]−1. We shall verify [a ∗ b−1, x] is e, for every x ∈ G.

(a ∗ b−1) ∗ x ;
(a ∗ b−1) ∗ x ;
(a ∗ b−1) ∗ x ;
(a ∗ b−1) ∗ x ;
(a ∗ b−1) ∗ x ; e, (a ∗ b−1)−1 ∗ x−1.

[(a ∗ b−1) ∗ x] ∗ [(b ∗ a−1) ∗ x−1], (a ∗ b−1)−1 ∗ x−1
[(a ∗ b−1) ∗ b] ∗ [(x ∗ a−1) ∗ x−1], (a ∗ b−1)−1 ∗ x−1
(a ∗ x) ∗ (a−1 ∗ x−1), (a ∗ b−1)−1 ∗ x−1
(x ∗ a) ∗ (a−1 ∗ x−1), (a ∗ b−1)−1 ∗ x−1

We have shown that a ∗ b−1 is commutable; this proves Comm(G) ∈ G⊆.

Proposition 19.2. If C ⊆ Comm(G) is a subgroup, then C ∈ ˆG⊆; we say C is a central invariant
subgroup of G.
Proof. Observe xC = Cx, for any x ∈ G.

We now build the collection generated by the commutators of G. Take the collection of all commutators

[a, b], this is the subcollection [x, y]x,y∈G. We recall the notation Λ([x, y]x,y∈G), where Λ is the generailzed
operation function of the operation of the group, represents the image of all the operators Λn
i=1 in the
image of Λ. We will represent it with [G, G]. Of course, if a group contains all the commutators, it also
contains [G, G].
Proposition 19.3. The subcollection [G, G] ⊆ G is called the commutant of G and [G, G] ∈ ˆG⊆.
are subcollections of [G, G]. If c, d ∈ [G, G] then they can be represented by(cid:81)m
Proof. We ﬁrst want to prove that [G, G] is a subgroup. We will give a proof that [G, G]2 and [G, G]−1
For the second part, we can easily ﬁnd the inverse of(cid:81)n
j=1 D j,
where Ci, D j are all commutators of G. This means c ∗ d is of the same form as each of the factors c, d.
i=1 xi; e,(cid:81)n
(cid:81)n
i=1 xi, for xi ∈ G, by the following. Suppose
 n+1(cid:89)
x−1
n+1 ∗
 ,
n+1(cid:89)

 ∗ xn+1
 n(cid:89)
 ∗

i=1 Ci and(cid:81)n

n+1−i. Then, we ﬁnd

 ,

 ∗

n+1(cid:89)

i=1 x−1

x−1
n+2−i

x−1
n+2−i

i=2

x−1
n+2−i

xi

xi

x−1
n+1−i

xi

xi

;

;

i=1

i=1

i=1

xi

; e,

i=1

i=1

x−1
n+2−i.

n+1(cid:89)
n+1(cid:89)
n+1(cid:89)

i=1

i=1

 n(cid:89)
 n(cid:89)
n+1(cid:89)

i=1

i=1

100

CHAPTER VI. GROUP

If [a, b] ∈ [x, y]x,y∈G, then [a, b]−1 ∈ [x, y]x,y∈G. In fact,

(a ∗ b) ∗ (a−1 ∗ b−1)
(a ∗ b) ∗ (a−1 ∗ b−1)
(a ∗ b) ∗ (a−1 ∗ b−1)
(a ∗ b) ∗ (a−1 ∗ b−1)
(a ∗ b) ∗ (a−1 ∗ b−1)

[(a ∗ b) ∗ (a−1 ∗ b−1)] ∗ [(b ∗ a) ∗ (b−1 ∗ a−1)], (b ∗ a) ∗ (b−1 ∗ a−1)
[(a ∗ b) ∗ a−1] ∗ [a ∗ (b−1 ∗ a−1)], (b ∗ a) ∗ (b−1 ∗ a−1)
(a ∗ b) ∗ (b−1 ∗ a−1), (b ∗ a) ∗ (b−1 ∗ a−1)

;
;
;
; a ∗ a−1, (b ∗ a) ∗ (b−1 ∗ a−1)
; e, (b ∗ a) ∗ (b−1 ∗ a−1)
i=1 C−1

We can now say c−1 ∈ [G, G] because c−1;(cid:81)n
Next we need to prove [G, G] is invariant. It is easy to see that x ∗ c ∗ x−1;(cid:81)n

n+1−i, e.

i=1 x ∗ Ci ∗ x−1, e. Also,

x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]
x ∗ [a, b]

(x ∗ [a, b]) ∗ x−1, x−1
[x ∗ (a ∗ b) ∗ (a−1 ∗ b−1)] ∗ x−1, x−1

;
;
; x ∗ (a ∗ x−1) ∗ (x ∗ b) ∗ (x−1 ∗ x) ∗ (a−1 ∗ x−1) ∗ (x ∗ b−1) ∗ x−1, x−1
(x ∗ a ∗ x−1) ∗ (x ∗ b ∗ x−1) ∗ (x ∗ a−1 ∗ x−1) ∗ (x ∗ b−1 ∗ x−1), x−1
;
(x ∗ a ∗ x−1) ∗ (x ∗ b ∗ x−1) ∗ (x ∗ a ∗ x−1)−1 ∗ (x ∗ b ∗ x−1)−1, x−1
;

This means that x∗ [a, b]∗ x−1 is the same as [xax−1, xbx−1] ∈ [x, y]x,y∈G. This is, x∗ c∗ x−1 ∈ [G, G].

The commutant of G turns out to be a special subgroup. We cannot say [G, G] is abelian. However,

it does generate an abelian quotient group and it is the smallest subgroup of G to do so.
Theorem 19.4. Let N ∈ ˆG⊆. Then

1) G/[G, G] ∈ AbG⊆
2) G/N ∈ AbG⊆ ⇒ [G, G] ⊆ N
3) [N, N] ∈ ˆG⊆.

Proof.

1) To prove that G/[G, G] is a commutative subgroup of G we take [G, G]a and [G, G]b, for some

a, b ∈ G. We will show that their commutator is [G, G], the unit in G/[G, G].

[G, G]a ∗ [G, G]b ;
[G, G]a ∗ [G, G]b ;
[G, G]a ∗ [G, G]b ;

[G, G](a ∗ b) ∗ [G, G](a−1 ∗ b−1), [G, G]a−1 ∗ [G, G]b−1
[G, G][a, b], [G, G]a−1 ∗ [G, G]b−1
[G, G], [G, G]a−1 ∗ [G, G]b−1.

2) Suppose [G, G] is not a subset of N, then there is [a, b] ∈ [x, y]x,y∈G such that [a, b] (cid:60) N. The class

[G, G][a, b] is not N and therefore [[G, G]a, [G, G]b] do not commute.

20. TRANSFORMATION

101

Transformation
We have proven there is a functor + : Z → ZFZ, for groups. The main objective of the present section
is to build the tools necessary in order to generalize and clarify that situation.

Homomorphism.

Deﬁnition 14. We will say that a functor h : G1 → G2 is a homomorphism if G1, G2 are groups.

Condition 1) for functors means 1; 1, h. Also, for the product in G2,

hx−1
hx−1
hx−1
hx−1
hx−1

hx−1 ∗ [hx ∗ (hx)−1], 1
[hx−1 ∗ hx] ∗ (hx)−1, 1
h(x ∗ x−1) ∗ (hx)−1, 1
h1 ∗ (hx)−1, 1
(hx)−1, 1.

;
;
;
;
;

Here, 1 represents the unit, for both groups. A homomorphism with monic arrow function is called
monomorphism. If the arrow function of the homomorphism is onto, we will say it is an epimorphism.
Theorem 20.1. Let h : G1 → G2 be a homomorphism and g : G1 → G2 an epimorphism.

1) If H1 ∈ G1⊆, then hH1 ∈ G2⊆. And, if N1 ∈ ˆG1⊆, then gN1 ∈ ˆG2⊆.
2) If H2 ∈ G2⊆ then h−1H2 ∈ G1⊆. And, if N2 ∈ ˆG2⊆, then h−1N2 ∈ ˆG1⊆.

Proof.

1) We take two objects in hH1 and we wish to see if their product is, again in hH1. That is,

hh1
hh1
hh1

;
;
;

hh1 ∗ hh2, hh2
h(h1 ∗ h2), hh2
hh, hh2

for some h ∈ H1. Now, we suppose N1 is an invariant subspace; that is xN1x−1 ⊆ N1, for every
x ∈ G1. We shall prove gN1 is invariant as well. We wish to verify gx(gN1)gx−1 ⊆ gN1, for every
x ∈ G2. Any object of G2 can be represented by gx, for some x ∈ G1, because g is onto.Take an
object in gN1, say gn1 where n1 ∈ N1.

(gx ∗ gn1) ∗ gx−1, (gx)−1
;
; g[(x ∗ n1) ∗ x−1], (gx)−1
; gn2, (gx)−1
for some n2 ∈ N1. Therefore, (gx ∗ gn1) ∗ gx−1 ∈ gN1.

gx ∗ gn1
gx ∗ gn1
gx ∗ gn1

102

CHAPTER VI. GROUP

2) We follow the same line of thought as in 1). Thus, we take h1, h2 ∈ h−1H2 and we see that

hh1
hh1

;
;

hh1 ∗ hh2, hh2
h(h1 ∗ h2), hh2

which means h1 ∗ h2 ∈ h−1H2, because hh1 ∗ hh2 ∈ H2.
We now prove h−1N2 is invariant given N2 is invariant. Let n1 ∈ h−1N2, then

(x ∗ n1) ∗ x−1
(x ∗ n1) ∗ x−1
(x ∗ n1) ∗ x−1

h[(x ∗ n1) ∗ x−1], h
(hx ∗ hn1) ∗ hx−1, h

;
;
; n2, h

for some n2 ∈ N2. This is the same as (x ∗ n1) ∗ x−1 ∈ h−1N2.

Isomorphism

Theorem 20.2. Let h : G1 → G2 a homomorphism, and let Nul h = h−11. Then,

1) Nul h ∈ ˆG1⊆
2) There exists an isomorphism φ : G1/Nul h → Im h such that for every congruence, we have

(Nul h)x (cid:55)→φ hx. This isomorphism is called the natural isomorphism for G1/Nul h and Im h.

Proof.

1) We ﬁrst prove Nul h is a subgroup of G1. For e1, e2 ∈ Nul h, we have

2

e1 ∗ e−1
e1 ∗ e−1
e1 ∗ e−1
e1 ∗ e−1

2

2

2

h(e1 ∗ e−1
;
2 ), h
he1 ∗ he−1
;
2 , h
; 1 ∗ (he2)−1, h
; 1 ∗ 1, h

which means e1 ∗ e−1
for any e ∈ Nul h.

2 ∈ Nul h. To verify that Nul h is invariant we must prove (x∗ e)∗ x−1 ∈ Nul h,

(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1
(x ∗ e) ∗ x−1

h[(x ∗ e) ∗ x−1], h
(hx ∗ he) ∗ hx−1, h
(hx ∗ 1) ∗ (hx)−1, h
hx ∗ (hx)−1, h

;
;
;
;
; 1, h

20. TRANSFORMATION

2) To see that φ is a functor:

103

(Nul h)a ∗ (Nul h)b ; φ[Nul h(a) ∗ Nul h(b)], φ
(Nul h)a ∗ (Nul h)b ; φ[Nul h(a ∗ b)], φ
(Nul h)a ∗ (Nul h)b ;
(Nul h)a ∗ (Nul h)b ;
(Nul h)a ∗ (Nul h)b ; φ[(Nul h)a] ∗ φ[(Nul h)b], φ

h(a ∗ b), φ
ha ∗ hb, φ

We now prove that φ is onto. Every object Im h is of the form hx such that x ∈ G1. So we have,
for every hx ∈ Im h an object (Nul h)x ∈ G1/Nul h such that (Nul h)x (cid:55)→φ hx.
To verify we have an isomorphism, we look at the explicit relation between two objects in the
same congruence class. We have

if and only if e; a, b where e; 1, h. So, supposing a, b ∈ G1 are related, we get

a ≡ b mod Nul h

ha ∗ hb−1, (hb)−1

ha ;
ha ; φ[(Nul h)a] ∗ φ[(Nul h)b−1], (hb)−1
ha ; φ[(Nul h)a ∗ (Nul h)b−1], (hb)−1
ha ; φ[(Nul h)(a ∗ b−1)], (hb)−1
ha ; φ[(Nul h)((e ∗ b) ∗ b−1)], (hb)−1
ha ; φ[(Nul h)e], (hb)−1
he, (hb)−1
ha ;
ha ; 1, (hb)−1

That is, a, b are related if and only if ha, hb are the same object. Therefore, if (Nul h)a and (Nul h)b
are not the same class, then the image under φ are not the same object. We have thus proven the
functor is monic.

Theorem 20.3. An epimorphism g : G1 → G2 such that Nul g = {1} ⊆ G1, is an isomorphism.
Proof. We have an isomorphism G1/Nul g → G2. All we need is an isomorphism G1 → G1/Nul g. As
we have already seen, G1/Nul g = G1/1 = G1.

Automorphism

Given a group G, and an object x ∈ G, we will deﬁne an internal automorphism for G. It is deﬁned by
a (cid:55)→ (x ∗ a) ∗ x−1, and we will express it with ax.

104

CHAPTER VI. GROUP

Theorem 20.4. Let G be any group. Then,

1) The collection of internal automorphisms is a subcollection of {GFisoG}, and we denote it by aG.
2) The functor G → aG that makes x (cid:55)→ ax, is an epimorphism.
3) aG is an invariant subgroup of {GFisoG}.

Proof.

1) We see that, for a given x ∈ G, the internal automorphism ax is bijective. Let axa and axb be the

same object in the image of ax, then:

1, axa ; 1, axb

1, (x ∗ a) ∗ x−1

; 1, (x ∗ b) ∗ x−1

1, [(x ∗ a) ∗ x−1] ∗ x ; 1, [(x ∗ b) ∗ x−1] ∗ x

1, x ∗ a ; 1, x ∗ b

1, 1 ; x ∗ a, x ∗ b

x ∗ b, 1 ; x ∗ a, 1

x−1 ∗ (x ∗ b), 1 ; x−1 ∗ (x ∗ a), 1

b, 1 ; a, 1
1, 1 ; a, b
1, a ; 1, b

Now, to prove ax is onto, we see that for any a ∈ G, there exists x−1 ∗ (a ∗ x) ∈ G such that

(x−1 ∗ a) ∗ x ;
(x−1 ∗ a) ∗ x ;
(x−1 ∗ a) ∗ x ; a, ax.

(x ∗ [x−1 ∗ (a ∗ x)]) ∗ x−1, ax
(a ∗ x) ∗ x−1, ax

We see that we have a functor because

axa ;
axa ;
axa ;
axa ;
axa ;
axa ;

[(x ∗ a) ∗ x−1] ∗ [(x ∗ b) ∗ x−1], axb
[(x ∗ a) ∗ x−1] ∗ [x ∗ (b ∗ x−1)], axb
(x ∗ a) ∗ (b ∗ x−1), axb
[(x ∗ a) ∗ b] ∗ x−1, axb
[x ∗ (a ∗ b)] ∗ x−1, axb
ax(a ∗ b), axb.

20. TRANSFORMATION

105
2) We note that aG is an algebraic category. As a result, we can deﬁne a functor G → aG, such that
the function for objects of operation is deﬁned by x (cid:55)→ ax. We assert that this is a functor because,
for every a ∈ G:

a ;
a ;
a ;
a ;
a ;

[(x ∗ y) ∗ a] ∗ (x ∗ y)−1, ax∗y
[x ∗ (y ∗ a)] ∗ (y−1 ∗ x−1), ax∗y
([x ∗ (y ∗ a)] ∗ y−1) ∗ x−1, ax∗y
(x ∗ [(y ∗ a) ∗ y−1]) ∗ x−1, ax∗y
(ax ◦ ay)a, ax∗y

The facts proven thus far, and theorem 7, imply that aG is a subgroup of {GFisoG}.

Action Group

Deﬁnition 15. A group G, with operation ∗, is an action group of X if there exists a homomorphism ¯∗
from G into the group of transformations of X. We will write a (cid:55)→ a¯∗ to represent the images. The null
space of ¯∗ is called the nucleus of non-eﬀectivity for G. If ¯∗ is an isomorphism, then we will say G is an
eﬀective action group of X.

An action group is called transitive if for every x, y ∈ X there exists a ∈ G such that x; y, a¯∗.
Let f : X → Y be a bijective set function and f : G → H an isomorphism such that G, H is an action
group of X, Y, and the operations are ∗1,∗2. If f, f ; fa¯∗2, a¯∗1 we say (X, G) and (Y, H) are similar pairs.
All that is being said is f (a¯∗1x) and (fa)¯∗2( f x) are the same object, for every x ∈ X.
The deﬁnition of action group is one of the main reasons why deﬁning the operation as a function
O1 → O2 fO3 is convenient; to some extent it is easier to see the deep relation between operation and
group. Recall that the objects of O1 were called the actions of the operation; they are the objects that
act on the objects of O2. We conclude with the observation that providing ¯∗ is, in a way, extending the
operation of the group, so as to let objects of the collection be acted upon by objects of G.

Group, Action Group and Group of Transformations First of all, any action group of X is
homomorphic to the group of transformations of X. Also notice that any group of transformations of X
is an action group of X.
Any group G may be seen as the action group of any one object set {1}; we deﬁne the homomorphism
¯∗ as the trivial x (cid:55)→ I, where I : {1} → {1}, for all x ∈ G. We see that the images allowed for a
homomorphism ¯∗, depends on the objects of the collection X because this is what deﬁnes the diversity
of functions X → X. For example, we have the extreme case in which a group G is an action group of
a set with one object, {x}. In this case Nul ¯∗ = G because all functions are the same, by deﬁnition.

Similarity We see that a similar pair is the best thing that can happen, when considering two action
groups. One is entirely justiﬁed in considering these two as the same group, to far extent. The situation
is as follows, in considering a similar pair. Not only are the groups isomorphic, the collections for
which they are deﬁned are also bijective. And on top of this, the function and isomorphism commute
well, in the following sense. We can ﬁrst apply a¯∗1 and then f , or we can ﬁrst apply f and then (fa)¯∗2.

106

CHAPTER VI. GROUP

Transitive Action Groups In the following we will consider the collection of left congruence

classes. Such a collection of classes, with respect to H ⊆ G, is represented by G/xH.
Theorem 20.5. Let H ∈ G⊆, with operation ∗. Let ¯∗ : G → (G/xH) fiso(G/xH) be such that a (cid:55)→¯∗ a¯∗
and xH (cid:55)→a¯∗ (a ∗ x)H, for every a ∈ G. Then,

1) G is a transitive action group of G/xH, by the homomorphism ¯∗
2) H; H, x¯∗ ⇔ x ∈ H
3) N ∈ ˆH⊆ ⇒ N ⊆ Nul ¯∗ ⊆ H.

Proof.

1) We will see that ¯∗ is a homomorphism. We are left to prove a ∗ b; (a¯∗) ◦ (b¯∗), ¯∗. The domain and
image of the functions (a ∗ b)¯∗ and (a¯∗) ◦ (b¯∗) are the same, respectively. Let xH ∈ G/xH, for
some x ∈ G,

(a ∗ b)¯∗xH, (a ∗ b)¯∗
[(a ∗ b) ∗ x]H, (a ∗ b)¯∗
[a ∗ (b ∗ x)]H, (a ∗ b)¯∗

xH ;
xH ;
xH ;
xH ; a¯∗(b ∗ x)H, (a ∗ b)¯∗
xH ; a¯∗(b¯∗xH), (a ∗ b)¯∗

Now our aim is to give a proof that G is transitive. Let aH, bH ∈ G/xH, since G is a group,
b ∗ a−1 ∈ G so that

(b ∗ a−1)¯∗aH, (b ∗ a−1)¯∗
[(b ∗ a−1) ∗ a]H, (b ∗ a−1)¯∗

aH ;
aH ;
aH ; bH, (b ∗ a−1)¯∗.

2) x ∈ H if and only if x ∗ h ∈ H, for any h ∈ H. This last condition is true if and only if: a)

x¯∗H = xH ⊆ H, and b) H ⊆ xH = x¯∗H.
Suppose x∗h ∈ H, for every h ∈ H, then xH ⊆ H. We can equivalently say x ∈ H, and this means
that h ∈ H is the same as x ∗ (x−1 ∗ h) ∈ xH because x ∗ (x−1 ∗ h) is the same as (x ∗ x−1) ∗ h ∈ H.
Let us now suppose that conditions a) and b) are true, then x ∗ h ∈ xH = H, for any h ∈ H. We
may now conclude x ∈ H if and only if x¯∗H = H.

3) If we prove Nul ¯∗ =(cid:84)
Therefore, n ∈ xHx−1 and we can say N ⊆(cid:84)

x∈G xHx−1, we are done proving 3), for the following reasons. From this
we get Nul ¯∗ ⊆ H, for any x ∈ G, because H = eHe−1. Also, consider any invariant subgroup N,
of H, and let n ∈ N ⊆ H. Let x ∈ G, then there exists m ∈ N ⊆ H such that n is (x ∗ m) ∗ x−1.

x∈G xHx−1.

20. TRANSFORMATION

107

We know a ∈ Nul ¯∗ if and only if (a ∗ x)H = a¯∗xH = xH, for every x ∈ G. We have

H = eH

= (x−1 ∗ x)H
= (x−1 ∗ x)¯∗H
= x−1¯∗(x¯∗H)
= x−1¯∗xH
= x−1¯∗(a ∗ x)H
= [x−1 ∗ (a ∗ x)]H,

and because of the ﬁrst theorem in the section for congruence classes, x−1 ∗ (a ∗ x) ∈ H. From
this we have a ∗ x ∈ xH and after that, a ∈ xHx−1. All the implications are reversible, so we also

have(cid:84)

x∈G xHx−1 ⊆ Nul ¯∗.

Suppose G is a transitive action group of X and take a ∈ X. Deﬁne, Ga(cid:55)→b, for any b ∈ X, as the

subcollection of all x ∈ G such that a; b, x¯∗; transitivty of G assures that Ga(cid:55)→b (cid:44) ∅.
Proposition 20.6. If a ∈ X and G is an action group of X, we will say that Ga(cid:55)→a is the stable subgroup
for a, and represent it by Inv(a), in view of Inv(a) ∈ G⊆.
Proof. All we need to prove is that Inv(a)Inv(a)−1 ⊆ Inv(a). Let x ∈ Inv(a) and y−1 ∈ Inv(a)−1, for
some y ∈ Inv(a). We must verify (x ∗ y−1)¯∗ applies a to a.

(x ∗ y−1)¯∗a, (x ∗ y−1)¯∗
a ;
a ; x¯∗(y−1¯∗a), (x ∗ y−1)¯∗
a ; x¯∗[(y¯∗)−1a], (x ∗ y−1)¯∗
a ; x¯∗a, (x ∗ y−1)¯∗
a ; a, (x ∗ y−1)¯∗

Notice we are using the inverse function (y¯∗)−1 in virtue that y¯∗ is bijective. We use the fact that (y¯∗)−1,
just as y, applies a to a.

We get a another representation of the nucleus of non-eﬀectivity for G; again, as an intersection.

(cid:92)

x∈X

Nul ¯∗ =

Inv(x).

Now, consider the operation φ : X → X f PG that makes a (cid:55)→φ aφ and deﬁne aφ : X → PG as
the function that makes b (cid:55)→aφ Ga(cid:55)→b. The notation for this operation yields a; Ga(cid:55)→b, b. Another way of
saying this is in terms of the function is b; Ga(cid:55)→b, aφ.
Theorem 20.7. Let G be a transitive action group of X and I : G → G be the identity functor.

1) Im aφ = G/x Inv(a) and aφ|Im aφ = aφ|G/x Inv(a) is bijective

108

CHAPTER VI. GROUP

2) The pairs (X, G) and (G/x Inv(a), G) are similar, in virtue of aφ|G/x Inv(a), I
3) x ∈ Ga(cid:55)→b ⇒ Inv(b) = x Inv(a) x−1.

Proof.

1)

2)

3)

4)

Linear Space

Deﬁnition 16. Let K(+,·) be a ﬁeld and VG(∗) an abelian group. Represent the underlying set of VG
with V and recall that {VGFisoVG} is the group of automorphisms for VG. Let K(·) be the group under
the product, for the ﬁeld, and suppose there is a homomorphism ¯∗ : K(·) → {VGFisoVG}, such that

(VII.1)
This last condition means (a + b)¯∗u is the same as (a¯∗u)∗ (b¯∗u) where a, b ∈ K and u ∈ VG. The abelian
group VG, together with the homomorphism ¯∗ : K(·) → {VGFisoVG} forms a linear space.

a + b; (a¯∗u) ∗ (b¯∗u), u.

In other words we have a linear space iﬀ we have a ﬁeld that under product is homomorphic to the
group of automorphisms of an abelian group, in such a manner that (VII.1) holds. The linear space is
represented by V. The following establishes equivalence with the usual deﬁnition of linear space.
Proposition 20.8. A linear space V exists iﬀ there is an abelian group VG(∗) and a ﬁeld K(+,·) such
that there is an operation ¯∗ : A|K → {A|VG f A|VG} deﬁned so that (VII.1) holds, as well as

(a¯∗u) ∗ (a¯∗v), u ∗ v

a ;
1 ; u, u

a · b ; a¯∗(b¯∗u), u,

(VII.2)
(VII.3)
(VII.4)

in terms of the notation for ¯∗ and for 1 ∈ K(·).
Proof. Since the image of ¯∗ consists of automorphisms, we can say a¯∗(u∗ v) is the same as (a¯∗u)∗ (a¯∗v)
for every a in the ﬁeld and u, v in the abelian group VG. Secondly, since ¯∗ is a homomoprhism, we can
say 1¯∗ : VG → VG is the identity automorphism. Finally, the fact that ¯∗ is a homomorphism implies that
(a· b)¯∗ is the same automorphism as a¯∗◦ b¯∗, which is the same as saying (a· b)¯∗u is equal to a¯∗(b¯∗u).

109

110

CHAPTER VII. LINEAR SPACE

Topological System

Let X be a set and let X be an algebraic category with the c-object deﬁned as O|X := X. For every subset
A ⊆ X, we deﬁne an arrow in X, also denoted A, and we call it the arrow subset. If there is no fear for
confusion we may say it is a subset of X. To make sure X is a category, we must provide a composition
operation for the arrows. We know union is associative, and the emptyset acts as unit. Also, the union
of any two subsets of X, is also a subset of X. This means that X is an algebraic category with subsets
as objects of operation, and X as c-object.
Now we want to consider a subcategory of X. This will be the category that consists of the arrow
subset corresponding to the singletons of X. The category will be represented by {{X}}. The arrows
of this category are called points of X. We will include ∅ and X in the category of points. We are
identifying each subset (in the strict sense) of X, with the arrow subset, in X. We are doing this so that
we can view subsets as arrows in a category.

Two Descriptions, One System

Closure

Let T be a subcategory of X, such that ∅, X are arrow subsetes in T. We say T is the topological space,
while a topological system is a functor ClX : T → T so that for any point x, and any subset A, in T:

1) x ; x, ClX

2) ClXA ; ClXA, ClX.

Both 1) and 2) can be expressed as one condition. We are saying {{T}} is strongly invariant under
ClX, and ClX is a once eﬀective functor. Of course, we use {{T}} to represent the points of T. Simply
put, Im ClX ∪ {{T}} is strongly invariant. The concept of stongly invariant and once eﬀective function
is presented in the subdivision Sequence for Composition.
In view of the last statements, the two
conditions are replaced by the condition that any arrow subset A, in Im ClX ∪ {{T}}, satisﬁes A; A, ClX.
A topological system is an algebraic functor that leaves Im ClX ∪ {{T}} strongly invariant.
Any D in T such that D; D, ClX is said to be closed. The collection of all closed subsets of X is
represented by C. A subset V ⊆ X, complement of a closed subset, is in the collection of open sets, O.
Proposition 21.1. For any A, B ⊆ X, we have

1) A ⊆ ClXA
2) A ⊆ B ⇒ ClXA ⊆ ClXB.

111

112
Proof. A point x, of the space is adherent to A ⊆ X if x ∈ ClXA. We say ClXA is the adherence of A.
1) Let x ∈ A, then

CHAPTER VIII. TOPOLOGICAL SYSTEM

A ; ClX(A ∪ {x}), ClX
A ; ClXA ∪ ClX{x}, ClX
A ; ClXA ∪ {x}, ClX.

This last expression is ClXA = ClXA ∪ {x}, which is equivalent to x ∈ ClXA.

2) If A ⊆ B, we have

B ; ClX(A ∪ B), ClX
B ; ClXA ∪ ClXB, ClX

⇔ ClXB = ClXA ∪ ClXB
⇔ ClXA ⊆ ClXB.

Theorem 21.2. For any ﬁnite subcollections {Di}n

i=1 ⊆ C or {Vi}n

i=1 ⊆ O, we have

1) (cid:83)
2) (cid:84)

Proof.

i Di ∈ C
i Vi ∈ O.
1)

D1 ∪ D2
D1 ∪ D2
D1 ∪ D2

; ClX(D1 ∪ D2), ClX
; ClXD1 ∪ ClXD2, ClX
; D1 ∪ D2, ClX.

The ressult follows for n + 1 subsets if we suppose that it holds for n.

2)

;
This means (∩iVi)c ∈ C, which proves ∩iVi ∈ O.

Vi

i

i

i

(cid:92)
(cid:92)
(cid:92)
(cid:92)
(cid:92)

i

i

Vi

Vi

Vi

Vi

c
c
c
c
c

(cid:91)
(cid:91)

i

i

; ClX

; ClX

Vc
i , ClX

Di, ClX

;

;

i

(cid:91)
(cid:91)
(cid:92)

i

i

Di, ClX

Vc
i , ClX

c

Vi

, ClX.

22. NEIGHBORHOODS
Theorem 21.3. For any subcollections {Di}i ⊆ C or {Vi}i ⊆ O, we have

1) (cid:84)
2) (cid:83)

i Di ∈ C
i Vi ∈ O.

113

Proof. We know that ∩iDi ⊆ ClX ∩i Di. Thus, all we need to prove is ClX ∩i Di ⊆ ∩iDi. From 2) in
proposition 21.1, we get ClX ∩i Di ⊆ ClXD, for every D ∈ {Di}i. Then, ClX ∩i Di ⊆ ∩iClXDi = ∩iDi.

Theorem 21.4. Let A ⊆ X and CA the collection of all D such that A ⊆ D ∈ C. Then A;(cid:84)CA, ClX.

We can prove 2) as we did in the last theorem.

Proof. We know ClXA ∈ C, and since A ⊆ ClXA, we also have ClXA ∈ CA. This implies ∩CA ⊆ ClXA.
On the other hand, A ⊆ D, for every D ∈ CA, means A ⊆ ∩CA. From this, and the fact that ∩CA ∈ C,
we get ClXA ⊆ ClX ∩ CA = ∩CA.

Interior

To establish a topological system, a closure operation must be deﬁned for the subsets of X. However, it
is not absolutely necessary to deﬁne the closure for all subsets. If we deﬁne the collection of closed sets,
we will be able to say what the closure of any subset is; this is provided by the last theorem. Simply
put, to every family of subsets of X, that includes ∅, X ∈ C, there corresponds a topological sysytem.
Now, in view of the fact that a topological system can be established by deﬁning the closed sets, we see
that it is perfectly acceptable to give the topological system by deﬁning the dual objects of these. That
is, a topological system is deﬁned by deﬁning the collection of open sets for X.

Neighborhoods
For any point x ∈ X, the family Ox consists of all V such that x ∈ V ∈ O. Also, OA is the family of all V
such that A ⊇ V ∈ O.
Deﬁnition 17. A family B ⊆ O is called a base of the topological system ClX if for every ∅ (cid:44) V ∈ O we
neighborhood of x if there exists V ∈ O such that x ∈ V ⊆ N. A family Bx ⊆ O is a point base of x if for
every neighborhood N of x, there exists U ∈ Bx such that x ∈ U ⊆ N.

have V =(cid:83)(OV ∩ B). If x ∈ U ∈ B, we say U is a base-neighborhood of x. The subset N is called a

Notice that in order to speak of base-neighborhoods, we must have a ﬁxed base. So, anytime base-

neighborhoods are discussed, we will presuppose the choice of a base.

We wish to see that every point of X is in some base-neighborhood. We can easily prove this for
any non-trivial case in which their are at least two points. In this case, we have proven X is open and

therefore X =(cid:83)B. From this it follows that every point x is in some N ∈ B.

Proposition 22.1. For any x ∈ X we verify
1) Any base of X is a point base of x.
2) The collection of all base-neighborhoods of x is a point base of x.

CHAPTER VIII. TOPOLOGICAL SYSTEM

then there is an open set V such that x ∈ V ⊆ N. We know V =(cid:83)V, where V is a subfamily of B.

Proof. We will not give a proof for 1); this is a trivial observation. Let N be a neighborhood of x,
Therefore, x ∈ U ⊆ N, for some subset U ∈ V.
Theorem 22.2. A subset is open if and only if it is a neighborhood of every point it contains.
Proof. Clearly, V ∈ O is a neighborhood of any x ∈ V because V ⊆ V.

Suppose V is a neighborhood of every x ∈ N. Consider, for each x, the open set x ∈ Ux ⊆ V. It is

114

easily veriﬁed that V =(cid:83)

x Ux ∈ O.

Theorem 22.3. B is a base of CLX if and only if

U ∈ (OV ∩ B).

x ∈ V ∈ O ⇒ (∃U ∈ B)(x ∈ U ⊆ V).

Proof. B is a base of X if and only if V =(cid:83)(OV ∩ B). This last holds if and only if x ∈ U, for some
of(cid:83) β, for every β ⊆ B. Let¯ : T → T be the functor that assigns A (cid:55)→ ¯A, where x ∈ ¯A if and only if

Closure and Neighborhoods. Of course, once we have speciﬁed a base, we have also, unequivocally,
speciﬁed a topological system. This is due to the fact that a base determines a collection O that consists
x ∈ U ∈ B implies the existence of some a ∈ A ∩ U. When such a functor is given, we call it a closure
in terms of a base.

Theorem 22.4. The closure operation, deﬁned in terms of a base, forms a topological system which is
the same topological system determined by the open sets, generated from the base.

Proof. We must verify that ¯A =(cid:84)CA, where the closed subsets are those corresponding to open sets
given by the base. Let x ∈ ¯A, and take D ∈ CA. We show x (cid:60) Dc ∈ O in order to prove x ∈(cid:84)CA. If it
For the opposite inclusion, suppose x ∈(cid:84)CA and let x ∈ U ∈ B. If A∩U = ∅, then x (cid:60) A ⊆ Uc ∈ C.
which implies x (cid:60)(cid:84)CA. Therefore, a ∈ A ∩ U, for some a. Thus, x ∈ ¯A.

were true that x ∈ Dc, then there exists U ∈ B such that x ∈ U ⊆ Dc. But this means a ∈ U, for some
a ∈ A. This is a clear contradiction beacause A ⊆ D ⊆ Uc.

The collection of all the bases of a topological system is represented by B; in an analogous manner
we denote by O the collection of open sets that determine a topological system. Also, let T be the
collection of all topological systems of X. We will say CL : B → T is the function that assigns to each
base of X the unique closure in terms of the base. Represent by Cl : B → O → T, the function that
assigns to each base of X, the family of open sets, for which it is base, and then to that family, assigns
its corresponding closure function. The theorem says both are the same.

22. NEIGHBORHOODS

Acknowledgements

115

The present work began as a project to study several areas of mathematics using the perspective of
systems; objects and relations. The initial intention on the part of the author was to use this only as
a conceptual tool for personal understanding. In a series of talks with a fellow student, we came to
the conclusion that this focus was similar to the concept of category, where relations take the special
form of arrows. This enabled me to start writing out the present document. My thanks go out to Marco
Armenta, and several other costudents whom I had enriching conversations with.

The initial thoughts came about after reading a recommendation from my professor, Victor Pérez
Abreu. After making a project on axiomatic systems, for a class I was taking with the professor, he
recommended I read, An Eternal Golden Braid by Douglas R. Hofstadter. This book had profound
implications in my life and philosophical views. Since I am an undergraduate student of mathematics,
I decided to use this philosophy to start learning mathematics from scratch. Of course, lead by the
works of others in all areas of mathematics, I have tried to make an account of some basic principle of
mathematics. The professor was always giving great insight in his class and at talks in his oﬃce. His
patience and dedication to all his students is admirable.

After making some progress, I came across the work of Jouni J¨arvinen. This helped me to materialize
the constructions of the integers and rationals. Although, I initially came across an article on information
systems, this article was not ultimately of much help but his article [VIII] turned out to be of tremendous
help. I went back and tried to properly deﬁne the construction using the deﬁnitions provided in [VIII].
I have also made use of the online encyclopedia, Wikipedia.

Any error or misrepresentation of mathematical results that goes against established mathematical
standards are sole responsibility of the author, whom does not wish to involve any of the above mentioned,
on negative feedback, that shall certainly come. Of course, all feedback will be more than welcome by
the author.

Bibliography

I. Mac Lane, Saunders. Categories for the Working Mathematician. New York: Springer-Verlag,

1971.

II. Asperti, Andrea and Longo, Giuseppe. Categories Types and Structures: An Introduction to

Category Theory for the Working Computer Scientist. MIT Press, 1991.

III. R. M. Dudley. Real Analysis and Probability. Cambridge: Cambridge University Press, 2004.

IV. Mac Lane, Saunders and Birkhoﬀ, Garrett. Algebra. Providence, Rhode Island: AMS Chelsea

Publishing, Third edition 2004.

V. L. S. Pontriaguin. Grupos Continuos. Moscú: Editorial Mir, 1978.

VI. J. N. Sharma. Krishna’s Topology. Meerut: Krishna Prakashan Media (P) Ltd, 1979.

VII. Mariusz Wodzicki. Notes on Topology. December 3, 2010.

VIII J¨arvinen, Jouni. Lattice Theory for Rough Sets. Turku Centre for Computer Sciences. FI-20014

University of Turku, Finland.

116

CHAPTER VIII. TOPOLOGICAL SYSTEM

IX Bifunctor. V.E. Govorov (originator), Encyclopedia of Mathematics.

X A Concrete Introduction to Categories. William R. Schmitt. Department of Mathematics, George

Washington University.

XI Representable Functors and the Yoneda Lemma. Brown, Gordon. Spring 2015

XII math.stackexchange.com

